"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/libqp";
exports.ids = ["vendor-chunks/libqp"];
exports.modules = {

/***/ "(rsc)/./node_modules/libqp/lib/libqp.js":
/*!*****************************************!*\
  !*** ./node_modules/libqp/lib/libqp.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-useless-escape: 0 */ \nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\");\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst Transform = stream.Transform;\n/**\n * Encodes a Buffer into a Quoted-Printable encoded string\n *\n * @param {Buffer} buffer Buffer to convert\n * @returns {String} Quoted-Printable encoded string\n */ function encode(buffer) {\n    if (typeof buffer === \"string\") {\n        buffer = Buffer.from(buffer, \"utf-8\");\n    }\n    // usable characters that do not need encoding\n    let ranges = [\n        // https://tools.ietf.org/html/rfc2045#section-6.7\n        [\n            0x09\n        ],\n        [\n            0x0a\n        ],\n        [\n            0x0d\n        ],\n        [\n            0x20,\n            0x3c\n        ],\n        [\n            0x3e,\n            0x7e\n        ] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}\n    ];\n    let result = \"\";\n    let ord;\n    for(let i = 0, len = buffer.length; i < len; i++){\n        ord = buffer[i];\n        // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line\n        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {\n            result += String.fromCharCode(ord);\n            continue;\n        }\n        result += \"=\" + (ord < 0x10 ? \"0\" : \"\") + ord.toString(16).toUpperCase();\n    }\n    return result;\n}\n/**\n * Decodes a Quoted-Printable encoded string to a Buffer object\n *\n * @param {String} str Quoted-Printable encoded string\n * @returns {Buffer} Decoded value\n */ function decode(str) {\n    str = (str || \"\").toString()// remove invalid whitespace from the end of lines\n    .replace(/[\\t ]+$/gm, \"\")// remove soft line breaks\n    .replace(/\\=(?:\\r?\\n|$)/g, \"\");\n    let encodedBytesCount = (str.match(/\\=[\\da-fA-F]{2}/g) || []).length, bufferLength = str.length - encodedBytesCount * 2, chr, hex, buffer = Buffer.alloc(bufferLength), bufferPos = 0;\n    for(let i = 0, len = str.length; i < len; i++){\n        chr = str.charAt(i);\n        if (chr === \"=\" && (hex = str.substr(i + 1, 2)) && /[\\da-fA-F]{2}/.test(hex)) {\n            buffer[bufferPos++] = parseInt(hex, 16);\n            i += 2;\n            continue;\n        }\n        buffer[bufferPos++] = chr.charCodeAt(0);\n    }\n    return buffer;\n}\n/**\n * Adds soft line breaks to a Quoted-Printable string\n *\n * @param {String} str Quoted-Printable encoded string that might need line wrapping\n * @param {Number} [lineLength=76] Maximum allowed length for a line\n * @returns {String} Soft-wrapped Quoted-Printable encoded string\n */ function wrap(str, lineLength) {\n    str = (str || \"\").toString();\n    lineLength = lineLength || 76;\n    if (str.length <= lineLength) {\n        return str;\n    }\n    let pos = 0, len = str.length, match, code, line, lineMargin = Math.floor(lineLength / 3), result = \"\";\n    // insert soft linebreaks where needed\n    while(pos < len){\n        line = str.substr(pos, lineLength);\n        if (match = line.match(/\\r\\n/)) {\n            line = line.substr(0, match.index + match[0].length);\n            result += line;\n            pos += line.length;\n            continue;\n        }\n        if (line.substr(-1) === \"\\n\") {\n            // nothing to change here\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (match = line.substr(-lineMargin).match(/\\n.*?$/)) {\n            // truncate to nearest line break\n            line = line.substr(0, line.length - (match[0].length - 1));\n            result += line;\n            pos += line.length;\n            continue;\n        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \\t\\.,!\\?][^ \\t\\.,!\\?]*$/))) {\n            // truncate to nearest space\n            line = line.substr(0, line.length - (match[0].length - 1));\n        } else if (line.match(/\\=[\\da-f]{0,2}$/i)) {\n            // push incomplete encoding sequences to the next line\n            if (match = line.match(/\\=[\\da-f]{0,1}$/i)) {\n                line = line.substr(0, line.length - match[0].length);\n            }\n            // ensure that utf-8 sequences are not split\n            while(line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\\da-f]{2}){1,4}$/i) && (match = line.match(/\\=[\\da-f]{2}$/gi))){\n                code = parseInt(match[0].substr(1, 2), 16);\n                if (code < 128) {\n                    break;\n                }\n                line = line.substr(0, line.length - 3);\n                if (code >= 0xc0) {\n                    break;\n                }\n            }\n        }\n        if (pos + line.length < len && line.substr(-1) !== \"\\n\") {\n            if (line.length === lineLength && line.match(/\\=[\\da-f]{2}$/i)) {\n                line = line.substr(0, line.length - 3);\n            } else if (line.length === lineLength) {\n                line = line.substr(0, line.length - 1);\n            }\n            pos += line.length;\n            line += \"=\\r\\n\";\n        } else {\n            pos += line.length;\n        }\n        result += line;\n    }\n    return result;\n}\n/**\n * Helper function to check if a number is inside provided ranges\n *\n * @param {Number} nr Number to check for\n * @param {Array} ranges An Array of allowed values\n * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise\n */ function checkRanges(nr, ranges) {\n    for(let i = ranges.length - 1; i >= 0; i--){\n        if (!ranges[i].length) {\n            continue;\n        }\n        if (ranges[i].length === 1 && nr === ranges[i][0]) {\n            return true;\n        }\n        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Creates a transform stream for encoding data to Quoted-Printable encoding\n *\n * @constructor\n * @param {Object} options Stream options\n * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping\n */ class Encoder extends Transform {\n    constructor(options){\n        super();\n        // init Transform\n        this.options = options || {};\n        if (this.options.lineLength !== false) {\n            this.options.lineLength = this.options.lineLength || 76;\n        }\n        this._curLine = \"\";\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n        Transform.call(this, this.options);\n    }\n    _transform(chunk, encoding, done) {\n        let qp;\n        if (encoding !== \"buffer\") {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n        this.inputBytes += chunk.length;\n        if (this.options.lineLength) {\n            qp = this._curLine + encode(chunk);\n            qp = wrap(qp, this.options.lineLength);\n            qp = qp.replace(/(^|\\n)([^\\n]*)$/, (match, lineBreak, lastLine)=>{\n                this._curLine = lastLine;\n                return lineBreak;\n            });\n            if (qp) {\n                this.outputBytes += qp.length;\n                this.push(qp);\n            }\n        } else {\n            qp = encode(chunk);\n            this.outputBytes += qp.length;\n            this.push(qp, \"ascii\");\n        }\n        done();\n    }\n    _flush(done) {\n        if (this._curLine) {\n            this.outputBytes += this._curLine.length;\n            this.push(this._curLine, \"ascii\");\n        }\n        done();\n    }\n}\n/**\n * Creates a transform stream for decoding Quoted-Printable encoded strings\n * The input is not actually processed as a stream but concatted and processed as a single input\n *\n * @constructor\n * @param {Object} options Stream options\n */ class Decoder extends Transform {\n    constructor(options){\n        options = options || {};\n        super(options);\n        // init Transform\n        this.options = options;\n        this._curLine = \"\";\n        this.inputBytes = 0;\n        this.outputBytes = 0;\n        this.qpChunks = [];\n    }\n    _transform(chunk, encoding, done) {\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n        if (typeof chunk === \"string\") {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        this.qpChunks.push(chunk);\n        this.inputBytes += chunk.length;\n        done();\n    }\n    _flush(done) {\n        if (this.inputBytes) {\n            let buf = decode(Buffer.concat(this.qpChunks, this.inputBytes).toString());\n            this.outputBytes += buf.length;\n            this.push(buf);\n        }\n        done();\n    }\n}\n// expose to the world\nmodule.exports = {\n    encode,\n    decode,\n    wrap,\n    Encoder,\n    Decoder\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlicXAvbGliL2xpYnFwLmpzIiwibWFwcGluZ3MiOiJBQUFBLCtCQUErQixHQUUvQjtBQUVBLE1BQU0sRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1DLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1FLFlBQVlELE9BQU9DLFNBQVM7QUFFbEM7Ozs7O0NBS0MsR0FDRCxTQUFTQyxPQUFPQyxNQUFNO0lBQ2xCLElBQUksT0FBT0EsV0FBVyxVQUFVO1FBQzVCQSxTQUFTTCxPQUFPTSxJQUFJLENBQUNELFFBQVE7SUFDakM7SUFFQSw4Q0FBOEM7SUFDOUMsSUFBSUUsU0FBUztRQUNULGtEQUFrRDtRQUNsRDtZQUFDO1NBQUs7UUFDTjtZQUFDO1NBQUs7UUFDTjtZQUFDO1NBQUs7UUFDTjtZQUFDO1lBQU07U0FBSztRQUNaO1lBQUM7WUFBTTtTQUFLLENBQUMsbUVBQW1FO0tBQ25GO0lBQ0QsSUFBSUMsU0FBUztJQUNiLElBQUlDO0lBRUosSUFBSyxJQUFJQyxJQUFJLEdBQUdDLE1BQU1OLE9BQU9PLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsSUFBSztRQUMvQ0QsTUFBTUosTUFBTSxDQUFDSyxFQUFFO1FBQ2YsMkZBQTJGO1FBQzNGLElBQUlHLFlBQVlKLEtBQUtGLFdBQVcsQ0FBRSxFQUFDRSxRQUFRLFFBQVFBLFFBQVEsSUFBRyxLQUFPQyxDQUFBQSxNQUFNQyxNQUFNLEtBQUtOLE1BQU0sQ0FBQ0ssSUFBSSxFQUFFLEtBQUssUUFBUUwsTUFBTSxDQUFDSyxJQUFJLEVBQUUsS0FBSyxJQUFHLENBQUMsR0FBSTtZQUN0SUYsVUFBVU0sT0FBT0MsWUFBWSxDQUFDTjtZQUM5QjtRQUNKO1FBQ0FELFVBQVUsTUFBT0MsQ0FBQUEsTUFBTSxPQUFPLE1BQU0sRUFBQyxJQUFLQSxJQUFJTyxRQUFRLENBQUMsSUFBSUMsV0FBVztJQUMxRTtJQUVBLE9BQU9UO0FBQ1g7QUFFQTs7Ozs7Q0FLQyxHQUNE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RTtJQUN0QjtJQUVBVixXQUFXQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFO1FBQzlCLElBQUksQ0FBQ0YsU0FBUyxDQUFDQSxNQUFNdkMsTUFBTSxFQUFFO1lBQ3pCLE9BQU95QztRQUNYO1FBRUEsSUFBSSxPQUFPRixVQUFVLFVBQVU7WUFDM0JBLFFBQVFuRCxPQUFPTSxJQUFJLENBQUM2QyxPQUFPQztRQUMvQjtRQUVBLElBQUksQ0FBQ1EsUUFBUSxDQUFDSCxJQUFJLENBQUNOO1FBQ25CLElBQUksQ0FBQ0osVUFBVSxJQUFJSSxNQUFNdkMsTUFBTTtRQUUvQnlDO0lBQ0o7SUFFQUssT0FBT0wsSUFBSSxFQUFFO1FBQ1QsSUFBSSxJQUFJLENBQUNOLFVBQVUsRUFBRTtZQUNqQixJQUFJYyxNQUFNM0MsT0FBT2xCLE9BQU84RCxNQUFNLENBQUMsSUFBSSxDQUFDRixRQUFRLEVBQUUsSUFBSSxDQUFDYixVQUFVLEVBQUUvQixRQUFRO1lBQ3ZFLElBQUksQ0FBQ2dDLFdBQVcsSUFBSWEsSUFBSWpELE1BQU07WUFDOUIsSUFBSSxDQUFDNkMsSUFBSSxDQUFDSTtRQUNkO1FBRUFSO0lBQ0o7QUFDSjtBQUVBLHNCQUFzQjtBQUN0QlUsT0FBT0MsT0FBTyxHQUFHO0lBQ2I1RDtJQUNBYztJQUNBZTtJQUNBVTtJQUNBZ0I7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0FTV0QgQ2xpZW50IEh1Yi8uL25vZGVfbW9kdWxlcy9saWJxcC9saWIvbGlicXAuanM/YWU3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tdXNlbGVzcy1lc2NhcGU6IDAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKTtcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJyk7XG5jb25zdCBUcmFuc2Zvcm0gPSBzdHJlYW0uVHJhbnNmb3JtO1xuXG4vKipcbiAqIEVuY29kZXMgYSBCdWZmZXIgaW50byBhIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBRdW90ZWQtUHJpbnRhYmxlIGVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShidWZmZXIpIHtcbiAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyLCAndXRmLTgnKTtcbiAgICB9XG5cbiAgICAvLyB1c2FibGUgY2hhcmFjdGVycyB0aGF0IGRvIG5vdCBuZWVkIGVuY29kaW5nXG4gICAgbGV0IHJhbmdlcyA9IFtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIwNDUjc2VjdGlvbi02LjdcbiAgICAgICAgWzB4MDldLCAvLyA8VEFCPlxuICAgICAgICBbMHgwYV0sIC8vIDxMRj5cbiAgICAgICAgWzB4MGRdLCAvLyA8Q1I+XG4gICAgICAgIFsweDIwLCAweDNjXSwgLy8gPFNQPiFcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5OjtcbiAgICAgICAgWzB4M2UsIDB4N2VdIC8vID4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9XG4gICAgXTtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgbGV0IG9yZDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb3JkID0gYnVmZmVyW2ldO1xuICAgICAgICAvLyBpZiB0aGUgY2hhciBpcyBpbiBhbGxvd2VkIHJhbmdlLCB0aGVuIGtlZXAgYXMgaXMsIHVubGVzcyBpdCBpcyBhIHdzIGluIHRoZSBlbmQgb2YgYSBsaW5lXG4gICAgICAgIGlmIChjaGVja1JhbmdlcyhvcmQsIHJhbmdlcykgJiYgISgob3JkID09PSAweDIwIHx8IG9yZCA9PT0gMHgwOSkgJiYgKGkgPT09IGxlbiAtIDEgfHwgYnVmZmVyW2kgKyAxXSA9PT0gMHgwYSB8fCBidWZmZXJbaSArIDFdID09PSAweDBkKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG9yZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJz0nICsgKG9yZCA8IDB4MTAgPyAnMCcgOiAnJykgKyBvcmQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZyB0byBhIEJ1ZmZlciBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IERlY29kZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgIHN0ciA9IChzdHIgfHwgJycpXG4gICAgICAgIC50b1N0cmluZygpXG4gICAgICAgIC8vIHJlbW92ZSBpbnZhbGlkIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGxpbmVzXG4gICAgICAgIC5yZXBsYWNlKC9bXFx0IF0rJC9nbSwgJycpXG4gICAgICAgIC8vIHJlbW92ZSBzb2Z0IGxpbmUgYnJlYWtzXG4gICAgICAgIC5yZXBsYWNlKC9cXD0oPzpcXHI/XFxufCQpL2csICcnKTtcblxuICAgIGxldCBlbmNvZGVkQnl0ZXNDb3VudCA9IChzdHIubWF0Y2goL1xcPVtcXGRhLWZBLUZdezJ9L2cpIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgIGJ1ZmZlckxlbmd0aCA9IHN0ci5sZW5ndGggLSBlbmNvZGVkQnl0ZXNDb3VudCAqIDIsXG4gICAgICAgIGNocixcbiAgICAgICAgaGV4LFxuICAgICAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2MoYnVmZmVyTGVuZ3RoKSxcbiAgICAgICAgYnVmZmVyUG9zID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2hyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNociA9PT0gJz0nICYmIChoZXggPSBzdHIuc3Vic3RyKGkgKyAxLCAyKSkgJiYgL1tcXGRhLWZBLUZdezJ9Ly50ZXN0KGhleCkpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltidWZmZXJQb3MrK10gPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlcltidWZmZXJQb3MrK10gPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKipcbiAqIEFkZHMgc29mdCBsaW5lIGJyZWFrcyB0byBhIFF1b3RlZC1QcmludGFibGUgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBRdW90ZWQtUHJpbnRhYmxlIGVuY29kZWQgc3RyaW5nIHRoYXQgbWlnaHQgbmVlZCBsaW5lIHdyYXBwaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbmVMZW5ndGg9NzZdIE1heGltdW0gYWxsb3dlZCBsZW5ndGggZm9yIGEgbGluZVxuICogQHJldHVybnMge1N0cmluZ30gU29mdC13cmFwcGVkIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gd3JhcChzdHIsIGxpbmVMZW5ndGgpIHtcbiAgICBzdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuICAgIGxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoIHx8IDc2O1xuXG4gICAgaWYgKHN0ci5sZW5ndGggPD0gbGluZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGxldCBwb3MgPSAwLFxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgY29kZSxcbiAgICAgICAgbGluZSxcbiAgICAgICAgbGluZU1hcmdpbiA9IE1hdGguZmxvb3IobGluZUxlbmd0aCAvIDMpLFxuICAgICAgICByZXN1bHQgPSAnJztcblxuICAgIC8vIGluc2VydCBzb2Z0IGxpbmVicmVha3Mgd2hlcmUgbmVlZGVkXG4gICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICBsaW5lID0gc3RyLnN1YnN0cihwb3MsIGxpbmVMZW5ndGgpO1xuICAgICAgICBpZiAoKG1hdGNoID0gbGluZS5tYXRjaCgvXFxyXFxuLykpKSB7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmU7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lLnN1YnN0cigtMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGNoYW5nZSBoZXJlXG4gICAgICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICAgICAgICAgIHBvcyArPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGxpbmUuc3Vic3RyKC1saW5lTWFyZ2luKS5tYXRjaCgvXFxuLio/JC8pKSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdG8gbmVhcmVzdCBsaW5lIGJyZWFrXG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgbGluZS5sZW5ndGggLSAobWF0Y2hbMF0ubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmU7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA+IGxpbmVMZW5ndGggLSBsaW5lTWFyZ2luICYmIChtYXRjaCA9IGxpbmUuc3Vic3RyKC1saW5lTWFyZ2luKS5tYXRjaCgvWyBcXHRcXC4sIVxcP11bXiBcXHRcXC4sIVxcP10qJC8pKSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdG8gbmVhcmVzdCBzcGFjZVxuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gKG1hdGNoWzBdLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaW5lLm1hdGNoKC9cXD1bXFxkYS1mXXswLDJ9JC9pKSkge1xuICAgICAgICAgICAgLy8gcHVzaCBpbmNvbXBsZXRlIGVuY29kaW5nIHNlcXVlbmNlcyB0byB0aGUgbmV4dCBsaW5lXG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gbGluZS5tYXRjaCgvXFw9W1xcZGEtZl17MCwxfSQvaSkpKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgdXRmLTggc2VxdWVuY2VzIGFyZSBub3Qgc3BsaXRcbiAgICAgICAgICAgIHdoaWxlIChsaW5lLmxlbmd0aCA+IDMgJiYgbGluZS5sZW5ndGggPCBsZW4gLSBwb3MgJiYgIWxpbmUubWF0Y2goL14oPzo9W1xcZGEtZl17Mn0pezEsNH0kL2kpICYmIChtYXRjaCA9IGxpbmUubWF0Y2goL1xcPVtcXGRhLWZdezJ9JC9naSkpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IHBhcnNlSW50KG1hdGNoWzBdLnN1YnN0cigxLCAyKSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHhjMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zICsgbGluZS5sZW5ndGggPCBsZW4gJiYgbGluZS5zdWJzdHIoLTEpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSBsaW5lTGVuZ3RoICYmIGxpbmUubWF0Y2goL1xcPVtcXGRhLWZdezJ9JC9pKSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA9PT0gbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGluZSArPSAnPVxcclxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhIG51bWJlciBpcyBpbnNpZGUgcHJvdmlkZWQgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5yIE51bWJlciB0byBjaGVjayBmb3JcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlcyBBbiBBcnJheSBvZiBhbGxvd2VkIHZhbHVlc1xuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIHdhcyBmb3VuZCBpbnNpZGUgYWxsb3dlZCByYW5nZXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBjaGVja1JhbmdlcyhuciwgcmFuZ2VzKSB7XG4gICAgZm9yIChsZXQgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIXJhbmdlc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAxICYmIG5yID09PSByYW5nZXNbaV1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAyICYmIG5yID49IHJhbmdlc1tpXVswXSAmJiBuciA8PSByYW5nZXNbaV1bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZW5jb2RpbmcgZGF0YSB0byBRdW90ZWQtUHJpbnRhYmxlIGVuY29kaW5nXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdHJlYW0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbmVMZW5ndGg9NzZdIE1heGltdW0gbGVuZ2h0IGZvciBsaW5lcywgc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgd3JhcHBpbmdcbiAqL1xuY2xhc3MgRW5jb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIGluaXQgVHJhbnNmb3JtXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxpbmVMZW5ndGggPSB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCB8fCA3NjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1ckxpbmUgPSAnJztcblxuICAgICAgICB0aGlzLmlucHV0Qnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLm91dHB1dEJ5dGVzID0gMDtcblxuICAgICAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgIGxldCBxcDtcblxuICAgICAgICBpZiAoZW5jb2RpbmcgIT09ICdidWZmZXInKSB7XG4gICAgICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlucHV0Qnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGluZUxlbmd0aCkge1xuICAgICAgICAgICAgcXAgPSB0aGlzLl9jdXJMaW5lICsgZW5jb2RlKGNodW5rKTtcbiAgICAgICAgICAgIHFwID0gd3JhcChxcCwgdGhpcy5vcHRpb25zLmxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcXAgPSBxcC5yZXBsYWNlKC8oXnxcXG4pKFteXFxuXSopJC8sIChtYXRjaCwgbGluZUJyZWFrLCBsYXN0TGluZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1ckxpbmUgPSBsYXN0TGluZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZUJyZWFrO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChxcCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gcXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChxcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxcCA9IGVuY29kZShjaHVuayk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IHFwLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucHVzaChxcCwgJ2FzY2lpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gdGhpcy5fY3VyTGluZS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5fY3VyTGluZSwgJ2FzY2lpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZGVjb2RpbmcgUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZ3NcbiAqIFRoZSBpbnB1dCBpcyBub3QgYWN0dWFsbHkgcHJvY2Vzc2VkIGFzIGEgc3RyZWFtIGJ1dCBjb25jYXR0ZWQgYW5kIHByb2Nlc3NlZCBhcyBhIHNpbmdsZSBpbnB1dFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU3RyZWFtIG9wdGlvbnNcbiAqL1xuY2xhc3MgRGVjb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgLy8gaW5pdCBUcmFuc2Zvcm1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuXG4gICAgICAgIHRoaXMuaW5wdXRCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgPSAwO1xuXG4gICAgICAgIHRoaXMucXBDaHVua3MgPSBbXTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICBpZiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5xcENodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5pbnB1dEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRCeXRlcykge1xuICAgICAgICAgICAgbGV0IGJ1ZiA9IGRlY29kZShCdWZmZXIuY29uY2F0KHRoaXMucXBDaHVua3MsIHRoaXMuaW5wdXRCeXRlcykudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2goYnVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG59XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGVuY29kZSxcbiAgICBkZWNvZGUsXG4gICAgd3JhcCxcbiAgICBFbmNvZGVyLFxuICAgIERlY29kZXJcbn07XG4iXSwibmFtZXMiOlsiQnVmZmVyIiwicmVxdWlyZSIsInN0cmVhbSIsIlRyYW5zZm9ybSIsImVuY29kZSIsImJ1ZmZlciIsImZyb20iLCJyYW5nZXMiLCJyZXN1bHQiLCJvcmQiLCJpIiwibGVuIiwibGVuZ3RoIiwiY2hlY2tSYW5nZXMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJ0b1N0cmluZyIsInRvVXBwZXJDYXNlIiwiZGVjb2RlIiwic3RyIiwicmVwbGFjZSIsImVuY29kZWRCeXRlc0NvdW50IiwibWF0Y2giLCJidWZmZXJMZW5ndGgiLCJjaHIiLCJoZXgiLCJhbGxvYyIsImJ1ZmZlclBvcyIsImNoYXJBdCIsInN1YnN0ciIsInRlc3QiLCJwYXJzZUludCIsImNoYXJDb2RlQXQiLCJ3cmFwIiwibGluZUxlbmd0aCIsInBvcyIsImNvZGUiLCJsaW5lIiwibGluZU1hcmdpbiIsIk1hdGgiLCJmbG9vciIsImluZGV4IiwibnIiLCJFbmNvZGVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2N1ckxpbmUiLCJpbnB1dEJ5dGVzIiwib3V0cHV0Qnl0ZXMiLCJjYWxsIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJkb25lIiwicXAiLCJsaW5lQnJlYWsiLCJsYXN0TGluZSIsInB1c2giLCJfZmx1c2giLCJEZWNvZGVyIiwicXBDaHVua3MiLCJidWYiLCJjb25jYXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/libqp/lib/libqp.js\n");

/***/ })

};
;