"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mailparser";
exports.ids = ["vendor-chunks/mailparser"];
exports.modules = {

/***/ "(rsc)/./node_modules/mailparser/index.js":
/*!******************************************!*\
  !*** ./node_modules/mailparser/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst MailParser = __webpack_require__(/*! ./lib/mail-parser */ \"(rsc)/./node_modules/mailparser/lib/mail-parser.js\");\nconst simpleParser = __webpack_require__(/*! ./lib/simple-parser */ \"(rsc)/./node_modules/mailparser/lib/simple-parser.js\");\nmodule.exports = {\n    MailParser,\n    simpleParser\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDO0FBRTdCRSxPQUFPQyxPQUFPLEdBQUc7SUFDYko7SUFDQUU7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL0FTV0QgQ2xpZW50IEh1Yi8uL25vZGVfbW9kdWxlcy9tYWlscGFyc2VyL2luZGV4LmpzP2YxODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNYWlsUGFyc2VyID0gcmVxdWlyZSgnLi9saWIvbWFpbC1wYXJzZXInKTtcbmNvbnN0IHNpbXBsZVBhcnNlciA9IHJlcXVpcmUoJy4vbGliL3NpbXBsZS1wYXJzZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWFpbFBhcnNlcixcbiAgICBzaW1wbGVQYXJzZXJcbn07XG4iXSwibmFtZXMiOlsiTWFpbFBhcnNlciIsInJlcXVpcmUiLCJzaW1wbGVQYXJzZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mailparser/lib/mail-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/mailparser/lib/mail-parser.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst mailsplit = __webpack_require__(/*! @zone-eu/mailsplit */ \"(rsc)/./node_modules/@zone-eu/mailsplit/index.js\");\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\nconst addressparser = __webpack_require__(/*! nodemailer/lib/addressparser */ \"(rsc)/./node_modules/nodemailer/lib/addressparser/index.js\");\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst Splitter = mailsplit.Splitter;\nconst ChunkedPassthrough = mailsplit.ChunkedPassthrough;\nconst punycode = __webpack_require__(/*! punycode.js */ \"(rsc)/./node_modules/punycode.js/punycode.es6.js\");\nconst FlowedDecoder = __webpack_require__(/*! @zone-eu/mailsplit/lib/flowed-decoder */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\");\nconst StreamHash = __webpack_require__(/*! ./stream-hash */ \"(rsc)/./node_modules/mailparser/lib/stream-hash.js\");\nconst iconv = __webpack_require__(/*! iconv-lite */ \"(rsc)/./node_modules/iconv-lite/lib/index.js\");\nconst { htmlToText } = __webpack_require__(/*! html-to-text */ \"(rsc)/./node_modules/html-to-text/lib/html-to-text.cjs\");\nconst he = __webpack_require__(/*! he */ \"(rsc)/./node_modules/he/he.js\");\nconst linkify = __webpack_require__(/*! linkify-it */ \"(rsc)/./node_modules/linkify-it/build/index.cjs.js\")();\nconst tlds = __webpack_require__(/*! tlds */ \"(rsc)/./node_modules/tlds/index.json\");\nconst encodingJapanese = __webpack_require__(/*! encoding-japanese */ \"(rsc)/./node_modules/encoding-japanese/src/index.js\");\nlinkify.tlds(tlds) // Reload with full tlds list\n.tlds(\"onion\", true) // Add unofficial `.onion` domain\n.add(\"git:\", \"http:\") // Add `git:` ptotocol as \"alias\"\n.add(\"ftp:\", null) // Disable `ftp:` ptotocol\n.set({\n    fuzzyIP: true,\n    fuzzyLink: true,\n    fuzzyEmail: true\n});\n// twitter linkifier from\n// https://github.com/markdown-it/linkify-it#example-2-add-twitter-mentions-handler\nlinkify.add(\"@\", {\n    validate (text, pos, self) {\n        let tail = text.slice(pos);\n        if (!self.re.twitter) {\n            self.re.twitter = new RegExp(\"^([a-zA-Z0-9_]){1,15}(?!_)(?=$|\" + self.re.src_ZPCc + \")\");\n        }\n        if (self.re.twitter.test(tail)) {\n            // Linkifier allows punctuation chars before prefix,\n            // but we additionally disable `@` (\"@@mention\" is invalid)\n            if (pos >= 2 && tail[pos - 2] === \"@\") {\n                return false;\n            }\n            return tail.match(self.re.twitter)[0].length;\n        }\n        return 0;\n    },\n    normalize (match) {\n        match.url = \"https://twitter.com/\" + match.url.replace(/^@/, \"\");\n    }\n});\nclass IconvDecoder extends Transform {\n    constructor(Iconv, charset){\n        super();\n        // Iconv throws error on ks_c_5601-1987 when it is mapped to EUC-KR\n        // https://github.com/bnoordhuis/node-iconv/issues/169\n        if (charset.toLowerCase() === \"ks_c_5601-1987\") {\n            charset = \"CP949\";\n        }\n        this.stream = new Iconv(charset, \"UTF-8//TRANSLIT//IGNORE\");\n        this.inputEnded = false;\n        this.endCb = false;\n        this.stream.on(\"error\", (err)=>this.emit(\"error\", err));\n        this.stream.on(\"data\", (chunk)=>this.push(chunk));\n        this.stream.on(\"end\", ()=>{\n            this.inputEnded = true;\n            if (typeof this.endCb === \"function\") {\n                this.endCb();\n            }\n        });\n    }\n    _transform(chunk, encoding, done) {\n        this.stream.write(chunk);\n        done();\n    }\n    _flush(done) {\n        this.endCb = done;\n        this.stream.end();\n    }\n}\nclass JPDecoder extends Transform {\n    constructor(charset){\n        super();\n        this.charset = charset;\n        this.chunks = [];\n        this.chunklen = 0;\n    }\n    _transform(chunk, encoding, done) {\n        if (typeof chunk === \"string\") {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        this.chunks.push(chunk);\n        this.chunklen += chunk.length;\n        done();\n    }\n    _flush(done) {\n        let input = Buffer.concat(this.chunks, this.chunklen);\n        try {\n            let output = encodingJapanese.convert(input, {\n                to: \"UNICODE\",\n                from: this.charset,\n                type: \"string\"\n            });\n            if (typeof output === \"string\") {\n                output = Buffer.from(output);\n            }\n            this.push(output);\n        } catch (err) {\n            // keep as is on errors\n            this.push(input);\n        }\n        done();\n    }\n}\nclass MailParser extends Transform {\n    constructor(config){\n        super({\n            readableObjectMode: true,\n            writableObjectMode: false\n        });\n        this.options = config || {};\n        this.chunkedPassthrough = new ChunkedPassthrough();\n        this.splitter = new Splitter(config);\n        this.chunkedPassthrough.pipe(this.splitter);\n        this.finished = false;\n        this.waitingEnd = false;\n        this.headers = false;\n        this.headerLines = false;\n        this.endReceived = false;\n        this.reading = false;\n        this.hasFailed = false;\n        this.tree = false;\n        this.curnode = false;\n        this.waitUntilAttachmentEnd = false;\n        this.attachmentCallback = false;\n        this.hasHtml = false;\n        this.hasText = false;\n        this.text = false;\n        this.html = false;\n        this.textAsHtml = false;\n        this.attachmentList = [];\n        this.boundaries = [];\n        this.textTypes = [\n            \"text/plain\",\n            \"text/html\"\n        ].concat(!this.options.keepDeliveryStatus ? \"message/delivery-status\" : []);\n        this.decoder = this.getDecoder();\n        this.chunkedPassthrough.on(\"error\", (err)=>{\n            this.splitter.emit(\"error\", err);\n        });\n        this.splitter.on(\"readable\", ()=>{\n            if (this.reading) {\n                return false;\n            }\n            this.readData();\n        });\n        this.splitter.on(\"end\", ()=>{\n            this.endReceived = true;\n            if (!this.reading) {\n                this.endStream();\n            }\n        });\n        this.splitter.on(\"error\", (err)=>{\n            this.hasFailed = true;\n            if (typeof this.waitingEnd === \"function\") {\n                return this.waitingEnd(err);\n            }\n            this.emit(\"error\", err);\n        });\n        this.libmime = new libmime.Libmime({\n            Iconv: this.options.Iconv\n        });\n    }\n    getDecoder() {\n        if (this.options.Iconv) {\n            const Iconv = this.options.Iconv;\n            // create wrapper\n            return {\n                decodeStream (charset) {\n                    return new IconvDecoder(Iconv, charset);\n                }\n            };\n        } else {\n            return {\n                decodeStream (charset) {\n                    charset = (charset || \"ascii\").toString().trim().toLowerCase();\n                    if (/^jis|^iso-?2022-?jp|^EUCJP/i.test(charset)) {\n                        // special case not supported by iconv-lite\n                        return new JPDecoder(charset);\n                    }\n                    return iconv.decodeStream(charset);\n                }\n            };\n        }\n    }\n    readData() {\n        if (this.hasFailed) {\n            return false;\n        }\n        this.reading = true;\n        let data = this.splitter.read();\n        if (data === null) {\n            this.reading = false;\n            if (this.endReceived) {\n                this.endStream();\n            }\n            return;\n        }\n        this.processChunk(data, (err)=>{\n            if (err) {\n                if (typeof this.waitingEnd === \"function\") {\n                    return this.waitingEnd(err);\n                }\n                return this.emit(\"error\", err);\n            }\n            setImmediate(()=>this.readData());\n        });\n    }\n    endStream() {\n        this.finished = true;\n        if (this.curnode && this.curnode.decoder) {\n            this.curnode.decoder.end();\n        }\n        if (typeof this.waitingEnd === \"function\") {\n            this.waitingEnd();\n        }\n    }\n    _transform(chunk, encoding, done) {\n        if (!chunk || !chunk.length) {\n            return done();\n        }\n        if (this.chunkedPassthrough.write(chunk) === false) {\n            return this.chunkedPassthrough.once(\"drain\", ()=>{\n                done();\n            });\n        } else {\n            return done();\n        }\n    }\n    _flush(done) {\n        setImmediate(()=>this.chunkedPassthrough.end());\n        if (this.finished) {\n            return this.cleanup(done);\n        }\n        this.waitingEnd = ()=>{\n            this.cleanup(()=>{\n                done();\n            });\n        };\n    }\n    cleanup(done) {\n        let finish = ()=>{\n            try {\n                let t = this.getTextContent();\n                this.push(t);\n            } catch (err) {\n                return this.emit(\"error\", err);\n            }\n            done();\n        };\n        if (this.curnode && this.curnode.decoder && this.curnode.decoder.readable && !this.decoderEnded) {\n            (this.curnode.contentStream || this.curnode.decoder).once(\"end\", ()=>{\n                finish();\n            });\n            this.curnode.decoder.end();\n        } else {\n            setImmediate(()=>{\n                finish();\n            });\n        }\n    }\n    processHeaders(lines) {\n        let headers = new Map();\n        (lines || []).forEach((line)=>{\n            let key = line.key;\n            let value = ((this.libmime.decodeHeader(line.line) || {}).value || \"\").toString().trim();\n            value = Buffer.from(value, \"binary\").toString();\n            switch(key){\n                case \"content-type\":\n                case \"content-disposition\":\n                case \"dkim-signature\":\n                    value = this.libmime.parseHeaderValue(value);\n                    if (value.value) {\n                        value.value = this.libmime.decodeWords(value.value);\n                    }\n                    Object.keys(value && value.params || {}).forEach((key)=>{\n                        try {\n                            value.params[key] = this.libmime.decodeWords(value.params[key]);\n                        } catch (E) {\n                        // ignore, keep as is\n                        }\n                    });\n                    break;\n                case \"date\":\n                    {\n                        let dateValue = new Date(value);\n                        if (isNaN(dateValue)) {\n                            // date parsing failed :S\n                            dateValue = new Date();\n                        }\n                        value = dateValue;\n                        break;\n                    }\n                case \"subject\":\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                    // ignore, keep as is\n                    }\n                    break;\n                case \"references\":\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                    // ignore\n                    }\n                    value = value.split(/\\s+/).map(this.ensureMessageIDFormat);\n                    break;\n                case \"message-id\":\n                case \"in-reply-to\":\n                    try {\n                        value = this.libmime.decodeWords(value);\n                    } catch (E) {\n                    // ignore\n                    }\n                    value = this.ensureMessageIDFormat(value);\n                    break;\n                case \"priority\":\n                case \"x-priority\":\n                case \"x-msmail-priority\":\n                case \"importance\":\n                    key = \"priority\";\n                    value = this.parsePriority(value);\n                    break;\n                case \"from\":\n                case \"to\":\n                case \"cc\":\n                case \"bcc\":\n                case \"sender\":\n                case \"reply-to\":\n                case \"delivered-to\":\n                case \"return-path\":\n                case \"disposition-notification-to\":\n                    value = addressparser(value);\n                    this.decodeAddresses(value);\n                    value = {\n                        value,\n                        html: this.getAddressesHTML(value),\n                        text: this.getAddressesText(value)\n                    };\n                    break;\n            }\n            // handle list-* keys\n            if (key.substr(0, 5) === \"list-\") {\n                value = this.parseListHeader(key.substr(5), value);\n                key = \"list\";\n            }\n            if (value) {\n                if (!headers.has(key)) {\n                    headers.set(key, [].concat(value || []));\n                } else if (Array.isArray(value)) {\n                    headers.set(key, headers.get(key).concat(value));\n                } else {\n                    headers.get(key).push(value);\n                }\n            }\n        });\n        // keep only the first value\n        let singleKeys = [\n            \"message-id\",\n            \"content-id\",\n            \"from\",\n            \"sender\",\n            \"in-reply-to\",\n            \"reply-to\",\n            \"subject\",\n            \"date\",\n            \"content-disposition\",\n            \"content-type\",\n            \"content-transfer-encoding\",\n            \"priority\",\n            \"mime-version\",\n            \"content-description\",\n            \"precedence\",\n            \"errors-to\",\n            \"disposition-notification-to\"\n        ];\n        headers.forEach((value, key)=>{\n            if (Array.isArray(value)) {\n                if (singleKeys.includes(key) && value.length) {\n                    headers.set(key, value[value.length - 1]);\n                } else if (value.length === 1) {\n                    headers.set(key, value[0]);\n                }\n            }\n            if (key === \"list\") {\n                // normalize List-* headers\n                let listValue = {};\n                [].concat(value || []).forEach((val)=>{\n                    Object.keys(val || {}).forEach((listKey)=>{\n                        listValue[listKey] = val[listKey];\n                    });\n                });\n                headers.set(key, listValue);\n            }\n        });\n        return headers;\n    }\n    parseListHeader(key, value) {\n        let addresses = addressparser(value);\n        let response = {};\n        let data = addresses.map((address)=>{\n            if (/^https?:/i.test(address.name)) {\n                response.url = address.name;\n            } else if (address.name) {\n                response.name = address.name;\n            }\n            if (/^mailto:/.test(address.address)) {\n                response.mail = address.address.substr(7);\n            } else if (address.address && address.address.indexOf(\"@\") < 0) {\n                response.id = address.address;\n            } else if (address.address) {\n                response.mail = address.address;\n            }\n            if (Object.keys(response).length) {\n                return response;\n            }\n            return false;\n        }).filter((address)=>address);\n        if (data.length) {\n            return {\n                [key]: response\n            };\n        }\n        return false;\n    }\n    parsePriority(value) {\n        value = value.toLowerCase().trim();\n        if (!isNaN(parseInt(value, 10))) {\n            // support \"X-Priority: 1 (Highest)\"\n            value = parseInt(value, 10) || 0;\n            if (value === 3) {\n                return \"normal\";\n            } else if (value > 3) {\n                return \"low\";\n            } else {\n                return \"high\";\n            }\n        } else {\n            switch(value){\n                case \"non-urgent\":\n                case \"low\":\n                    return \"low\";\n                case \"urgent\":\n                case \"high\":\n                    return \"high\";\n            }\n        }\n        return \"normal\";\n    }\n    ensureMessageIDFormat(value) {\n        if (!value.length) {\n            return false;\n        }\n        if (value.charAt(0) !== \"<\") {\n            value = \"<\" + value;\n        }\n        if (value.charAt(value.length - 1) !== \">\") {\n            value += \">\";\n        }\n        return value;\n    }\n    decodeAddresses(addresses) {\n        let processedAddress = new WeakSet();\n        for(let i = 0; i < addresses.length; i++){\n            let address = addresses[i];\n            address.name = (address.name || \"\").toString().trim();\n            if (!address.address && /^(=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)(\\s*=\\?([^?]+)\\?[Bb]\\?[^?]*\\?=)*$/.test(address.name) && !processedAddress.has(address)) {\n                let parsed = addressparser(this.libmime.decodeWords(address.name));\n                if (parsed.length) {\n                    parsed.forEach((entry)=>{\n                        processedAddress.add(entry);\n                        addresses.push(entry);\n                    });\n                }\n                // remove current element\n                addresses.splice(i, 1);\n                i--;\n                continue;\n            }\n            if (address.name) {\n                try {\n                    address.name = this.libmime.decodeWords(address.name);\n                } catch (E) {\n                //ignore, keep as is\n                }\n            }\n            if (/@xn--/.test(address.address)) {\n                try {\n                    address.address = address.address.substr(0, address.address.lastIndexOf(\"@\") + 1) + punycode.toUnicode(address.address.substr(address.address.lastIndexOf(\"@\") + 1));\n                } catch (E) {\n                // Not a valid punycode string; keep as is\n                }\n            }\n            if (address.group) {\n                this.decodeAddresses(address.group);\n            }\n        }\n    }\n    createNode(node) {\n        let contentType = node.contentType;\n        let disposition = node.disposition;\n        let encoding = node.encoding;\n        let charset = node.charset;\n        if (!contentType && node.root) {\n            contentType = \"text/plain\";\n        }\n        let newNode = {\n            node,\n            headerLines: node.headers.lines,\n            headers: this.processHeaders(node.headers.getList()),\n            contentType,\n            children: []\n        };\n        if (!/^multipart\\//i.test(contentType)) {\n            if (disposition && ![\n                \"attachment\",\n                \"inline\"\n            ].includes(disposition)) {\n                disposition = \"attachment\";\n            }\n            if (!disposition && !this.textTypes.includes(contentType)) {\n                newNode.disposition = \"attachment\";\n            } else {\n                newNode.disposition = disposition || \"inline\";\n            }\n            newNode.isAttachment = !this.textTypes.includes(contentType) || newNode.disposition !== \"inline\";\n            newNode.encoding = [\n                \"quoted-printable\",\n                \"base64\"\n            ].includes(encoding) ? encoding : \"binary\";\n            if (charset) {\n                newNode.charset = charset;\n            }\n            let decoder = node.getDecoder();\n            decoder.on(\"end\", ()=>{\n                this.decoderEnded = true;\n            });\n            newNode.decoder = decoder;\n        }\n        if (node.root) {\n            this.headers = newNode.headers;\n            this.headerLines = newNode.headerLines;\n        }\n        // find location in tree\n        if (!this.tree) {\n            newNode.root = true;\n            this.curnode = this.tree = newNode;\n            return newNode;\n        }\n        // immediate child of root node\n        if (!this.curnode.parent) {\n            newNode.parent = this.curnode;\n            this.curnode.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n        // siblings\n        if (this.curnode.parent.node === node.parentNode) {\n            newNode.parent = this.curnode.parent;\n            this.curnode.parent.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n        // first child\n        if (this.curnode.node === node.parentNode) {\n            newNode.parent = this.curnode;\n            this.curnode.children.push(newNode);\n            this.curnode = newNode;\n            return newNode;\n        }\n        // move up\n        let parentNode = this.curnode;\n        while(parentNode = parentNode.parent){\n            if (parentNode.node === node.parentNode) {\n                newNode.parent = parentNode;\n                parentNode.children.push(newNode);\n                this.curnode = newNode;\n                return newNode;\n            }\n        }\n        // should never happen, can't detect parent\n        this.curnode = newNode;\n        return newNode;\n    }\n    getTextContent() {\n        let text = [];\n        let html = [];\n        let processNode = (alternative, level, node)=>{\n            if (node.showMeta) {\n                let meta = [\n                    \"From\",\n                    \"Subject\",\n                    \"Date\",\n                    \"To\",\n                    \"Cc\",\n                    \"Bcc\"\n                ].map((fkey)=>{\n                    let key = fkey.toLowerCase();\n                    if (!node.headers.has(key)) {\n                        return false;\n                    }\n                    let value = node.headers.get(key);\n                    if (!value) {\n                        return false;\n                    }\n                    return {\n                        key: fkey,\n                        value: Array.isArray(value) ? value[value.length - 1] : value\n                    };\n                }).filter((entry)=>entry);\n                if (this.hasHtml) {\n                    html.push('<table class=\"mp_head\">' + meta.map((entry)=>{\n                        let value = entry.value;\n                        switch(entry.key){\n                            case \"From\":\n                            case \"To\":\n                            case \"Cc\":\n                            case \"Bcc\":\n                                value = value.html;\n                                break;\n                            case \"Date\":\n                                value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                                break;\n                            case \"Subject\":\n                                value = \"<strong>\" + he.encode(value) + \"</strong>\";\n                                break;\n                            default:\n                                value = he.encode(value);\n                        }\n                        return '<tr><td class=\"mp_head_key\">' + he.encode(entry.key) + ':</td><td class=\"mp_head_value\">' + value + \"<td></tr>\";\n                    }).join(\"\\n\") + \"<table>\");\n                }\n                if (this.hasText) {\n                    text.push(\"\\n\" + meta.map((entry)=>{\n                        let value = entry.value;\n                        switch(entry.key){\n                            case \"From\":\n                            case \"To\":\n                            case \"Cc\":\n                            case \"Bcc\":\n                                value = value.text;\n                                break;\n                            case \"Date\":\n                                value = this.options.formatDateString ? this.options.formatDateString(value) : value.toUTCString();\n                                break;\n                        }\n                        return entry.key + \": \" + value;\n                    }).join(\"\\n\") + \"\\n\");\n                }\n            }\n            if (node.textContent) {\n                if (node.contentType === \"text/plain\") {\n                    text.push(node.textContent);\n                    if (!alternative && this.hasHtml) {\n                        html.push(this.textToHtml(node.textContent));\n                    }\n                } else if (node.contentType === \"message/delivery-status\" && !this.options.keepDeliveryStatus) {\n                    text.push(node.textContent);\n                    if (!alternative && this.hasHtml) {\n                        html.push(this.textToHtml(node.textContent));\n                    }\n                } else if (node.contentType === \"text/html\") {\n                    let failedToParseHtml = false;\n                    if (!alternative && this.hasText || node.root && !this.hasText) {\n                        if (this.options.skipHtmlToText) {\n                            text.push(\"\");\n                        } else if (node.textContent.length > this.options.maxHtmlLengthToParse) {\n                            this.emit(\"error\", new Error(`HTML too long for parsing ${node.textContent.length} bytes`));\n                            text.push(\"Invalid HTML content (too long)\");\n                            failedToParseHtml = true;\n                        } else {\n                            try {\n                                text.push(htmlToText(node.textContent));\n                            } catch (err) {\n                                this.emit(\"error\", new Error(\"Failed to parse HTML\"));\n                                text.push(\"Invalid HTML content\");\n                                failedToParseHtml = true;\n                            }\n                        }\n                    }\n                    if (!failedToParseHtml) {\n                        html.push(node.textContent);\n                    }\n                }\n            }\n            alternative = alternative || node.contentType === \"multipart/alternative\";\n            if (node.children) {\n                node.children.forEach((subNode)=>{\n                    processNode(alternative, level + 1, subNode);\n                });\n            }\n        };\n        processNode(false, 0, this.tree);\n        let response = {\n            type: \"text\"\n        };\n        if (html.length) {\n            this.html = response.html = html.join(\"<br/>\\n\");\n        }\n        if (text.length) {\n            this.text = response.text = text.join(\"\\n\");\n            this.textAsHtml = response.textAsHtml = text.map((part)=>this.textToHtml(part)).join(\"<br/>\\n\");\n        }\n        return response;\n    }\n    processChunk(data, done) {\n        let partId = null;\n        if (data._parentBoundary) {\n            partId = this._getPartId(data._parentBoundary);\n        }\n        switch(data.type){\n            case \"node\":\n                {\n                    let node = this.createNode(data);\n                    if (node === this.tree) {\n                        [\n                            \"subject\",\n                            \"references\",\n                            \"date\",\n                            \"to\",\n                            \"from\",\n                            \"to\",\n                            \"cc\",\n                            \"bcc\",\n                            \"message-id\",\n                            \"in-reply-to\",\n                            \"reply-to\"\n                        ].forEach((key)=>{\n                            if (node.headers.has(key)) {\n                                this[key.replace(/-([a-z])/g, (m, c)=>c.toUpperCase())] = node.headers.get(key);\n                            }\n                        });\n                        this.emit(\"headers\", node.headers);\n                        if (node.headerLines) {\n                            this.emit(\"headerLines\", node.headerLines);\n                        }\n                    }\n                    if (data.contentType === \"message/rfc822\" && data.messageNode) {\n                        break;\n                    }\n                    if (data.parentNode && data.parentNode.contentType === \"message/rfc822\") {\n                        node.showMeta = true;\n                    }\n                    if (node.isAttachment) {\n                        let contentType = node.contentType;\n                        if (node.contentType === \"application/octet-stream\" && data.filename) {\n                            contentType = this.libmime.detectMimeType(data.filename) || \"application/octet-stream\";\n                        }\n                        let attachment = {\n                            type: \"attachment\",\n                            content: null,\n                            contentType,\n                            partId,\n                            release: ()=>{\n                                attachment.release = null;\n                                if (this.waitUntilAttachmentEnd && typeof this.attachmentCallback === \"function\") {\n                                    setImmediate(this.attachmentCallback);\n                                }\n                                this.attachmentCallback = false;\n                                this.waitUntilAttachmentEnd = false;\n                            }\n                        };\n                        let algo = this.options.checksumAlgo || \"md5\";\n                        let hasher = new StreamHash(attachment, algo);\n                        node.decoder.on(\"error\", (err)=>{\n                            hasher.emit(\"error\", err);\n                        });\n                        node.decoder.on(\"readable\", ()=>{\n                            let chunk;\n                            while((chunk = node.decoder.read()) !== null){\n                                hasher.write(chunk);\n                            }\n                        });\n                        node.decoder.once(\"end\", ()=>{\n                            hasher.end();\n                        });\n                        //node.decoder.pipe(hasher);\n                        attachment.content = hasher;\n                        this.waitUntilAttachmentEnd = true;\n                        if (data.disposition) {\n                            attachment.contentDisposition = data.disposition;\n                        }\n                        if (data.filename) {\n                            attachment.filename = data.filename;\n                        }\n                        if (node.headers.has(\"content-id\")) {\n                            attachment.contentId = [].concat(node.headers.get(\"content-id\") || []).shift();\n                            attachment.cid = attachment.contentId.trim().replace(/^<|>$/g, \"\").trim();\n                            // check if the attachment is \"related\" to text content like an embedded image etc\n                            let parentNode = node;\n                            while(parentNode = parentNode.parent){\n                                if (parentNode.contentType === \"multipart/related\") {\n                                    attachment.related = true;\n                                }\n                            }\n                        }\n                        attachment.headers = node.headers;\n                        this.push(attachment);\n                        this.attachmentList.push(attachment);\n                    } else if (node.disposition === \"inline\") {\n                        let chunks = [];\n                        let chunklen = 0;\n                        node.contentStream = node.decoder;\n                        if (node.contentType === \"text/plain\") {\n                            this.hasText = true;\n                        } else if (node.contentType === \"text/html\") {\n                            this.hasHtml = true;\n                        } else if (node.contentType === \"message/delivery-status\" && !this.options.keepDeliveryStatus) {\n                            this.hasText = true;\n                        }\n                        if (node.node.flowed) {\n                            let contentStream = node.contentStream;\n                            let flowDecoder = new FlowedDecoder({\n                                delSp: node.node.delSp\n                            });\n                            contentStream.on(\"error\", (err)=>{\n                                flowDecoder.emit(\"error\", err);\n                            });\n                            contentStream.pipe(flowDecoder);\n                            node.contentStream = flowDecoder;\n                        }\n                        let charset = node.charset || \"utf-8\";\n                        //charset = charset || 'windows-1257';\n                        if (![\n                            \"ascii\",\n                            \"usascii\",\n                            \"utf8\"\n                        ].includes(charset.toLowerCase().replace(/[^a-z0-9]+/g, \"\"))) {\n                            try {\n                                let contentStream = node.contentStream;\n                                let decodeStream = this.decoder.decodeStream(charset);\n                                contentStream.on(\"error\", (err)=>{\n                                    decodeStream.emit(\"error\", err);\n                                });\n                                contentStream.pipe(decodeStream);\n                                node.contentStream = decodeStream;\n                            } catch (E) {\n                            // do not decode charset\n                            }\n                        }\n                        node.contentStream.on(\"readable\", ()=>{\n                            let chunk;\n                            while((chunk = node.contentStream.read()) !== null){\n                                if (typeof chunk === \"string\") {\n                                    chunk = Buffer.from(chunk);\n                                }\n                                chunks.push(chunk);\n                                chunklen += chunk.length;\n                            }\n                        });\n                        node.contentStream.once(\"end\", ()=>{\n                            node.textContent = Buffer.concat(chunks, chunklen).toString().replace(/\\r?\\n/g, \"\\n\");\n                        });\n                        node.contentStream.once(\"error\", (err)=>{\n                            this.emit(\"error\", err);\n                        });\n                    }\n                    break;\n                }\n            case \"data\":\n                if (this.curnode && this.curnode.decoder) {\n                    this.curnode.decoder.end();\n                }\n                if (this.waitUntilAttachmentEnd) {\n                    this.attachmentCallback = done;\n                    return;\n                }\n                break;\n            case \"body\":\n                if (this.curnode && this.curnode.decoder && this.curnode.decoder.writable) {\n                    if (this.curnode.decoder.write(data.value) === false) {\n                        return this.curnode.decoder.once(\"drain\", done);\n                    }\n                }\n                break;\n        }\n        setImmediate(done);\n    }\n    _getPartId(parentBoundary) {\n        let boundaryIndex = this.boundaries.findIndex((item)=>item.name === parentBoundary);\n        if (boundaryIndex === -1) {\n            this.boundaries.push({\n                name: parentBoundary,\n                count: 1\n            });\n            boundaryIndex = this.boundaries.length - 1;\n        } else {\n            this.boundaries[boundaryIndex].count++;\n        }\n        let partId = \"1\";\n        for(let i = 0; i <= boundaryIndex; i++){\n            if (i === 0) partId = this.boundaries[i].count.toString();\n            else partId += \".\" + this.boundaries[i].count.toString();\n        }\n        return partId;\n    }\n    getAddressesHTML(value) {\n        let formatSingleLevel = (addresses)=>addresses.map((address)=>{\n                let str = '<span class=\"mp_address_group\">';\n                if (address.name) {\n                    str += '<span class=\"mp_address_name\">' + he.encode(address.name) + (address.group ? \": \" : \"\") + \"</span>\";\n                }\n                if (address.address) {\n                    let link = '<a href=\"mailto:' + he.encode(address.address) + '\" class=\"mp_address_email\">' + he.encode(address.address) + \"</a>\";\n                    if (address.name) {\n                        str += \" &lt;\" + link + \"&gt;\";\n                    } else {\n                        str += link;\n                    }\n                }\n                if (address.group) {\n                    str += formatSingleLevel(address.group) + \";\";\n                }\n                return str + \"</span>\";\n            }).join(\", \");\n        return formatSingleLevel([].concat(value || []));\n    }\n    getAddressesText(value) {\n        let formatSingleLevel = (addresses)=>addresses.map((address)=>{\n                let str = \"\";\n                if (address.name) {\n                    str += `\"${address.name}\"` + (address.group ? \": \" : \"\");\n                }\n                if (address.address) {\n                    let link = address.address;\n                    if (address.name) {\n                        str += \" <\" + link + \">\";\n                    } else {\n                        str += link;\n                    }\n                }\n                if (address.group) {\n                    str += formatSingleLevel(address.group) + \";\";\n                }\n                return str;\n            }).join(\", \");\n        return formatSingleLevel([].concat(value || []));\n    }\n    updateImageLinks(replaceCallback, done) {\n        if (!this.html) {\n            return setImmediate(()=>done(null, false));\n        }\n        let cids = new Map();\n        let html = (this.html || \"\").toString();\n        if (this.options.skipImageLinks) {\n            return done(null, html);\n        }\n        html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid)=>{\n            for(let i = 0, len = this.attachmentList.length; i < len; i++){\n                if (this.attachmentList[i].cid === cid && /^image\\/[\\w]+$/i.test(this.attachmentList[i].contentType)) {\n                    cids.set(cid, {\n                        attachment: this.attachmentList[i]\n                    });\n                    break;\n                }\n            }\n            return match;\n        });\n        let cidList = [];\n        cids.forEach((entry)=>{\n            cidList.push(entry);\n        });\n        let pos = 0;\n        let processNext = ()=>{\n            if (pos >= cidList.length) {\n                html = html.replace(/\\bcid:([^'\"\\s]{1,256})/g, (match, cid)=>{\n                    if (cids.has(cid) && cids.get(cid).url) {\n                        return cids.get(cid).url;\n                    }\n                    return match;\n                });\n                return done(null, html);\n            }\n            let entry = cidList[pos++];\n            replaceCallback(entry.attachment, (err, url)=>{\n                if (err) {\n                    return setImmediate(()=>done(err));\n                }\n                entry.url = url;\n                setImmediate(processNext);\n            });\n        };\n        setImmediate(processNext);\n    }\n    textToHtml(str) {\n        if (this.options.skipTextToHtml) {\n            return \"\";\n        }\n        str = (str || \"\").toString();\n        let encoded;\n        let linkified = false;\n        if (!this.options.skipTextLinks) {\n            try {\n                if (linkify.pretest(str)) {\n                    linkified = true;\n                    let links = linkify.match(str) || [];\n                    let result = [];\n                    let last = 0;\n                    links.forEach((link)=>{\n                        if (last < link.index) {\n                            let textPart = he// encode special chars\n                            .encode(str.slice(last, link.index), {\n                                useNamedReferences: true\n                            });\n                            result.push(textPart);\n                        }\n                        result.push(`<a href=\"${link.url}\">${link.text}</a>`);\n                        last = link.lastIndex;\n                    });\n                    let textPart = he// encode special chars\n                    .encode(str.slice(last), {\n                        useNamedReferences: true\n                    });\n                    result.push(textPart);\n                    encoded = result.join(\"\");\n                }\n            } catch (E) {\n            // failed, don't linkify\n            }\n        }\n        if (!linkified) {\n            encoded = he// encode special chars\n            .encode(str, {\n                useNamedReferences: true\n            });\n        }\n        let text = \"<p>\" + encoded.replace(/\\r?\\n/g, \"\\n\").trim() // normalize line endings\n        .replace(/[ \\t]+$/gm, \"\").trim() // trim empty line endings\n        .replace(/\\n\\n+/g, \"</p><p>\").trim() // insert <p> to multiple linebreaks\n        .replace(/\\n/g, \"<br/>\") + // insert <br> to single linebreaks\n        \"</p>\";\n        return text;\n    }\n}\nmodule.exports = MailParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9saWIvbWFpbC1wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxZQUFZQyxtQkFBT0EsQ0FBQztBQUMxQixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1HLFlBQVlILHVEQUEyQjtBQUM3QyxNQUFNSSxXQUFXTCxVQUFVSyxRQUFRO0FBQ25DLE1BQU1DLHFCQUFxQk4sVUFBVU0sa0JBQWtCO0FBQ3ZELE1BQU1DLFdBQVdOLG1CQUFPQSxDQUFDO0FBQ3pCLE1BQU1PLGdCQUFnQlAsbUJBQU9BLENBQUM7QUFDOUIsTUFBTVEsYUFBYVIsbUJBQU9BLENBQUM7QUFDM0IsTUFBTVMsUUFBUVQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTSxFQUFFVSxVQUFVLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFDL0IsTUFBTVcsS0FBS1gsbUJBQU9BLENBQUM7QUFDbkIsTUFBTVksVUFBVVosbUJBQU9BLENBQUM7QUFDeEIsTUFBTWEsT0FBT2IsbUJBQU9BLENBQUM7QUFDckIsTUFBTWMsbUJBQW1CZCxtQkFBT0EsQ0FBQztBQUVqQ1ksUUFDS0MsSUFBSSxDQUFDQSxNQUFNLDZCQUE2QjtDQUN4Q0EsSUFBSSxDQUFDLFNBQVMsTUFBTSxpQ0FBaUM7Q0FDckRFLEdBQUcsQ0FBQyxRQUFRLFNBQVMsaUNBQWlDO0NBQ3REQSxHQUFHLENBQUMsUUFBUSxNQUFNLDBCQUEwQjtDQUM1Q0MsR0FBRyxDQUFDO0lBQUVDLFNBQVM7SUFBTUMsV0FBVztJQUFNQyxZQUFZO0FBQUs7QUFFNUQseUJBQXlCO0FBQ3pCLG1GQUFtRjtBQUNuRlAsUUFBUUcsR0FBRyxDQUFDLEtBQUs7SUFDYkssVUFBU0MsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLElBQUk7UUFDcEIsSUFBSUMsT0FBT0gsS0FBS0ksS0FBSyxDQUFDSDtRQUV0QixJQUFJLENBQUNDLEtBQUtH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ZGVfbW9kdWxlcy9tYWlscGFyc2VyL2xpYi9tYWlsLXBhcnNlci5qcz8xNDBhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWFpbHNwbGl0ID0gcmVxdWlyZSgnQHpvbmUtZXUvbWFpbHNwbGl0Jyk7XG5jb25zdCBsaWJtaW1lID0gcmVxdWlyZSgnbGlibWltZScpO1xuY29uc3QgYWRkcmVzc3BhcnNlciA9IHJlcXVpcmUoJ25vZGVtYWlsZXIvbGliL2FkZHJlc3NwYXJzZXInKTtcbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbmNvbnN0IFNwbGl0dGVyID0gbWFpbHNwbGl0LlNwbGl0dGVyO1xuY29uc3QgQ2h1bmtlZFBhc3N0aHJvdWdoID0gbWFpbHNwbGl0LkNodW5rZWRQYXNzdGhyb3VnaDtcbmNvbnN0IHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUuanMnKTtcbmNvbnN0IEZsb3dlZERlY29kZXIgPSByZXF1aXJlKCdAem9uZS1ldS9tYWlsc3BsaXQvbGliL2Zsb3dlZC1kZWNvZGVyJyk7XG5jb25zdCBTdHJlYW1IYXNoID0gcmVxdWlyZSgnLi9zdHJlYW0taGFzaCcpO1xuY29uc3QgaWNvbnYgPSByZXF1aXJlKCdpY29udi1saXRlJyk7XG5jb25zdCB7IGh0bWxUb1RleHQgfSA9IHJlcXVpcmUoJ2h0bWwtdG8tdGV4dCcpO1xuY29uc3QgaGUgPSByZXF1aXJlKCdoZScpO1xuY29uc3QgbGlua2lmeSA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKSgpO1xuY29uc3QgdGxkcyA9IHJlcXVpcmUoJ3RsZHMnKTtcbmNvbnN0IGVuY29kaW5nSmFwYW5lc2UgPSByZXF1aXJlKCdlbmNvZGluZy1qYXBhbmVzZScpO1xuXG5saW5raWZ5XG4gICAgLnRsZHModGxkcykgLy8gUmVsb2FkIHdpdGggZnVsbCB0bGRzIGxpc3RcbiAgICAudGxkcygnb25pb24nLCB0cnVlKSAvLyBBZGQgdW5vZmZpY2lhbCBgLm9uaW9uYCBkb21haW5cbiAgICAuYWRkKCdnaXQ6JywgJ2h0dHA6JykgLy8gQWRkIGBnaXQ6YCBwdG90b2NvbCBhcyBcImFsaWFzXCJcbiAgICAuYWRkKCdmdHA6JywgbnVsbCkgLy8gRGlzYWJsZSBgZnRwOmAgcHRvdG9jb2xcbiAgICAuc2V0KHsgZnV6enlJUDogdHJ1ZSwgZnV6enlMaW5rOiB0cnVlLCBmdXp6eUVtYWlsOiB0cnVlIH0pO1xuXG4vLyB0d2l0dGVyIGxpbmtpZmllciBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdCNleGFtcGxlLTItYWRkLXR3aXR0ZXItbWVudGlvbnMtaGFuZGxlclxubGlua2lmeS5hZGQoJ0AnLCB7XG4gICAgdmFsaWRhdGUodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICAgIGxldCB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICAgIGlmICghc2VsZi5yZS50d2l0dGVyKSB7XG4gICAgICAgICAgICBzZWxmLnJlLnR3aXR0ZXIgPSBuZXcgUmVnRXhwKCdeKFthLXpBLVowLTlfXSl7MSwxNX0oPyFfKSg/PSR8JyArIHNlbGYucmUuc3JjX1pQQ2MgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnJlLnR3aXR0ZXIudGVzdCh0YWlsKSkge1xuICAgICAgICAgICAgLy8gTGlua2lmaWVyIGFsbG93cyBwdW5jdHVhdGlvbiBjaGFycyBiZWZvcmUgcHJlZml4LFxuICAgICAgICAgICAgLy8gYnV0IHdlIGFkZGl0aW9uYWxseSBkaXNhYmxlIGBAYCAoXCJAQG1lbnRpb25cIiBpcyBpbnZhbGlkKVxuICAgICAgICAgICAgaWYgKHBvcyA+PSAyICYmIHRhaWxbcG9zIC0gMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUudHdpdHRlcilbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgbm9ybWFsaXplKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLnVybCA9ICdodHRwczovL3R3aXR0ZXIuY29tLycgKyBtYXRjaC51cmwucmVwbGFjZSgvXkAvLCAnJyk7XG4gICAgfVxufSk7XG5cbmNsYXNzIEljb252RGVjb2RlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoSWNvbnYsIGNoYXJzZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICAvLyBJY29udiB0aHJvd3MgZXJyb3Igb24ga3NfY181NjAxLTE5ODcgd2hlbiBpdCBpcyBtYXBwZWQgdG8gRVVDLUtSXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ibm9vcmRodWlzL25vZGUtaWNvbnYvaXNzdWVzLzE2OVxuICAgICAgICBpZiAoY2hhcnNldC50b0xvd2VyQ2FzZSgpID09PSAna3NfY181NjAxLTE5ODcnKSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gJ0NQOTQ5JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmVhbSA9IG5ldyBJY29udihjaGFyc2V0LCAnVVRGLTgvL1RSQU5TTElULy9JR05PUkUnKTtcblxuICAgICAgICB0aGlzLmlucHV0RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRDYiA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgY2h1bmsgPT4gdGhpcy5wdXNoKGNodW5rKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmVuZENiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICB0aGlzLnN0cmVhbS53cml0ZShjaHVuayk7XG4gICAgICAgIGRvbmUoKTtcbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICB0aGlzLmVuZENiID0gZG9uZTtcbiAgICAgICAgdGhpcy5zdHJlYW0uZW5kKCk7XG4gICAgfVxufVxuXG5jbGFzcyBKUERlY29kZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJzZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rbGVuID0gMDtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBkb25lKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGRvbmUpIHtcbiAgICAgICAgbGV0IGlucHV0ID0gQnVmZmVyLmNvbmNhdCh0aGlzLmNodW5rcywgdGhpcy5jaHVua2xlbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0ID0gZW5jb2RpbmdKYXBhbmVzZS5jb252ZXJ0KGlucHV0LCB7XG4gICAgICAgICAgICAgICAgdG86ICdVTklDT0RFJywgLy8gdG9fZW5jb2RpbmdcbiAgICAgICAgICAgICAgICBmcm9tOiB0aGlzLmNoYXJzZXQsIC8vIGZyb21fZW5jb2RpbmdcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG91dHB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBCdWZmZXIuZnJvbShvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8ga2VlcCBhcyBpcyBvbiBlcnJvcnNcbiAgICAgICAgICAgIHRoaXMucHVzaChpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBkb25lKCk7XG4gICAgfVxufVxuXG5jbGFzcyBNYWlsUGFyc2VyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcgfHwge307XG4gICAgICAgIHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoID0gbmV3IENodW5rZWRQYXNzdGhyb3VnaCgpO1xuICAgICAgICB0aGlzLnNwbGl0dGVyID0gbmV3IFNwbGl0dGVyKGNvbmZpZyk7XG5cbiAgICAgICAgdGhpcy5jaHVua2VkUGFzc3Rocm91Z2gucGlwZSh0aGlzLnNwbGl0dGVyKTtcblxuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FpdGluZ0VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlYWRlckxpbmVzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5lbmRSZWNlaXZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnRyZWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJub2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FpdFVudGlsQXR0YWNobWVudEVuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnRDYWxsYmFjayA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaGFzSHRtbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1RleHQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnRleHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5odG1sID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dEFzSHRtbCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYXR0YWNobWVudExpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLmJvdW5kYXJpZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnRleHRUeXBlcyA9IFsndGV4dC9wbGFpbicsICd0ZXh0L2h0bWwnXS5jb25jYXQoIXRoaXMub3B0aW9ucy5rZWVwRGVsaXZlcnlTdGF0dXMgPyAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnIDogW10pO1xuXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IHRoaXMuZ2V0RGVjb2RlcigpO1xuXG4gICAgICAgIHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zcGxpdHRlci5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkRGF0YSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnNwbGl0dGVyLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZFJlY2VpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmRTdHJlYW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zcGxpdHRlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndhaXRpbmdFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWl0aW5nRW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5saWJtaW1lID0gbmV3IGxpYm1pbWUuTGlibWltZSh7IEljb252OiB0aGlzLm9wdGlvbnMuSWNvbnYgfSk7XG4gICAgfVxuXG4gICAgZ2V0RGVjb2RlcigpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5JY29udikge1xuICAgICAgICAgICAgY29uc3QgSWNvbnYgPSB0aGlzLm9wdGlvbnMuSWNvbnY7XG4gICAgICAgICAgICAvLyBjcmVhdGUgd3JhcHBlclxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVTdHJlYW0oY2hhcnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEljb252RGVjb2RlcihJY29udiwgY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVjb2RlU3RyZWFtKGNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9IChjaGFyc2V0IHx8ICdhc2NpaScpLnRvU3RyaW5nKCkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvXmppc3xeaXNvLT8yMDIyLT9qcHxeRVVDSlAvaS50ZXN0KGNoYXJzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ugbm90IHN1cHBvcnRlZCBieSBpY29udi1saXRlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpQRGVjb2RlcihjaGFyc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpY29udi5kZWNvZGVTdHJlYW0oY2hhcnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlYWREYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGYWlsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRpbmcgPSB0cnVlO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuc3BsaXR0ZXIucmVhZCgpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmRSZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kU3RyZWFtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb2Nlc3NDaHVuayhkYXRhLCBlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy53YWl0aW5nRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRpbmdFbmQoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMucmVhZERhdGEoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuZFN0cmVhbSgpIHtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY3Vybm9kZSAmJiB0aGlzLmN1cm5vZGUuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLmRlY29kZXIuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndhaXRpbmdFbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0VuZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICAgICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtlZFBhc3N0aHJvdWdoLndyaXRlKGNodW5rKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNodW5rZWRQYXNzdGhyb3VnaC5vbmNlKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmx1c2goZG9uZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5jaHVua2VkUGFzc3Rocm91Z2guZW5kKCkpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xlYW51cChkb25lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRpbmdFbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsZWFudXAoZG9uZSkge1xuICAgICAgICBsZXQgZmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgdCA9IHRoaXMuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2godCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5jdXJub2RlICYmIHRoaXMuY3Vybm9kZS5kZWNvZGVyICYmIHRoaXMuY3Vybm9kZS5kZWNvZGVyLnJlYWRhYmxlICYmICF0aGlzLmRlY29kZXJFbmRlZCkge1xuICAgICAgICAgICAgKHRoaXMuY3Vybm9kZS5jb250ZW50U3RyZWFtIHx8IHRoaXMuY3Vybm9kZS5kZWNvZGVyKS5vbmNlKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY3Vybm9kZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvY2Vzc0hlYWRlcnMobGluZXMpIHtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIChsaW5lcyB8fCBbXSkuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgIGxldCBrZXkgPSBsaW5lLmtleTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICgodGhpcy5saWJtaW1lLmRlY29kZUhlYWRlcihsaW5lLmxpbmUpIHx8IHt9KS52YWx1ZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmluYXJ5JykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29udGVudC10eXBlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb250ZW50LWRpc3Bvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdka2ltLXNpZ25hdHVyZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLnBhcnNlSGVhZGVyVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cygodmFsdWUgJiYgdmFsdWUucGFyYW1zKSB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wYXJhbXNba2V5XSA9IHRoaXMubGlibWltZS5kZWNvZGVXb3Jkcyh2YWx1ZS5wYXJhbXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlLCBrZWVwIGFzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlJzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ZVZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZGF0ZVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0ZSBwYXJzaW5nIGZhaWxlZCA6U1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZVZhbHVlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1YmplY3QnOlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmxpYm1pbWUuZGVjb2RlV29yZHModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUsIGtlZXAgYXMgaXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZWZlcmVuY2VzJzpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pLm1hcCh0aGlzLmVuc3VyZU1lc3NhZ2VJREZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2UtaWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2luLXJlcGx5LXRvJzpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmVuc3VyZU1lc3NhZ2VJREZvcm1hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ByaW9yaXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICd4LXByaW9yaXR5JzpcbiAgICAgICAgICAgICAgICBjYXNlICd4LW1zbWFpbC1wcmlvcml0eSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wb3J0YW5jZSc6XG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICdwcmlvcml0eSc7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZVByaW9yaXR5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnJvbSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndG8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NjJzpcbiAgICAgICAgICAgICAgICBjYXNlICdiY2MnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlbmRlcic6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbHktdG8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbGl2ZXJlZC10byc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmV0dXJuLXBhdGgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvbi10byc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWRkcmVzc3BhcnNlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQWRkcmVzc2VzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWw6IHRoaXMuZ2V0QWRkcmVzc2VzSFRNTCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmdldEFkZHJlc3Nlc1RleHQodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGUgbGlzdC0qIGtleXNcbiAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyKDAsIDUpID09PSAnbGlzdC0nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlTGlzdEhlYWRlcihrZXkuc3Vic3RyKDUpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAga2V5ID0gJ2xpc3QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoa2V5LCBbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgaGVhZGVycy5nZXQoa2V5KS5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLmdldChrZXkpLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8ga2VlcCBvbmx5IHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICBsZXQgc2luZ2xlS2V5cyA9IFtcbiAgICAgICAgICAgICdtZXNzYWdlLWlkJyxcbiAgICAgICAgICAgICdjb250ZW50LWlkJyxcbiAgICAgICAgICAgICdmcm9tJyxcbiAgICAgICAgICAgICdzZW5kZXInLFxuICAgICAgICAgICAgJ2luLXJlcGx5LXRvJyxcbiAgICAgICAgICAgICdyZXBseS10bycsXG4gICAgICAgICAgICAnc3ViamVjdCcsXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnY29udGVudC1kaXNwb3NpdGlvbicsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJyxcbiAgICAgICAgICAgICdjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJyxcbiAgICAgICAgICAgICdwcmlvcml0eScsXG4gICAgICAgICAgICAnbWltZS12ZXJzaW9uJyxcbiAgICAgICAgICAgICdjb250ZW50LWRlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdwcmVjZWRlbmNlJyxcbiAgICAgICAgICAgICdlcnJvcnMtdG8nLFxuICAgICAgICAgICAgJ2Rpc3Bvc2l0aW9uLW5vdGlmaWNhdGlvbi10bydcbiAgICAgICAgXTtcblxuICAgICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVLZXlzLmluY2x1ZGVzKGtleSkgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWVbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xpc3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIExpc3QtKiBoZWFkZXJzXG4gICAgICAgICAgICAgICAgbGV0IGxpc3RWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIFtdLmNvbmNhdCh2YWx1ZSB8fCBbXSkuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWwgfHwge30pLmZvckVhY2gobGlzdEtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0VmFsdWVbbGlzdEtleV0gPSB2YWxbbGlzdEtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgbGlzdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgcGFyc2VMaXN0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IGFkZHJlc3NwYXJzZXIodmFsdWUpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgbGV0IGRhdGEgPSBhZGRyZXNzZXNcbiAgICAgICAgICAgIC5tYXAoYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKC9eaHR0cHM/Oi9pLnRlc3QoYWRkcmVzcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS51cmwgPSBhZGRyZXNzLm5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubmFtZSA9IGFkZHJlc3MubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9ebWFpbHRvOi8udGVzdChhZGRyZXNzLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1haWwgPSBhZGRyZXNzLmFkZHJlc3Muc3Vic3RyKDcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5hZGRyZXNzICYmIGFkZHJlc3MuYWRkcmVzcy5pbmRleE9mKCdAJykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmlkID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1haWwgPSBhZGRyZXNzLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXNwb25zZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoYWRkcmVzcyA9PiBhZGRyZXNzKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtrZXldOiByZXNwb25zZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFyc2VQcmlvcml0eSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KHZhbHVlLCAxMCkpKSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IFwiWC1Qcmlvcml0eTogMSAoSGlnaGVzdClcIlxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbG93JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdoaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdub24tdXJnZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdsb3cnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2xvdyc7XG4gICAgICAgICAgICAgICAgY2FzZSAndXJnZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdoaWdoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdoaWdoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25vcm1hbCc7XG4gICAgfVxuXG4gICAgZW5zdXJlTWVzc2FnZUlERm9ybWF0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApICE9PSAnPCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJzwnICsgdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpICE9PSAnPicpIHtcbiAgICAgICAgICAgIHZhbHVlICs9ICc+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBkZWNvZGVBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBwcm9jZXNzZWRBZGRyZXNzID0gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gYWRkcmVzc2VzW2ldO1xuICAgICAgICAgICAgYWRkcmVzcy5uYW1lID0gKGFkZHJlc3MubmFtZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG5cbiAgICAgICAgICAgIGlmICghYWRkcmVzcy5hZGRyZXNzICYmIC9eKD1cXD8oW14/XSspXFw/W0JiXVxcP1teP10qXFw/PSkoXFxzKj1cXD8oW14/XSspXFw/W0JiXVxcP1teP10qXFw/PSkqJC8udGVzdChhZGRyZXNzLm5hbWUpICYmICFwcm9jZXNzZWRBZGRyZXNzLmhhcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWQgPSBhZGRyZXNzcGFyc2VyKHRoaXMubGlibWltZS5kZWNvZGVXb3JkcyhhZGRyZXNzLm5hbWUpKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRBZGRyZXNzLmFkZChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MubmFtZSA9IHRoaXMubGlibWltZS5kZWNvZGVXb3JkcyhhZGRyZXNzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZ25vcmUsIGtlZXAgYXMgaXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL0B4bi0tLy50ZXN0KGFkZHJlc3MuYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmFkZHJlc3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5hZGRyZXNzLnN1YnN0cigwLCBhZGRyZXNzLmFkZHJlc3MubGFzdEluZGV4T2YoJ0AnKSArIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1bnljb2RlLnRvVW5pY29kZShhZGRyZXNzLmFkZHJlc3Muc3Vic3RyKGFkZHJlc3MuYWRkcmVzcy5sYXN0SW5kZXhPZignQCcpICsgMSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGEgdmFsaWQgcHVueWNvZGUgc3RyaW5nOyBrZWVwIGFzIGlzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUFkZHJlc3NlcyhhZGRyZXNzLmdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZU5vZGUobm9kZSkge1xuICAgICAgICBsZXQgY29udGVudFR5cGUgPSBub2RlLmNvbnRlbnRUeXBlO1xuICAgICAgICBsZXQgZGlzcG9zaXRpb24gPSBub2RlLmRpc3Bvc2l0aW9uO1xuICAgICAgICBsZXQgZW5jb2RpbmcgPSBub2RlLmVuY29kaW5nO1xuICAgICAgICBsZXQgY2hhcnNldCA9IG5vZGUuY2hhcnNldDtcblxuICAgICAgICBpZiAoIWNvbnRlbnRUeXBlICYmIG5vZGUucm9vdCkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSAndGV4dC9wbGFpbic7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBoZWFkZXJMaW5lczogbm9kZS5oZWFkZXJzLmxpbmVzLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5wcm9jZXNzSGVhZGVycyhub2RlLmhlYWRlcnMuZ2V0TGlzdCgpKSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCEvXm11bHRpcGFydFxcLy9pLnRlc3QoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcG9zaXRpb24gJiYgIVsnYXR0YWNobWVudCcsICdpbmxpbmUnXS5pbmNsdWRlcyhkaXNwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NpdGlvbiA9ICdhdHRhY2htZW50JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkaXNwb3NpdGlvbiAmJiAhdGhpcy50ZXh0VHlwZXMuaW5jbHVkZXMoY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5kaXNwb3NpdGlvbiA9ICdhdHRhY2htZW50JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5kaXNwb3NpdGlvbiA9IGRpc3Bvc2l0aW9uIHx8ICdpbmxpbmUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdOb2RlLmlzQXR0YWNobWVudCA9ICF0aGlzLnRleHRUeXBlcy5pbmNsdWRlcyhjb250ZW50VHlwZSkgfHwgbmV3Tm9kZS5kaXNwb3NpdGlvbiAhPT0gJ2lubGluZSc7XG5cbiAgICAgICAgICAgIG5ld05vZGUuZW5jb2RpbmcgPSBbJ3F1b3RlZC1wcmludGFibGUnLCAnYmFzZTY0J10uaW5jbHVkZXMoZW5jb2RpbmcpID8gZW5jb2RpbmcgOiAnYmluYXJ5JztcblxuICAgICAgICAgICAgaWYgKGNoYXJzZXQpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLmNoYXJzZXQgPSBjaGFyc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGVjb2RlciA9IG5vZGUuZ2V0RGVjb2RlcigpO1xuICAgICAgICAgICAgZGVjb2Rlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlckVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3Tm9kZS5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IG5ld05vZGUuaGVhZGVycztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyTGluZXMgPSBuZXdOb2RlLmhlYWRlckxpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBsb2NhdGlvbiBpbiB0cmVlXG5cbiAgICAgICAgaWYgKCF0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgIG5ld05vZGUucm9vdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUgPSB0aGlzLnRyZWUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbW1lZGlhdGUgY2hpbGQgb2Ygcm9vdCBub2RlXG4gICAgICAgIGlmICghdGhpcy5jdXJub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzLmN1cm5vZGU7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUuY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgICAgIHRoaXMuY3Vybm9kZSA9IG5ld05vZGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpYmxpbmdzXG4gICAgICAgIGlmICh0aGlzLmN1cm5vZGUucGFyZW50Lm5vZGUgPT09IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSB0aGlzLmN1cm5vZGUucGFyZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLnBhcmVudC5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgY2hpbGRcbiAgICAgICAgaWYgKHRoaXMuY3Vybm9kZS5ub2RlID09PSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gdGhpcy5jdXJub2RlO1xuICAgICAgICAgICAgdGhpcy5jdXJub2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICB0aGlzLmN1cm5vZGUgPSBuZXdOb2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHVwXG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5jdXJub2RlO1xuICAgICAgICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGUgPT09IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4sIGNhbid0IGRldGVjdCBwYXJlbnRcbiAgICAgICAgdGhpcy5jdXJub2RlID0gbmV3Tm9kZTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxuXG4gICAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gW107XG4gICAgICAgIGxldCBodG1sID0gW107XG4gICAgICAgIGxldCBwcm9jZXNzTm9kZSA9IChhbHRlcm5hdGl2ZSwgbGV2ZWwsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnNob3dNZXRhKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ldGEgPSBbJ0Zyb20nLCAnU3ViamVjdCcsICdEYXRlJywgJ1RvJywgJ0NjJywgJ0JjYyddXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZmtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQga2V5ID0gZmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmhlYWRlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBub2RlLmhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGZrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gOiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihlbnRyeSA9PiBlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzSHRtbCkge1xuICAgICAgICAgICAgICAgICAgICBodG1sLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwibXBfaGVhZFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZW50cnkua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRnJvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmh0bWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5mb3JtYXREYXRlU3RyaW5nID8gdGhpcy5vcHRpb25zLmZvcm1hdERhdGVTdHJpbmcodmFsdWUpIDogdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnU3ViamVjdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzxzdHJvbmc+JyArIGhlLmVuY29kZSh2YWx1ZSkgKyAnPC9zdHJvbmc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBoZS5lbmNvZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzx0cj48dGQgY2xhc3M9XCJtcF9oZWFkX2tleVwiPicgKyBoZS5lbmNvZGUoZW50cnkua2V5KSArICc6PC90ZD48dGQgY2xhc3M9XCJtcF9oZWFkX3ZhbHVlXCI+JyArIHZhbHVlICsgJzx0ZD48L3RyPic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzx0YWJsZT4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1RleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZW50cnkua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnRnJvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnVG8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0NjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5mb3JtYXREYXRlU3RyaW5nID8gdGhpcy5vcHRpb25zLmZvcm1hdERhdGVTdHJpbmcodmFsdWUpIDogdmFsdWUudG9VVENTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkua2V5ICsgJzogJyArIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jb250ZW50VHlwZSA9PT0gJ3RleHQvcGxhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGl2ZSAmJiB0aGlzLmhhc0h0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0aGlzLnRleHRUb0h0bWwobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnICYmICF0aGlzLm9wdGlvbnMua2VlcERlbGl2ZXJ5U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbHRlcm5hdGl2ZSAmJiB0aGlzLmhhc0h0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaCh0aGlzLnRleHRUb0h0bWwobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAndGV4dC9odG1sJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmFpbGVkVG9QYXJzZUh0bWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghYWx0ZXJuYXRpdmUgJiYgdGhpcy5oYXNUZXh0KSB8fCAobm9kZS5yb290ICYmICF0aGlzLmhhc1RleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBIdG1sVG9UZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50ZXh0Q29udGVudC5sZW5ndGggPiB0aGlzLm9wdGlvbnMubWF4SHRtbExlbmd0aFRvUGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKGBIVE1MIHRvbyBsb25nIGZvciBwYXJzaW5nICR7bm9kZS50ZXh0Q29udGVudC5sZW5ndGh9IGJ5dGVzYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQucHVzaCgnSW52YWxpZCBIVE1MIGNvbnRlbnQgKHRvbyBsb25nKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZFRvUGFyc2VIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKGh0bWxUb1RleHQobm9kZS50ZXh0Q29udGVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgSFRNTCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5wdXNoKCdJbnZhbGlkIEhUTUwgY29udGVudCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRUb1BhcnNlSHRtbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmFpbGVkVG9QYXJzZUh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwucHVzaChub2RlLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsdGVybmF0aXZlID0gYWx0ZXJuYXRpdmUgfHwgbm9kZS5jb250ZW50VHlwZSA9PT0gJ211bHRpcGFydC9hbHRlcm5hdGl2ZSc7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChzdWJOb2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc05vZGUoYWx0ZXJuYXRpdmUsIGxldmVsICsgMSwgc3ViTm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvY2Vzc05vZGUoZmFsc2UsIDAsIHRoaXMudHJlZSk7XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnXG4gICAgICAgIH07XG4gICAgICAgIGlmIChodG1sLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5odG1sID0gcmVzcG9uc2UuaHRtbCA9IGh0bWwuam9pbignPGJyLz5cXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dCA9IHJlc3BvbnNlLnRleHQgPSB0ZXh0LmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgdGhpcy50ZXh0QXNIdG1sID0gcmVzcG9uc2UudGV4dEFzSHRtbCA9IHRleHQubWFwKHBhcnQgPT4gdGhpcy50ZXh0VG9IdG1sKHBhcnQpKS5qb2luKCc8YnIvPlxcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzQ2h1bmsoZGF0YSwgZG9uZSkge1xuICAgICAgICBsZXQgcGFydElkID0gbnVsbDtcbiAgICAgICAgaWYgKGRhdGEuX3BhcmVudEJvdW5kYXJ5KSB7XG4gICAgICAgICAgICBwYXJ0SWQgPSB0aGlzLl9nZXRQYXJ0SWQoZGF0YS5fcGFyZW50Qm91bmRhcnkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdub2RlJzoge1xuICAgICAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5jcmVhdGVOb2RlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLnRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgWydzdWJqZWN0JywgJ3JlZmVyZW5jZXMnLCAnZGF0ZScsICd0bycsICdmcm9tJywgJ3RvJywgJ2NjJywgJ2JjYycsICdtZXNzYWdlLWlkJywgJ2luLXJlcGx5LXRvJywgJ3JlcGx5LXRvJ10uZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVycy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5LnJlcGxhY2UoLy0oW2Etel0pL2csIChtLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpXSA9IG5vZGUuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhZGVycycsIG5vZGUuaGVhZGVycyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVyTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGVhZGVyTGluZXMnLCBub2RlLmhlYWRlckxpbmVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9yZmM4MjInICYmIGRhdGEubWVzc2FnZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucGFyZW50Tm9kZSAmJiBkYXRhLnBhcmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtZXNzYWdlL3JmYzgyMicpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zaG93TWV0YSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNBdHRhY2htZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZSA9IG5vZGUuY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyAmJiBkYXRhLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IHRoaXMubGlibWltZS5kZXRlY3RNaW1lVHlwZShkYXRhLmZpbGVuYW1lKSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRhY2htZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2F0dGFjaG1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFydElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQucmVsZWFzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMud2FpdFVudGlsQXR0YWNobWVudEVuZCAmJiB0eXBlb2YgdGhpcy5hdHRhY2htZW50Q2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHRoaXMuYXR0YWNobWVudENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50Q2FsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRVbnRpbEF0dGFjaG1lbnRFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgYWxnbyA9IHRoaXMub3B0aW9ucy5jaGVja3N1bUFsZ28gfHwgJ21kNSc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYXNoZXIgPSBuZXcgU3RyZWFtSGFzaChhdHRhY2htZW50LCBhbGdvKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWNvZGVyLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY29kZXIub24oJ3JlYWRhYmxlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGNodW5rID0gbm9kZS5kZWNvZGVyLnJlYWQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmRlY29kZXIub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaGVyLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvL25vZGUuZGVjb2Rlci5waXBlKGhhc2hlcik7XG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuY29udGVudCA9IGhhc2hlcjtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhaXRVbnRpbEF0dGFjaG1lbnRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5kaXNwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb250ZW50RGlzcG9zaXRpb24gPSBkYXRhLmRpc3Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZmlsZW5hbWUgPSBkYXRhLmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaGVhZGVycy5oYXMoJ2NvbnRlbnQtaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jb250ZW50SWQgPSBbXS5jb25jYXQobm9kZS5oZWFkZXJzLmdldCgnY29udGVudC1pZCcpIHx8IFtdKS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5jaWQgPSBhdHRhY2htZW50LmNvbnRlbnRJZC50cmltKCkucmVwbGFjZSgvXjx8PiQvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBhdHRhY2htZW50IGlzIFwicmVsYXRlZFwiIHRvIHRleHQgY29udGVudCBsaWtlIGFuIGVtYmVkZGVkIGltYWdlIGV0Y1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtdWx0aXBhcnQvcmVsYXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudC5yZWxhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhdHRhY2htZW50LmhlYWRlcnMgPSBub2RlLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChhdHRhY2htZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2htZW50TGlzdC5wdXNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5kaXNwb3NpdGlvbiA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2h1bmtsZW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRTdHJlYW0gPSBub2RlLmRlY29kZXI7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudFR5cGUgPT09ICd0ZXh0L3BsYWluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNUZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAndGV4dC9odG1sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNIdG1sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNvbnRlbnRUeXBlID09PSAnbWVzc2FnZS9kZWxpdmVyeS1zdGF0dXMnICYmICF0aGlzLm9wdGlvbnMua2VlcERlbGl2ZXJ5U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZS5mbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50U3RyZWFtID0gbm9kZS5jb250ZW50U3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsb3dEZWNvZGVyID0gbmV3IEZsb3dlZERlY29kZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbFNwOiBub2RlLm5vZGUuZGVsU3BcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb3dEZWNvZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5waXBlKGZsb3dEZWNvZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udGVudFN0cmVhbSA9IGZsb3dEZWNvZGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYXJzZXQgPSBub2RlLmNoYXJzZXQgfHwgJ3V0Zi04JztcbiAgICAgICAgICAgICAgICAgICAgLy9jaGFyc2V0ID0gY2hhcnNldCB8fCAnd2luZG93cy0xMjU3JztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIVsnYXNjaWknLCAndXNhc2NpaScsICd1dGY4J10uaW5jbHVkZXMoY2hhcnNldC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1teYS16MC05XSsvZywgJycpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFN0cmVhbSA9IG5vZGUuY29udGVudFN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVjb2RlU3RyZWFtID0gdGhpcy5kZWNvZGVyLmRlY29kZVN0cmVhbShjaGFyc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZVN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0cmVhbS5waXBlKGRlY29kZVN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtID0gZGVjb2RlU3RyZWFtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBkZWNvZGUgY2hhcnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBub2RlLmNvbnRlbnRTdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnRTdHJlYW0ub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbikudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHI/XFxuL2csICdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jb250ZW50U3RyZWFtLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vybm9kZSAmJiB0aGlzLmN1cm5vZGUuZGVjb2Rlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cm5vZGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy53YWl0VW50aWxBdHRhY2htZW50RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNobWVudENhbGxiYWNrID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGFydCBtZXNzYWdlIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHJlbGF0ZWQgdG8gYW55IHNwZWNpZmljICdub2RlJyBibG9jayBhcyBpdCBpbmNsdWRlc1xuICAgICAgICAgICAgICAgIC8vIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUgZW5kIG9mIHNvbWUgbm9kZSBib2R5IGFuZCBiZXR3ZWVuIHRoZSBuZXh0IGhlYWRlclxuICAgICAgICAgICAgICAgIC8vcHJvY2Vzcy5zdGRvdXQud3JpdGUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cm5vZGUgJiYgdGhpcy5jdXJub2RlLmRlY29kZXIgJiYgdGhpcy5jdXJub2RlLmRlY29kZXIud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3Vybm9kZS5kZWNvZGVyLndyaXRlKGRhdGEudmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Vybm9kZS5kZWNvZGVyLm9uY2UoJ2RyYWluJywgZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMZWFmIGVsZW1lbnQgYm9keS4gSW5jbHVkZXMgdGhlIGJvZHkgZm9yIHRoZSBsYXN0ICdub2RlJyBibG9jay4gWW91IG1pZ2h0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBzZXZlcmFsICdib2R5JyBjYWxscyBmb3IgYSBzaW5nbGUgJ25vZGUnIGJsb2NrXG4gICAgICAgICAgICAgICAgLy9wcm9jZXNzLnN0ZG91dC53cml0ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZShkb25lKTtcbiAgICB9XG5cbiAgICBfZ2V0UGFydElkKHBhcmVudEJvdW5kYXJ5KSB7XG4gICAgICAgIGxldCBib3VuZGFyeUluZGV4ID0gdGhpcy5ib3VuZGFyaWVzLmZpbmRJbmRleChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gcGFyZW50Qm91bmRhcnkpO1xuICAgICAgICBpZiAoYm91bmRhcnlJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRhcmllcy5wdXNoKHsgbmFtZTogcGFyZW50Qm91bmRhcnksIGNvdW50OiAxIH0pO1xuICAgICAgICAgICAgYm91bmRhcnlJbmRleCA9IHRoaXMuYm91bmRhcmllcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ib3VuZGFyaWVzW2JvdW5kYXJ5SW5kZXhdLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnRJZCA9ICcxJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYm91bmRhcnlJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgcGFydElkID0gdGhpcy5ib3VuZGFyaWVzW2ldLmNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBlbHNlIHBhcnRJZCArPSAnLicgKyB0aGlzLmJvdW5kYXJpZXNbaV0uY291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydElkO1xuICAgIH1cblxuICAgIGdldEFkZHJlc3Nlc0hUTUwodmFsdWUpIHtcbiAgICAgICAgbGV0IGZvcm1hdFNpbmdsZUxldmVsID0gYWRkcmVzc2VzID0+XG4gICAgICAgICAgICBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAubWFwKGFkZHJlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyID0gJzxzcGFuIGNsYXNzPVwibXBfYWRkcmVzc19ncm91cFwiPic7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnPHNwYW4gY2xhc3M9XCJtcF9hZGRyZXNzX25hbWVcIj4nICsgaGUuZW5jb2RlKGFkZHJlc3MubmFtZSkgKyAoYWRkcmVzcy5ncm91cCA/ICc6ICcgOiAnJykgKyAnPC9zcGFuPic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmsgPSAnPGEgaHJlZj1cIm1haWx0bzonICsgaGUuZW5jb2RlKGFkZHJlc3MuYWRkcmVzcykgKyAnXCIgY2xhc3M9XCJtcF9hZGRyZXNzX2VtYWlsXCI+JyArIGhlLmVuY29kZShhZGRyZXNzLmFkZHJlc3MpICsgJzwvYT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnICZsdDsnICsgbGluayArICcmZ3Q7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBmb3JtYXRTaW5nbGVMZXZlbChhZGRyZXNzLmdyb3VwKSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXRTaW5nbGVMZXZlbChbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICB9XG5cbiAgICBnZXRBZGRyZXNzZXNUZXh0KHZhbHVlKSB7XG4gICAgICAgIGxldCBmb3JtYXRTaW5nbGVMZXZlbCA9IGFkZHJlc3NlcyA9PlxuICAgICAgICAgICAgYWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgLm1hcChhZGRyZXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gYFwiJHthZGRyZXNzLm5hbWV9XCJgICsgKGFkZHJlc3MuZ3JvdXAgPyAnOiAnIDogJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5rID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnIDwnICsgbGluayArICc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGxpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBmb3JtYXRTaW5nbGVMZXZlbChhZGRyZXNzLmdyb3VwKSArICc7JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBmb3JtYXRTaW5nbGVMZXZlbChbXS5jb25jYXQodmFsdWUgfHwgW10pKTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbWFnZUxpbmtzKHJlcGxhY2VDYWxsYmFjaywgZG9uZSkge1xuICAgICAgICBpZiAoIXRoaXMuaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBkb25lKG51bGwsIGZhbHNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2lkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGh0bWwgPSAodGhpcy5odG1sIHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcEltYWdlTGlua3MpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbC5yZXBsYWNlKC9cXGJjaWQ6KFteJ1wiXFxzXXsxLDI1Nn0pL2csIChtYXRjaCwgY2lkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5hdHRhY2htZW50TGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0dGFjaG1lbnRMaXN0W2ldLmNpZCA9PT0gY2lkICYmIC9eaW1hZ2VcXC9bXFx3XSskL2kudGVzdCh0aGlzLmF0dGFjaG1lbnRMaXN0W2ldLmNvbnRlbnRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjaWRzLnNldChjaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQ6IHRoaXMuYXR0YWNobWVudExpc3RbaV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IGNpZExpc3QgPSBbXTtcbiAgICAgICAgY2lkcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGNpZExpc3QucHVzaChlbnRyeSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBsZXQgcHJvY2Vzc05leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zID49IGNpZExpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXFxiY2lkOihbXidcIlxcc117MSwyNTZ9KS9nLCAobWF0Y2gsIGNpZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2lkcy5oYXMoY2lkKSAmJiBjaWRzLmdldChjaWQpLnVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNpZHMuZ2V0KGNpZCkudXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKG51bGwsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVudHJ5ID0gY2lkTGlzdFtwb3MrK107XG4gICAgICAgICAgICByZXBsYWNlQ2FsbGJhY2soZW50cnkuYXR0YWNobWVudCwgKGVyciwgdXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKCgpID0+IGRvbmUoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudHJ5LnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUocHJvY2Vzc05leHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKHByb2Nlc3NOZXh0KTtcbiAgICB9XG5cbiAgICB0ZXh0VG9IdG1sKHN0cikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNraXBUZXh0VG9IdG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGVuY29kZWQ7XG5cbiAgICAgICAgbGV0IGxpbmtpZmllZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5za2lwVGV4dExpbmtzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5raWZ5LnByZXRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5raWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlua3MgPSBsaW5raWZ5Lm1hdGNoKHN0cikgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA8IGxpbmsuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFBhcnQgPSBoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGUgc3BlY2lhbCBjaGFyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW5jb2RlKHN0ci5zbGljZShsYXN0LCBsaW5rLmluZGV4KSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRleHRQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYDxhIGhyZWY9XCIke2xpbmsudXJsfVwiPiR7bGluay50ZXh0fTwvYT5gKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGxpbmsubGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFBhcnQgPSBoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5jb2RlIHNwZWNpYWwgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lbmNvZGUoc3RyLnNsaWNlKGxhc3QpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGV4dFBhcnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZWQgPSByZXN1bHQuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgIC8vIGZhaWxlZCwgZG9uJ3QgbGlua2lmeVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsaW5raWZpZWQpIHtcbiAgICAgICAgICAgIGVuY29kZWQgPSBoZVxuICAgICAgICAgICAgICAgIC8vIGVuY29kZSBzcGVjaWFsIGNoYXJzXG4gICAgICAgICAgICAgICAgLmVuY29kZShzdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlTmFtZWRSZWZlcmVuY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdGV4dCA9XG4gICAgICAgICAgICAnPHA+JyArXG4gICAgICAgICAgICBlbmNvZGVkXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccj9cXG4vZywgJ1xcbicpXG4gICAgICAgICAgICAgICAgLnRyaW0oKSAvLyBub3JtYWxpemUgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1sgXFx0XSskL2dtLCAnJylcbiAgICAgICAgICAgICAgICAudHJpbSgpIC8vIHRyaW0gZW1wdHkgbGluZSBlbmRpbmdzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcblxcbisvZywgJzwvcD48cD4nKVxuICAgICAgICAgICAgICAgIC50cmltKCkgLy8gaW5zZXJ0IDxwPiB0byBtdWx0aXBsZSBsaW5lYnJlYWtzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnPGJyLz4nKSArIC8vIGluc2VydCA8YnI+IHRvIHNpbmdsZSBsaW5lYnJlYWtzXG4gICAgICAgICAgICAnPC9wPic7XG5cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1haWxQYXJzZXI7XG4iXSwibmFtZXMiOlsibWFpbHNwbGl0IiwicmVxdWlyZSIsImxpYm1pbWUiLCJhZGRyZXNzcGFyc2VyIiwiVHJhbnNmb3JtIiwiU3BsaXR0ZXIiLCJDaHVua2VkUGFzc3Rocm91Z2giLCJwdW55Y29kZSIsIkZsb3dlZERlY29kZXIiLCJTdHJlYW1IYXNoIiwiaWNvbnYiLCJodG1sVG9UZXh0IiwiaGUiLCJsaW5raWZ5IiwidGxkcyIsImVuY29kaW5nSmFwYW5lc2UiLCJhZGQiLCJzZXQiLCJmdXp6eUlQIiwiZnV6enlMaW5rIiwiZnV6enlFbWFpbCIsInZhbGlkYXRlIiwidGV4dCIsInBvcyIsInNlbGYiLCJ0YWlsIiwic2xpY2UiLCJyZSIsInR3aXR0ZXIiLCJSZWdFeHAiLCJzcmNfWlBDYyIsInRlc3QiLCJtYXRjaCIsImxlbmd0aCIsIm5vcm1hbGl6ZSIsInVybCIsInJlcGxhY2UiLCJJY29udkRlY29kZXIiLCJjb25zdHJ1Y3RvciIsIkljb252IiwiY2hhcnNldCIsInRvTG93ZXJDYXNlIiwic3RyZWFtIiwiaW5wdXRFbmRlZCIsImVuZENiIiwib24iLCJlcnIiLCJlbWl0IiwiY2h1bmsiLCJwdXNoIiwiX3RyYW5zZm9ybSIsImVuY29kaW5nIiwiZG9uZSIsIndyaXRlIiwiX2ZsdXNoIiwiZW5kIiwiSlBEZWNvZGVyIiwiY2h1bmtzIiwiY2h1bmtsZW4iLCJCdWZmZXIiLCJmcm9tIiwiaW5wdXQiLCJjb25jYXQiLCJvdXRwdXQiLCJjb252ZXJ0IiwidG8iLCJ0eXBlIiwiTWFpbFBhcnNlciIsImNvbmZpZyIsInJlYWRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIm9wdGlvbnMiLCJjaHVua2VkUGFzc3Rocm91Z2giLCJzcGxpdHRlciIsInBpcGUiLCJmaW5pc2hlZCIsIndhaXRpbmdFbmQiLCJoZWFkZXJzIiwiaGVhZGVyTGluZXMiLCJlbmRSZWNlaXZlZCIsInJlYWRpbmciLCJoYXNGYWlsZWQiLCJ0cmVlIiwiY3Vybm9kZSIsIndhaXRVbnRpbEF0dGFjaG1lbnRFbmQiLCJhdHRhY2htZW50Q2FsbGJhY2siLCJoYXNIdG1sIiwiaGFzVGV4dCIsImh0bWwiLCJ0ZXh0QXNIdG1sIiwiYXR0YWNobWVudExpc3QiLCJib3VuZGFyaWVzIiwidGV4dFR5cGVzIiwia2VlcERlbGl2ZXJ5U3RhdHVzIiwiZGVjb2RlciIsImdldERlY29kZXIiLCJyZWFkRGF0YSIsImVuZFN0cmVhbSIsIkxpYm1pbWUiLCJkZWNvZGVTdHJlYW0iLCJ0b1N0cmluZyIsInRyaW0iLCJkYXRhIiwicmVhZCIsInByb2Nlc3NDaHVuayIsInNldEltbWVkaWF0ZSIsIm9uY2UiLCJjbGVhbnVwIiwiZmluaXNoIiwidCIsImdldFRleHRDb250ZW50IiwicmVhZGFibGUiLCJkZWNvZGVyRW5kZWQiLCJjb250ZW50U3RyZWFtIiwicHJvY2Vzc0hlYWRlcnMiLCJsaW5lcyIsIk1hcCIsImZvckVhY2giLCJsaW5lIiwia2V5IiwidmFsdWUiLCJkZWNvZGVIZWFkZXIiLCJwYXJzZUhlYWRlclZhbHVlIiwiZGVjb2RlV29yZHMiLCJPYmplY3QiLCJrZXlzIiwicGFyYW1zIiwiRSIsImRhdGVWYWx1ZSIsIkRhdGUiLCJpc05hTiIsInNwbGl0IiwibWFwIiwiZW5zdXJlTWVzc2FnZUlERm9ybWF0IiwicGFyc2VQcmlvcml0eSIsImRlY29kZUFkZHJlc3NlcyIsImdldEFkZHJlc3Nlc0hUTUwiLCJnZXRBZGRyZXNzZXNUZXh0Iiwic3Vic3RyIiwicGFyc2VMaXN0SGVhZGVyIiwiaGFzIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0Iiwic2luZ2xlS2V5cyIsImluY2x1ZGVzIiwibGlzdFZhbHVlIiwidmFsIiwibGlzdEtleSIsImFkZHJlc3NlcyIsInJlc3BvbnNlIiwiYWRkcmVzcyIsIm5hbWUiLCJtYWlsIiwiaW5kZXhPZiIsImlkIiwiZmlsdGVyIiwicGFyc2VJbnQiLCJjaGFyQXQiLCJwcm9jZXNzZWRBZGRyZXNzIiwiV2Vha1NldCIsImkiLCJwYXJzZWQiLCJlbnRyeSIsInNwbGljZSIsImxhc3RJbmRleE9mIiwidG9Vbmljb2RlIiwiZ3JvdXAiLCJjcmVhdGVOb2RlIiwibm9kZSIsImNvbnRlbnRUeXBlIiwiZGlzcG9zaXRpb24iLCJyb290IiwibmV3Tm9kZSIsImdldExpc3QiLCJjaGlsZHJlbiIsImlzQXR0YWNobWVudCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJwcm9jZXNzTm9kZSIsImFsdGVybmF0aXZlIiwibGV2ZWwiLCJzaG93TWV0YSIsIm1ldGEiLCJma2V5IiwiZm9ybWF0RGF0ZVN0cmluZyIsInRvVVRDU3RyaW5nIiwiZW5jb2RlIiwiam9pbiIsInRleHRDb250ZW50IiwidGV4dFRvSHRtbCIsImZhaWxlZFRvUGFyc2VIdG1sIiwic2tpcEh0bWxUb1RleHQiLCJtYXhIdG1sTGVuZ3RoVG9QYXJzZSIsIkVycm9yIiwic3ViTm9kZSIsInBhcnQiLCJwYXJ0SWQiLCJfcGFyZW50Qm91bmRhcnkiLCJfZ2V0UGFydElkIiwibSIsImMiLCJ0b1VwcGVyQ2FzZSIsIm1lc3NhZ2VOb2RlIiwiZmlsZW5hbWUiLCJkZXRlY3RNaW1lVHlwZSIsImF0dGFjaG1lbnQiLCJjb250ZW50IiwicmVsZWFzZSIsImFsZ28iLCJjaGVja3N1bUFsZ28iLCJoYXNoZXIiLCJjb250ZW50RGlzcG9zaXRpb24iLCJjb250ZW50SWQiLCJzaGlmdCIsImNpZCIsInJlbGF0ZWQiLCJmbG93ZWQiLCJmbG93RGVjb2RlciIsImRlbFNwIiwid3JpdGFibGUiLCJwYXJlbnRCb3VuZGFyeSIsImJvdW5kYXJ5SW5kZXgiLCJmaW5kSW5kZXgiLCJpdGVtIiwiY291bnQiLCJmb3JtYXRTaW5nbGVMZXZlbCIsInN0ciIsImxpbmsiLCJ1cGRhdGVJbWFnZUxpbmtzIiwicmVwbGFjZUNhbGxiYWNrIiwiY2lkcyIsInNraXBJbWFnZUxpbmtzIiwibGVuIiwiY2lkTGlzdCIsInByb2Nlc3NOZXh0Iiwic2tpcFRleHRUb0h0bWwiLCJlbmNvZGVkIiwibGlua2lmaWVkIiwic2tpcFRleHRMaW5rcyIsInByZXRlc3QiLCJsaW5rcyIsInJlc3VsdCIsImxhc3QiLCJpbmRleCIsInRleHRQYXJ0IiwidXNlTmFtZWRSZWZlcmVuY2VzIiwibGFzdEluZGV4IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/lib/mail-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mailparser/lib/simple-parser.js":
/*!******************************************************!*\
  !*** ./node_modules/mailparser/lib/simple-parser.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst MailParser = __webpack_require__(/*! ./mail-parser.js */ \"(rsc)/./node_modules/mailparser/lib/mail-parser.js\");\nmodule.exports = (input, options, callback)=>{\n    if (input === null || input === undefined) {\n        throw new TypeError(\"Input cannot be null or undefined.\");\n    }\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = false;\n    }\n    let promise;\n    if (!callback) {\n        promise = new Promise((resolve, reject)=>{\n            callback = callbackPromise(resolve, reject);\n        });\n    }\n    options = options || {};\n    let keepCidLinks = !!options.keepCidLinks;\n    let mail = {\n        attachments: []\n    };\n    let parser = new MailParser(options);\n    parser.on(\"error\", (err)=>{\n        callback(err);\n    });\n    parser.on(\"headers\", (headers)=>{\n        mail.headers = headers;\n        mail.headerLines = parser.headerLines;\n    });\n    let reading = false;\n    let reader = ()=>{\n        reading = true;\n        let data = parser.read();\n        if (data === null) {\n            reading = false;\n            return;\n        }\n        if (data.type === \"text\") {\n            Object.keys(data).forEach((key)=>{\n                if ([\n                    \"text\",\n                    \"html\",\n                    \"textAsHtml\"\n                ].includes(key)) {\n                    mail[key] = data[key];\n                }\n            });\n        }\n        if (data.type === \"attachment\") {\n            mail.attachments.push(data);\n            let chunks = [];\n            let chunklen = 0;\n            data.content.on(\"readable\", ()=>{\n                let chunk;\n                while((chunk = data.content.read()) !== null){\n                    chunks.push(chunk);\n                    chunklen += chunk.length;\n                }\n            });\n            data.content.on(\"end\", ()=>{\n                data.content = Buffer.concat(chunks, chunklen);\n                data.release();\n                reader();\n            });\n        } else {\n            reader();\n        }\n    };\n    parser.on(\"readable\", ()=>{\n        if (!reading) {\n            reader();\n        }\n    });\n    parser.on(\"end\", ()=>{\n        [\n            \"subject\",\n            \"references\",\n            \"date\",\n            \"to\",\n            \"from\",\n            \"to\",\n            \"cc\",\n            \"bcc\",\n            \"message-id\",\n            \"in-reply-to\",\n            \"reply-to\"\n        ].forEach((key)=>{\n            if (mail.headers && mail.headers.has(key)) {\n                mail[key.replace(/-([a-z])/g, (m, c)=>c.toUpperCase())] = mail.headers.get(key);\n            }\n        });\n        if (keepCidLinks) {\n            return callback(null, mail);\n        }\n        parser.updateImageLinks((attachment, done)=>done(false, \"data:\" + attachment.contentType + \";base64,\" + attachment.content.toString(\"base64\")), (err, html)=>{\n            if (err) {\n                return callback(err);\n            }\n            mail.html = html;\n            callback(null, mail);\n        });\n    });\n    if (typeof input === \"string\") {\n        parser.end(Buffer.from(input));\n    } else if (Buffer.isBuffer(input)) {\n        parser.end(input);\n    } else {\n        input.once(\"error\", (err)=>{\n            input.destroy();\n            parser.destroy();\n            callback(err);\n        }).pipe(parser);\n    }\n    return promise;\n};\nfunction callbackPromise(resolve, reject) {\n    return function(...args) {\n        let err = args.shift();\n        if (err) {\n            reject(err);\n        } else {\n            resolve(...args);\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9saWIvc2ltcGxlLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGFBQWFDLG1CQUFPQSxDQUFDO0FBRTNCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQ0MsT0FBT0MsU0FBU0M7SUFDOUIsSUFBSUYsVUFBVSxRQUFRQSxVQUFVRyxXQUFXO1FBQ3ZDLE1BQU0sSUFBSUMsVUFBVTtJQUN4QjtJQUVBLElBQUksQ0FBQ0YsWUFBWSxPQUFPRCxZQUFZLFlBQVk7UUFDNUNDLFdBQVdEO1FBQ1hBLFVBQVU7SUFDZDtJQUVBLElBQUlJO0lBQ0osSUFBSSxDQUFDSCxVQUFVO1FBQ1hHLFVBQVUsSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUM1Qk4sV0FBV08sZ0JBQWdCRixTQUFTQztRQUN4QztJQUNKO0lBRUFQLFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJUyxlQUFlLENBQUMsQ0FBQ1QsUUFBUVMsWUFBWTtJQUV6QyxJQUFJQyxPQUFPO1FBQ1BDLGFBQWEsRUFBRTtJQUNuQjtJQUVBLElBQUlDLFNBQVMsSUFBSWpCLFdBQVdLO0lBRTVCWSxPQUFPQyxFQUFFLENBQUMsU0FBU0MsQ0FBQUE7UUFDZmIsU0FBU2E7SUFDYjtJQUVBRixPQUFPQyxFQUFFLENBQUMsV0FBV0UsQ0FBQUE7UUFDakJMLEtBQUtLLE9BQU8sR0FBR0E7UUFDZkwsS0FBS00sV0FBVyxHQUFHSixPQUFPSSxXQUFXO0lBQ3pDO0lBRUEsSUFBSUMsVUFBVTtJQUNkLElBQUlDLFNBQVM7UUFDVEQsVUFBVTtRQUVWLElBQUlFLE9BQU9QLE9BQU9RLElBQUk7UUFFdEIsSUFBSUQsU0FBUyxNQUFNO1lBQ2ZGLFVBQVU7WUFDVjtRQUNKO1FBRUEsSUFBSUUsS0FBS0UsSUFBSSxLQUFLLFFBQVE7WUFDdEJDLE9BQU9DLElBQUksQ0FBQ0osTUFBTUssT0FBTyxDQUFDQyxDQUFBQTtnQkFDdEIsSUFBSTtvQkFBQztvQkFBUTtvQkFBUTtpQkFBYSxDQUFDQyxRQUFRLENBQUNELE1BQU07b0JBQzlDZixJQUFJLENBQUNlLElBQUksR0FBR04sSUFBSSxDQUFDTSxJQUFJO2dCQUN6QjtZQUNKO1FBQ0o7UUFFQSxJQUFJTixLQUFLRSxJQUFJLEtBQUssY0FBYztZQUM1QlgsS0FBS0MsV0FBVyxDQUFDZ0IsSUFBSSxDQUFDUjtZQUV0QixJQUFJUyxTQUFTLEVBQUU7WUFDZixJQUFJQyxXQUFXO1lBQ2ZWLEtBQUtXLE9BQU8sQ0FBQ2pCLEVBQUUsQ0FBQyxZQUFZO2dCQUN4QixJQUFJa0I7Z0JBQ0osTUFBTyxDQUFDQSxRQUFRWixLQUFLVyxPQUFPLENBQUNWLElBQUksRUFBQyxNQUFPLEtBQU07b0JBQzNDUSxPQUFPRCxJQUFJLENBQUNJO29CQUNaRixZQUFZRSxNQUFNQyxNQUFNO2dCQUM1QjtZQUNKO1lBRUFiLEtBQUtXLE9BQU8sQ0FBQ2pCLEVBQUUsQ0FBQyxPQUFPO2dCQUNuQk0sS0FBS1csT0FBTyxHQUFHRyxPQUFPQyxNQUFNLENBQUNOLFFBQVFDO2dCQUNyQ1YsS0FBS2dCLE9BQU87Z0JBQ1pqQjtZQUNKO1FBQ0osT0FBTztZQUNIQTtRQUNKO0lBQ0o7SUFFQU4sT0FBT0MsRUFBRSxDQUFDLFlBQVk7UUFDbEIsSUFBSSxDQUFDSSxTQUFTO1lBQ1ZDO1FBQ0o7SUFDSjtJQUVBTixPQUFPQyxFQUFFLENBQUMsT0FBTztRQUNiO1lBQUM7WUFBVztZQUFjO1lBQVE7WUFBTTtZQUFRO1lBQU07WUFBTTtZQUFPO1lBQWM7WUFBZTtTQUFXLENBQUNXLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDaEgsSUFBSWYsS0FBS0ssT0FBTyxJQUFJTCxLQUFLSyxPQUFPLENBQUNxQixHQUFHLENBQUNYLE1BQU07Z0JBQ3ZDZixJQUFJLENBQUNlLElBQUlZLE9BQU8sQ0FBQyxhQUFhLENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFdBQVcsSUFBSSxHQUFHOUIsS0FBS0ssT0FBTyxDQUFDMEIsR0FBRyxDQUFDaEI7WUFDakY7UUFDSjtRQUVBLElBQUloQixjQUFjO1lBQ2QsT0FBT1IsU0FBUyxNQUFNUztRQUMxQjtRQUNBRSxPQUFPOEIsZ0JBQWdCLENBQ25CLENBQUNDLFlBQVlDLE9BQVNBLEtBQUssT0FBTyxVQUFVRCxXQUFXRSxXQUFXLEdBQUcsYUFBYUYsV0FBV2IsT0FBTyxDQUFDZ0IsUUFBUSxDQUFDLFlBQzlHLENBQUNoQyxLQUFLaUM7WUFDRixJQUFJakMsS0FBSztnQkFDTCxPQUFPYixTQUFTYTtZQUNwQjtZQUNBSixLQUFLcUMsSUFBSSxHQUFHQTtZQUVaOUMsU0FBUyxNQUFNUztRQUNuQjtJQUVSO0lBRUEsSUFBSSxPQUFPWCxVQUFVLFVBQVU7UUFDM0JhLE9BQU9vQyxHQUFHLENBQUNmLE9BQU9nQixJQUFJLENBQUNsRDtJQUMzQixPQUFPLElBQUlrQyxPQUFPaUIsUUFBUSxDQUFDbkQsUUFBUTtRQUMvQmEsT0FBT29DLEdBQUcsQ0FBQ2pEO0lBQ2YsT0FBTztRQUNIQSxNQUNLb0QsSUFBSSxDQUFDLFNBQVNyQyxDQUFBQTtZQUNYZixNQUFNcUQsT0FBTztZQUNieEMsT0FBT3dDLE9BQU87WUFDZG5ELFNBQVNhO1FBQ2IsR0FDQ3VDLElBQUksQ0FBQ3pDO0lBQ2Q7SUFFQSxPQUFPUjtBQUNYO0FBRUEsU0FBU0ksZ0JBQWdCRixPQUFPLEVBQUVDLE1BQU07SUFDcEMsT0FBTyxTQUFVLEdBQUcrQyxJQUFJO1FBQ3BCLElBQUl4QyxNQUFNd0MsS0FBS0MsS0FBSztRQUNwQixJQUFJekMsS0FBSztZQUNMUCxPQUFPTztRQUNYLE9BQU87WUFDSFIsV0FBV2dEO1FBQ2Y7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQVNXRCBDbGllbnQgSHViLy4vbm9kZV9tb2R1bGVzL21haWxwYXJzZXIvbGliL3NpbXBsZS1wYXJzZXIuanM/MjMyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1haWxQYXJzZXIgPSByZXF1aXJlKCcuL21haWwtcGFyc2VyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKGlucHV0LCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2tQcm9taXNlKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCBrZWVwQ2lkTGlua3MgPSAhIW9wdGlvbnMua2VlcENpZExpbmtzO1xuXG4gICAgbGV0IG1haWwgPSB7XG4gICAgICAgIGF0dGFjaG1lbnRzOiBbXVxuICAgIH07XG5cbiAgICBsZXQgcGFyc2VyID0gbmV3IE1haWxQYXJzZXIob3B0aW9ucyk7XG5cbiAgICBwYXJzZXIub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHBhcnNlci5vbignaGVhZGVycycsIGhlYWRlcnMgPT4ge1xuICAgICAgICBtYWlsLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICBtYWlsLmhlYWRlckxpbmVzID0gcGFyc2VyLmhlYWRlckxpbmVzO1xuICAgIH0pO1xuXG4gICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgcmVhZGVyID0gKCkgPT4ge1xuICAgICAgICByZWFkaW5nID0gdHJ1ZTtcblxuICAgICAgICBsZXQgZGF0YSA9IHBhcnNlci5yZWFkKCk7XG5cbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChbJ3RleHQnLCAnaHRtbCcsICd0ZXh0QXNIdG1sJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBtYWlsW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnYXR0YWNobWVudCcpIHtcbiAgICAgICAgICAgIG1haWwuYXR0YWNobWVudHMucHVzaChkYXRhKTtcblxuICAgICAgICAgICAgbGV0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGNodW5rbGVuID0gMDtcbiAgICAgICAgICAgIGRhdGEuY29udGVudC5vbigncmVhZGFibGUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoY2h1bmsgPSBkYXRhLmNvbnRlbnQucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rbGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGF0YS5jb250ZW50Lm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGF0YS5jb250ZW50ID0gQnVmZmVyLmNvbmNhdChjaHVua3MsIGNodW5rbGVuKTtcbiAgICAgICAgICAgICAgICBkYXRhLnJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICByZWFkZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZGVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcGFyc2VyLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgaWYgKCFyZWFkaW5nKSB7XG4gICAgICAgICAgICByZWFkZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcGFyc2VyLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIFsnc3ViamVjdCcsICdyZWZlcmVuY2VzJywgJ2RhdGUnLCAndG8nLCAnZnJvbScsICd0bycsICdjYycsICdiY2MnLCAnbWVzc2FnZS1pZCcsICdpbi1yZXBseS10bycsICdyZXBseS10byddLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChtYWlsLmhlYWRlcnMgJiYgbWFpbC5oZWFkZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbWFpbFtrZXkucmVwbGFjZSgvLShbYS16XSkvZywgKG0sIGMpID0+IGMudG9VcHBlckNhc2UoKSldID0gbWFpbC5oZWFkZXJzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoa2VlcENpZExpbmtzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbWFpbCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLnVwZGF0ZUltYWdlTGlua3MoXG4gICAgICAgICAgICAoYXR0YWNobWVudCwgZG9uZSkgPT4gZG9uZShmYWxzZSwgJ2RhdGE6JyArIGF0dGFjaG1lbnQuY29udGVudFR5cGUgKyAnO2Jhc2U2NCwnICsgYXR0YWNobWVudC5jb250ZW50LnRvU3RyaW5nKCdiYXNlNjQnKSksXG4gICAgICAgICAgICAoZXJyLCBodG1sKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFpbC5odG1sID0gaHRtbDtcblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1haWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyc2VyLmVuZChCdWZmZXIuZnJvbShpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICBwYXJzZXIuZW5kKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dFxuICAgICAgICAgICAgLm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5waXBlKHBhcnNlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5mdW5jdGlvbiBjYWxsYmFja1Byb21pc2UocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGxldCBlcnIgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiTWFpbFBhcnNlciIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiaW5wdXQiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJjYWxsYmFja1Byb21pc2UiLCJrZWVwQ2lkTGlua3MiLCJtYWlsIiwiYXR0YWNobWVudHMiLCJwYXJzZXIiLCJvbiIsImVyciIsImhlYWRlcnMiLCJoZWFkZXJMaW5lcyIsInJlYWRpbmciLCJyZWFkZXIiLCJkYXRhIiwicmVhZCIsInR5cGUiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwicHVzaCIsImNodW5rcyIsImNodW5rbGVuIiwiY29udGVudCIsImNodW5rIiwibGVuZ3RoIiwiQnVmZmVyIiwiY29uY2F0IiwicmVsZWFzZSIsImhhcyIsInJlcGxhY2UiLCJtIiwiYyIsInRvVXBwZXJDYXNlIiwiZ2V0IiwidXBkYXRlSW1hZ2VMaW5rcyIsImF0dGFjaG1lbnQiLCJkb25lIiwiY29udGVudFR5cGUiLCJ0b1N0cmluZyIsImh0bWwiLCJlbmQiLCJmcm9tIiwiaXNCdWZmZXIiLCJvbmNlIiwiZGVzdHJveSIsInBpcGUiLCJhcmdzIiwic2hpZnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/lib/simple-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/mailparser/lib/stream-hash.js":
/*!****************************************************!*\
  !*** ./node_modules/mailparser/lib/stream-hash.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nclass StreamHash extends Transform {\n    constructor(attachment, algo){\n        super();\n        this.attachment = attachment;\n        this.algo = (algo || \"md5\").toLowerCase();\n        this.hash = crypto.createHash(algo);\n        this.byteCount = 0;\n    }\n    _transform(chunk, encoding, done) {\n        this.hash.update(chunk);\n        this.byteCount += chunk.length;\n        done(null, chunk);\n    }\n    _flush(done) {\n        this.attachment.checksum = this.hash.digest(\"hex\");\n        this.attachment.size = this.byteCount;\n        done();\n    }\n}\nmodule.exports = StreamHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9saWIvc3RyZWFtLWhhc2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUN2QixNQUFNQyxZQUFZRCx1REFBMkI7QUFFN0MsTUFBTUUsbUJBQW1CRDtJQUNyQkUsWUFBWUMsVUFBVSxFQUFFQyxJQUFJLENBQUU7UUFDMUIsS0FBSztRQUNMLElBQUksQ0FBQ0QsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLElBQUksR0FBRyxDQUFDQSxRQUFRLEtBQUksRUFBR0MsV0FBVztRQUN2QyxJQUFJLENBQUNDLElBQUksR0FBR1IsT0FBT1MsVUFBVSxDQUFDSDtRQUM5QixJQUFJLENBQUNJLFNBQVMsR0FBRztJQUNyQjtJQUVBQyxXQUFXQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUFFO1FBQzlCLElBQUksQ0FBQ04sSUFBSSxDQUFDTyxNQUFNLENBQUNIO1FBQ2pCLElBQUksQ0FBQ0YsU0FBUyxJQUFJRSxNQUFNSSxNQUFNO1FBQzlCRixLQUFLLE1BQU1GO0lBQ2Y7SUFFQUssT0FBT0gsSUFBSSxFQUFFO1FBQ1QsSUFBSSxDQUFDVCxVQUFVLENBQUNhLFFBQVEsR0FBRyxJQUFJLENBQUNWLElBQUksQ0FBQ1csTUFBTSxDQUFDO1FBQzVDLElBQUksQ0FBQ2QsVUFBVSxDQUFDZSxJQUFJLEdBQUcsSUFBSSxDQUFDVixTQUFTO1FBQ3JDSTtJQUNKO0FBQ0o7QUFFQU8sT0FBT0MsT0FBTyxHQUFHbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BU1dEIENsaWVudCBIdWIvLi9ub2RlX21vZHVsZXMvbWFpbHBhcnNlci9saWIvc3RyZWFtLWhhc2guanM/OTMzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xuXG5jbGFzcyBTdHJlYW1IYXNoIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihhdHRhY2htZW50LCBhbGdvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXR0YWNobWVudCA9IGF0dGFjaG1lbnQ7XG4gICAgICAgIHRoaXMuYWxnbyA9IChhbGdvIHx8ICdtZDUnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLmhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvKTtcbiAgICAgICAgdGhpcy5ieXRlQ291bnQgPSAwO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgICAgIHRoaXMuaGFzaC51cGRhdGUoY2h1bmspO1xuICAgICAgICB0aGlzLmJ5dGVDb3VudCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGRvbmUobnVsbCwgY2h1bmspO1xuICAgIH1cblxuICAgIF9mbHVzaChkb25lKSB7XG4gICAgICAgIHRoaXMuYXR0YWNobWVudC5jaGVja3N1bSA9IHRoaXMuaGFzaC5kaWdlc3QoJ2hleCcpO1xuICAgICAgICB0aGlzLmF0dGFjaG1lbnQuc2l6ZSA9IHRoaXMuYnl0ZUNvdW50O1xuICAgICAgICBkb25lKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbUhhc2g7XG4iXSwibmFtZXMiOlsiY3J5cHRvIiwicmVxdWlyZSIsIlRyYW5zZm9ybSIsIlN0cmVhbUhhc2giLCJjb25zdHJ1Y3RvciIsImF0dGFjaG1lbnQiLCJhbGdvIiwidG9Mb3dlckNhc2UiLCJoYXNoIiwiY3JlYXRlSGFzaCIsImJ5dGVDb3VudCIsIl90cmFuc2Zvcm0iLCJjaHVuayIsImVuY29kaW5nIiwiZG9uZSIsInVwZGF0ZSIsImxlbmd0aCIsIl9mbHVzaCIsImNoZWNrc3VtIiwiZGlnZXN0Iiwic2l6ZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mailparser/lib/stream-hash.js\n");

/***/ })

};
;