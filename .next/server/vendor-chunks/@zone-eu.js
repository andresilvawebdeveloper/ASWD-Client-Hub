"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zone-eu";
exports.ids = ["vendor-chunks/@zone-eu"];
exports.modules = {

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst MessageSplitter = __webpack_require__(/*! ./lib/message-splitter */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-splitter.js\");\nconst MessageJoiner = __webpack_require__(/*! ./lib/message-joiner */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-joiner.js\");\nconst NodeRewriter = __webpack_require__(/*! ./lib/node-rewriter */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js\");\nconst NodeStreamer = __webpack_require__(/*! ./lib/node-streamer */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-streamer.js\");\nconst Headers = __webpack_require__(/*! ./lib/headers */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js\");\nconst ChunkedPassthrough = __webpack_require__(/*! ./lib/chunked-passthrough */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js\");\nmodule.exports = {\n    Splitter: MessageSplitter,\n    Joiner: MessageJoiner,\n    Rewriter: NodeRewriter,\n    Streamer: NodeStreamer,\n    ChunkedPassthrough,\n    Headers\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsa0JBQWtCQyxtQkFBT0EsQ0FBQztBQUNoQyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBQzlCLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDO0FBQ3hCLE1BQU1LLHFCQUFxQkwsbUJBQU9BLENBQUM7QUFFbkNNLE9BQU9DLE9BQU8sR0FBRztJQUNiQyxVQUFVVDtJQUNWVSxRQUFRUjtJQUNSUyxVQUFVUjtJQUNWUyxVQUFVUjtJQUNWRTtJQUNBRDtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQVNXRCBDbGllbnQgSHViLy4vbm9kZV9tb2R1bGVzL0B6b25lLWV1L21haWxzcGxpdC9pbmRleC5qcz9kOTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWVzc2FnZVNwbGl0dGVyID0gcmVxdWlyZSgnLi9saWIvbWVzc2FnZS1zcGxpdHRlcicpO1xuY29uc3QgTWVzc2FnZUpvaW5lciA9IHJlcXVpcmUoJy4vbGliL21lc3NhZ2Utam9pbmVyJyk7XG5jb25zdCBOb2RlUmV3cml0ZXIgPSByZXF1aXJlKCcuL2xpYi9ub2RlLXJld3JpdGVyJyk7XG5jb25zdCBOb2RlU3RyZWFtZXIgPSByZXF1aXJlKCcuL2xpYi9ub2RlLXN0cmVhbWVyJyk7XG5jb25zdCBIZWFkZXJzID0gcmVxdWlyZSgnLi9saWIvaGVhZGVycycpO1xuY29uc3QgQ2h1bmtlZFBhc3N0aHJvdWdoID0gcmVxdWlyZSgnLi9saWIvY2h1bmtlZC1wYXNzdGhyb3VnaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBTcGxpdHRlcjogTWVzc2FnZVNwbGl0dGVyLFxuICAgIEpvaW5lcjogTWVzc2FnZUpvaW5lcixcbiAgICBSZXdyaXRlcjogTm9kZVJld3JpdGVyLFxuICAgIFN0cmVhbWVyOiBOb2RlU3RyZWFtZXIsXG4gICAgQ2h1bmtlZFBhc3N0aHJvdWdoLFxuICAgIEhlYWRlcnNcbn07XG4iXSwibmFtZXMiOlsiTWVzc2FnZVNwbGl0dGVyIiwicmVxdWlyZSIsIk1lc3NhZ2VKb2luZXIiLCJOb2RlUmV3cml0ZXIiLCJOb2RlU3RyZWFtZXIiLCJIZWFkZXJzIiwiQ2h1bmtlZFBhc3N0aHJvdWdoIiwibW9kdWxlIiwiZXhwb3J0cyIsIlNwbGl0dGVyIiwiSm9pbmVyIiwiUmV3cml0ZXIiLCJTdHJlYW1lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Transform } = __webpack_require__(/*! stream */ \"stream\");\nclass ChunkedPassthrough extends Transform {\n    constructor(options = {}){\n        let config = {\n            readableObjectMode: true,\n            writableObjectMode: false\n        };\n        super(config);\n        this.chunkSize = options.chunkSize || 64 * 1024; // 64KB default\n        this.buffer = Buffer.alloc(0);\n    }\n    _transform(chunk, encoding, callback) {\n        this.buffer = Buffer.concat([\n            this.buffer,\n            chunk\n        ]);\n        if (this.buffer.length >= this.chunkSize) {\n            this.push(this.buffer);\n            this.buffer = Buffer.alloc(0);\n        }\n        callback();\n    }\n    _flush(callback) {\n        // Send remaining data\n        if (this.buffer.length > 0) {\n            this.push(this.buffer);\n            this.buffer = Buffer.alloc(0);\n        }\n        callback();\n    }\n}\nmodule.exports = ChunkedPassthrough;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9jaHVua2VkLXBhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFOUIsTUFBTUMsMkJBQTJCRjtJQUM3QkcsWUFBWUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUN0QixJQUFJQyxTQUFTO1lBQ1RDLG9CQUFvQjtZQUNwQkMsb0JBQW9CO1FBQ3hCO1FBQ0EsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0csU0FBUyxHQUFHSixRQUFRSSxTQUFTLElBQUksS0FBSyxNQUFNLGVBQWU7UUFDaEUsSUFBSSxDQUFDQyxNQUFNLEdBQUdDLE9BQU9DLEtBQUssQ0FBQztJQUMvQjtJQUVBQyxXQUFXQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLElBQUksQ0FBQ04sTUFBTSxHQUFHQyxPQUFPTSxNQUFNLENBQUM7WUFBQyxJQUFJLENBQUNQLE1BQU07WUFBRUk7U0FBTTtRQUVoRCxJQUFJLElBQUksQ0FBQ0osTUFBTSxDQUFDUSxNQUFNLElBQUksSUFBSSxDQUFDVCxTQUFTLEVBQUU7WUFDdEMsSUFBSSxDQUFDVSxJQUFJLENBQUMsSUFBSSxDQUFDVCxNQUFNO1lBQ3JCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQyxPQUFPQyxLQUFLLENBQUM7UUFDL0I7UUFFQUk7SUFDSjtJQUVBSSxPQUFPSixRQUFRLEVBQUU7UUFDYixzQkFBc0I7UUFDdEIsSUFBSSxJQUFJLENBQUNOLE1BQU0sQ0FBQ1EsTUFBTSxHQUFHLEdBQUc7WUFDeEIsSUFBSSxDQUFDQyxJQUFJLENBQUMsSUFBSSxDQUFDVCxNQUFNO1lBQ3JCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQyxPQUFPQyxLQUFLLENBQUM7UUFDL0I7UUFDQUk7SUFDSjtBQUNKO0FBRUFLLE9BQU9DLE9BQU8sR0FBR25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQVNXRCBDbGllbnQgSHViLy4vbm9kZV9tb2R1bGVzL0B6b25lLWV1L21haWxzcGxpdC9saWIvY2h1bmtlZC1wYXNzdGhyb3VnaC5qcz8wNDU3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jbGFzcyBDaHVua2VkUGFzc3Rocm91Z2ggZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLmNodW5rU2l6ZSA9IG9wdGlvbnMuY2h1bmtTaXplIHx8IDY0ICogMTAyNDsgLy8gNjRLQiBkZWZhdWx0XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmZmVyLCBjaHVua10pO1xuXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFNlbmQgcmVtYWluaW5nIGRhdGFcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDaHVua2VkUGFzc3Rocm91Z2g7XG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtIiwicmVxdWlyZSIsIkNodW5rZWRQYXNzdGhyb3VnaCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImNvbmZpZyIsInJlYWRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImNodW5rU2l6ZSIsImJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsImNvbmNhdCIsImxlbmd0aCIsInB1c2giLCJfZmx1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/chunked-passthrough.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js":
/*!***************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// Helper class to rewrite nodes with specific mime type\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\n/**\n * Really bad \"stream\" transform to parse format=flowed content\n *\n * @constructor\n * @param {String} delSp True if delsp option was used\n */ class FlowedDecoder extends Transform {\n    constructor(config){\n        super();\n        this.config = config || {};\n        this.chunks = [];\n        this.chunklen = 0;\n        this.libmime = new libmime.Libmime({\n            Iconv: config.Iconv\n        });\n    }\n    _transform(chunk, encoding, callback) {\n        if (!chunk || !chunk.length) {\n            return callback();\n        }\n        if (!encoding !== \"buffer\") {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        this.chunks.push(chunk);\n        this.chunklen += chunk.length;\n        callback();\n    }\n    _flush(callback) {\n        if (this.chunklen) {\n            let currentBody = Buffer.concat(this.chunks, this.chunklen);\n            if (this.config.encoding === \"base64\") {\n                currentBody = Buffer.from(currentBody.toString(\"binary\"), \"base64\");\n            }\n            let content = this.libmime.decodeFlowed(currentBody.toString(\"binary\"), this.config.delSp);\n            this.push(Buffer.from(content, \"binary\"));\n        }\n        return callback();\n    }\n}\nmodule.exports = FlowedDecoder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9mbG93ZWQtZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLHdEQUF3RDtBQUV4RCxNQUFNQSxZQUFZQyx1REFBMkI7QUFDN0MsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUM7QUFFeEI7Ozs7O0NBS0MsR0FDRCxNQUFNRSxzQkFBc0JIO0lBQ3hCSSxZQUFZQyxNQUFNLENBQUU7UUFDaEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsTUFBTSxHQUFHQSxVQUFVLENBQUM7UUFFekIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUVoQixJQUFJLENBQUNMLE9BQU8sR0FBRyxJQUFJQSxRQUFRTSxPQUFPLENBQUM7WUFBRUMsT0FBT0osT0FBT0ksS0FBSztRQUFDO0lBQzdEO0lBRUFDLFdBQVdDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDbEMsSUFBSSxDQUFDRixTQUFTLENBQUNBLE1BQU1HLE1BQU0sRUFBRTtZQUN6QixPQUFPRDtRQUNYO1FBRUEsSUFBSSxDQUFDRCxhQUFhLFVBQVU7WUFDeEJELFFBQVFJLE9BQU9DLElBQUksQ0FBQ0wsT0FBT0M7UUFDL0I7UUFFQSxJQUFJLENBQUNOLE1BQU0sQ0FBQ1csSUFBSSxDQUFDTjtRQUNqQixJQUFJLENBQUNKLFFBQVEsSUFBSUksTUFBTUcsTUFBTTtRQUU3QkQ7SUFDSjtJQUVBSyxPQUFPTCxRQUFRLEVBQUU7UUFDYixJQUFJLElBQUksQ0FBQ04sUUFBUSxFQUFFO1lBQ2YsSUFBSVksY0FBY0osT0FBT0ssTUFBTSxDQUFDLElBQUksQ0FBQ2QsTUFBTSxFQUFFLElBQUksQ0FBQ0MsUUFBUTtZQUUxRCxJQUFJLElBQUksQ0FBQ0YsTUFBTSxDQUFDTyxRQUFRLEtBQUssVUFBVTtnQkFDbkNPLGNBQWNKLE9BQU9DLElBQUksQ0FBQ0csWUFBWUUsUUFBUSxDQUFDLFdBQVc7WUFDOUQ7WUFFQSxJQUFJQyxVQUFVLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ3FCLFlBQVksQ0FBQ0osWUFBWUUsUUFBUSxDQUFDLFdBQVcsSUFBSSxDQUFDaEIsTUFBTSxDQUFDbUIsS0FBSztZQUN6RixJQUFJLENBQUNQLElBQUksQ0FBQ0YsT0FBT0MsSUFBSSxDQUFDTSxTQUFTO1FBQ25DO1FBQ0EsT0FBT1Q7SUFDWDtBQUNKO0FBRUFZLE9BQU9DLE9BQU8sR0FBR3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQVNXRCBDbGllbnQgSHViLy4vbm9kZV9tb2R1bGVzL0B6b25lLWV1L21haWxzcGxpdC9saWIvZmxvd2VkLWRlY29kZXIuanM/MDRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIEhlbHBlciBjbGFzcyB0byByZXdyaXRlIG5vZGVzIHdpdGggc3BlY2lmaWMgbWltZSB0eXBlXG5cbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbmNvbnN0IGxpYm1pbWUgPSByZXF1aXJlKCdsaWJtaW1lJyk7XG5cbi8qKlxuICogUmVhbGx5IGJhZCBcInN0cmVhbVwiIHRyYW5zZm9ybSB0byBwYXJzZSBmb3JtYXQ9Zmxvd2VkIGNvbnRlbnRcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZWxTcCBUcnVlIGlmIGRlbHNwIG9wdGlvbiB3YXMgdXNlZFxuICovXG5jbGFzcyBGbG93ZWREZWNvZGVyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua2xlbiA9IDA7XG5cbiAgICAgICAgdGhpcy5saWJtaW1lID0gbmV3IGxpYm1pbWUuTGlibWltZSh7IEljb252OiBjb25maWcuSWNvbnYgfSk7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVuY29kaW5nICE9PSAnYnVmZmVyJykge1xuICAgICAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgIHRoaXMuY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNodW5rbGVuKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEJvZHkgPSBCdWZmZXIuY29uY2F0KHRoaXMuY2h1bmtzLCB0aGlzLmNodW5rbGVuKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5ID0gQnVmZmVyLmZyb20oY3VycmVudEJvZHkudG9TdHJpbmcoJ2JpbmFyeScpLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5saWJtaW1lLmRlY29kZUZsb3dlZChjdXJyZW50Qm9keS50b1N0cmluZygnYmluYXJ5JyksIHRoaXMuY29uZmlnLmRlbFNwKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChCdWZmZXIuZnJvbShjb250ZW50LCAnYmluYXJ5JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGbG93ZWREZWNvZGVyO1xuIl0sIm5hbWVzIjpbIlRyYW5zZm9ybSIsInJlcXVpcmUiLCJsaWJtaW1lIiwiRmxvd2VkRGVjb2RlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiY2h1bmtzIiwiY2h1bmtsZW4iLCJMaWJtaW1lIiwiSWNvbnYiLCJfdHJhbnNmb3JtIiwiY2h1bmsiLCJlbmNvZGluZyIsImNhbGxiYWNrIiwibGVuZ3RoIiwiQnVmZmVyIiwiZnJvbSIsInB1c2giLCJfZmx1c2giLCJjdXJyZW50Qm9keSIsImNvbmNhdCIsInRvU3RyaW5nIiwiY29udGVudCIsImRlY29kZUZsb3dlZCIsImRlbFNwIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js":
/*!********************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/headers.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\n/**\n * Class Headers to parse and handle message headers. Headers instance allows to\n * check existing, delete or add new headers\n */ class Headers {\n    constructor(headers, config){\n        config = config || {};\n        if (Array.isArray(headers)) {\n            // already using parsed headers\n            this.changed = true;\n            this.headers = false;\n            this.parsed = true;\n            this.lines = headers;\n        } else {\n            // using original string/buffer headers\n            this.changed = false;\n            this.headers = headers;\n            this.parsed = false;\n            this.lines = false;\n        }\n        this.mbox = false;\n        this.http = false;\n        this.libmime = new libmime.Libmime({\n            Iconv: config.Iconv\n        });\n    }\n    hasHeader(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        return typeof this.lines.find((line)=>line.key === key) === \"object\";\n    }\n    get(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        let lines = this.lines.filter((line)=>line.key === key).map((line)=>line.line);\n        return lines;\n    }\n    getDecoded(key) {\n        return this.get(key).map((line)=>this.libmime.decodeHeader(line)).filter((line)=>line && line.value);\n    }\n    getFirst(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        let header = this.lines.find((line)=>line.key === key);\n        if (!header) {\n            return \"\";\n        }\n        return ((this.libmime.decodeHeader(header.line) || {}).value || \"\").toString().trim();\n    }\n    getList() {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        return this.lines;\n    }\n    add(key, value, index) {\n        if (typeof value === \"undefined\") {\n            return;\n        }\n        if (typeof value === \"number\") {\n            value = value.toString();\n        }\n        if (typeof value === \"string\") {\n            value = Buffer.from(value);\n        }\n        value = value.toString(\"binary\");\n        this.addFormatted(key, this.libmime.foldLines(key + \": \" + value.replace(/\\r?\\n/g, \"\"), 76, false), index);\n    }\n    addFormatted(key, line, index) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        index = index || 0;\n        this.changed = true;\n        if (!line) {\n            return;\n        }\n        if (typeof line !== \"string\") {\n            line = line.toString(\"binary\");\n        }\n        let header = {\n            key: this._normalizeHeader(key),\n            line\n        };\n        if (index < 1) {\n            this.lines.unshift(header);\n        } else if (index >= this.lines.length) {\n            this.lines.push(header);\n        } else {\n            this.lines.splice(index, 0, header);\n        }\n    }\n    remove(key) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        key = this._normalizeHeader(key);\n        for(let i = this.lines.length - 1; i >= 0; i--){\n            if (this.lines[i].key === key) {\n                this.changed = true;\n                this.lines.splice(i, 1);\n            }\n        }\n    }\n    update(key, value, relativeIndex) {\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        let keyName = key;\n        let index = 0;\n        key = this._normalizeHeader(key);\n        let relativeIndexCount = 0;\n        let relativeMatchFound = false;\n        for(let i = this.lines.length - 1; i >= 0; i--){\n            if (this.lines[i].key === key) {\n                if (relativeIndex && relativeIndex !== relativeIndexCount) {\n                    relativeIndexCount++;\n                    continue;\n                }\n                index = i;\n                this.changed = true;\n                this.lines.splice(i, 1);\n                if (relativeIndex) {\n                    relativeMatchFound = true;\n                    break;\n                }\n            }\n        }\n        if (relativeIndex && !relativeMatchFound) {\n            return;\n        }\n        this.add(keyName, value, index);\n    }\n    build(lineEnd) {\n        if (!this.changed && !lineEnd) {\n            return typeof this.headers === \"string\" ? Buffer.from(this.headers, \"binary\") : this.headers;\n        }\n        if (!this.parsed) {\n            this._parseHeaders();\n        }\n        lineEnd = lineEnd || \"\\r\\n\";\n        let headers = this.lines.map((line)=>line.line.replace(/\\r?\\n/g, lineEnd)).join(lineEnd) + `${lineEnd}${lineEnd}`;\n        if (this.mbox) {\n            headers = this.mbox + lineEnd + headers;\n        }\n        if (this.http) {\n            headers = this.http + lineEnd + headers;\n        }\n        return Buffer.from(headers, \"binary\");\n    }\n    _normalizeHeader(key) {\n        return (key || \"\").toLowerCase().trim();\n    }\n    _parseHeaders() {\n        if (!this.headers) {\n            this.lines = [];\n            this.parsed = true;\n            return;\n        }\n        let lines = this.headers.toString(\"binary\").replace(/[\\r\\n]+$/, \"\").split(/\\r?\\n/);\n        for(let i = lines.length - 1; i >= 0; i--){\n            let chr = lines[i].charAt(0);\n            if (i && (chr === \" \" || chr === \"\t\")) {\n                lines[i - 1] += \"\\r\\n\" + lines[i];\n                lines.splice(i, 1);\n            } else {\n                let line = lines[i];\n                if (!i && /^From /i.test(line)) {\n                    // mbox file\n                    this.mbox = line;\n                    lines.splice(i, 1);\n                    continue;\n                } else if (!i && /^POST /i.test(line)) {\n                    // HTTP POST request\n                    this.http = line;\n                    lines.splice(i, 1);\n                    continue;\n                }\n                let key = this._normalizeHeader(line.substr(0, line.indexOf(\":\")));\n                lines[i] = {\n                    key,\n                    line\n                };\n            }\n        }\n        this.lines = lines;\n        this.parsed = true;\n    }\n}\n// expose to the world\nmodule.exports = Headers;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFeEI7OztDQUdDLEdBQ0QsTUFBTUM7SUFDRkMsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDekJBLFNBQVNBLFVBQVUsQ0FBQztRQUVwQixJQUFJQyxNQUFNQyxPQUFPLENBQUNILFVBQVU7WUFDeEIsK0JBQStCO1lBQy9CLElBQUksQ0FBQ0ksT0FBTyxHQUFHO1lBQ2YsSUFBSSxDQUFDSixPQUFPLEdBQUc7WUFDZixJQUFJLENBQUNLLE1BQU0sR0FBRztZQUNkLElBQUksQ0FBQ0MsS0FBSyxHQUFHTjtRQUNqQixPQUFPO1lBQ0gsdUNBQXVDO1lBQ3ZDLElBQUksQ0FBQ0ksT0FBTyxHQUFHO1lBQ2YsSUFBSSxDQUFDSixPQUFPLEdBQUdBO1lBQ2YsSUFBSSxDQUFDSyxNQUFNLEdBQUc7WUFDZCxJQUFJLENBQUNDLEtBQUssR0FBRztRQUNqQjtRQUNBLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFFWixJQUFJLENBQUNaLE9BQU8sR0FBRyxJQUFJQSxRQUFRYSxPQUFPLENBQUM7WUFBRUMsT0FBT1QsT0FBT1MsS0FBSztRQUFDO0lBQzdEO0lBRUFDLFVBQVVDLEdBQUcsRUFBRTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUNQLE1BQU0sRUFBRTtZQUNkLElBQUksQ0FBQ1EsYUFBYTtRQUN0QjtRQUNBRCxNQUFNLElBQUksQ0FBQ0UsZ0JBQWdCLENBQUNGO1FBQzVCLE9BQU8sT0FBTyxJQUFJLENBQUNOLEtBQUssQ0FBQ1MsSUFBSSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLSixHQUFHLEtBQUtBLFNBQVM7SUFDaEU7SUFFQUssSUFBSUwsR0FBRyxFQUFFO1FBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQ1AsTUFBTSxFQUFFO1lBQ2QsSUFB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aWxzcGxpdC9saWIvaGVhZGVycy5qcz9kMDYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbGlibWltZSA9IHJlcXVpcmUoJ2xpYm1pbWUnKTtcblxuLyoqXG4gKiBDbGFzcyBIZWFkZXJzIHRvIHBhcnNlIGFuZCBoYW5kbGUgbWVzc2FnZSBoZWFkZXJzLiBIZWFkZXJzIGluc3RhbmNlIGFsbG93cyB0b1xuICogY2hlY2sgZXhpc3RpbmcsIGRlbGV0ZSBvciBhZGQgbmV3IGhlYWRlcnNcbiAqL1xuY2xhc3MgSGVhZGVycyB7XG4gICAgY29uc3RydWN0b3IoaGVhZGVycywgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSB1c2luZyBwYXJzZWQgaGVhZGVyc1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5saW5lcyA9IGhlYWRlcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2luZyBvcmlnaW5hbCBzdHJpbmcvYnVmZmVyIGhlYWRlcnNcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgICAgIHRoaXMucGFyc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmxpbmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYm94ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaHR0cCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMubGlibWltZSA9IG5ldyBsaWJtaW1lLkxpYm1pbWUoeyBJY29udjogY29uZmlnLkljb252IH0pO1xuICAgIH1cblxuICAgIGhhc0hlYWRlcihrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyKGtleSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5saW5lcy5maW5kKGxpbmUgPT4gbGluZS5rZXkgPT09IGtleSkgPT09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyKGtleSk7XG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMubGluZXMuZmlsdGVyKGxpbmUgPT4gbGluZS5rZXkgPT09IGtleSkubWFwKGxpbmUgPT4gbGluZS5saW5lKTtcblxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuXG4gICAgZ2V0RGVjb2RlZChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSlcbiAgICAgICAgICAgIC5tYXAobGluZSA9PiB0aGlzLmxpYm1pbWUuZGVjb2RlSGVhZGVyKGxpbmUpKVxuICAgICAgICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUgJiYgbGluZS52YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0Rmlyc3Qoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHRoaXMuX25vcm1hbGl6ZUhlYWRlcihrZXkpO1xuICAgICAgICBsZXQgaGVhZGVyID0gdGhpcy5saW5lcy5maW5kKGxpbmUgPT4gbGluZS5rZXkgPT09IGtleSk7XG4gICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgodGhpcy5saWJtaW1lLmRlY29kZUhlYWRlcihoZWFkZXIubGluZSkgfHwge30pLnZhbHVlIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBnZXRMaXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5saW5lcztcbiAgICB9XG5cbiAgICBhZGQoa2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgdGhpcy5hZGRGb3JtYXR0ZWQoa2V5LCB0aGlzLmxpYm1pbWUuZm9sZExpbmVzKGtleSArICc6ICcgKyB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKSwgNzYsIGZhbHNlKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdHRlZChrZXksIGxpbmUsIGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBoZWFkZXIgPSB7XG4gICAgICAgICAgICBrZXk6IHRoaXMuX25vcm1hbGl6ZUhlYWRlcihrZXkpLFxuICAgICAgICAgICAgbGluZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmRleCA8IDEpIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMudW5zaGlmdChoZWFkZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID49IHRoaXMubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLnB1c2goaGVhZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMuc3BsaWNlKGluZGV4LCAwLCBoZWFkZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBpZiAoIXRoaXMucGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSB0aGlzLl9ub3JtYWxpemVIZWFkZXIoa2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVzW2ldLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZShrZXksIHZhbHVlLCByZWxhdGl2ZUluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrZXlOYW1lID0ga2V5O1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBrZXkgPSB0aGlzLl9ub3JtYWxpemVIZWFkZXIoa2V5KTtcbiAgICAgICAgbGV0IHJlbGF0aXZlSW5kZXhDb3VudCA9IDA7XG4gICAgICAgIGxldCByZWxhdGl2ZU1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVzW2ldLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlSW5kZXggJiYgcmVsYXRpdmVJbmRleCAhPT0gcmVsYXRpdmVJbmRleENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlSW5kZXhDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVNYXRjaEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbGF0aXZlSW5kZXggJiYgIXJlbGF0aXZlTWF0Y2hGb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGQoa2V5TmFtZSwgdmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICBidWlsZChsaW5lRW5kKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGFuZ2VkICYmICFsaW5lRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuaGVhZGVycyA9PT0gJ3N0cmluZycgPyBCdWZmZXIuZnJvbSh0aGlzLmhlYWRlcnMsICdiaW5hcnknKSA6IHRoaXMuaGVhZGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXJzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluZUVuZCA9IGxpbmVFbmQgfHwgJ1xcclxcbic7XG5cbiAgICAgICAgbGV0IGhlYWRlcnMgPSB0aGlzLmxpbmVzLm1hcChsaW5lID0+IGxpbmUubGluZS5yZXBsYWNlKC9cXHI/XFxuL2csIGxpbmVFbmQpKS5qb2luKGxpbmVFbmQpICsgYCR7bGluZUVuZH0ke2xpbmVFbmR9YDtcblxuICAgICAgICBpZiAodGhpcy5tYm94KSB7XG4gICAgICAgICAgICBoZWFkZXJzID0gdGhpcy5tYm94ICsgbGluZUVuZCArIGhlYWRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5odHRwKSB7XG4gICAgICAgICAgICBoZWFkZXJzID0gdGhpcy5odHRwICsgbGluZUVuZCArIGhlYWRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oaGVhZGVycywgJ2JpbmFyeScpO1xuICAgIH1cblxuICAgIF9ub3JtYWxpemVIZWFkZXIoa2V5KSB7XG4gICAgICAgIHJldHVybiAoa2V5IHx8ICcnKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBfcGFyc2VIZWFkZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpbmVzID0gdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAudG9TdHJpbmcoJ2JpbmFyeScpXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcclxcbl0rJC8sICcnKVxuICAgICAgICAgICAgLnNwbGl0KC9cXHI/XFxuLyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hyID0gbGluZXNbaV0uY2hhckF0KDApO1xuICAgICAgICAgICAgaWYgKGkgJiYgKGNociA9PT0gJyAnIHx8IGNociA9PT0gJ1xcdCcpKSB7XG4gICAgICAgICAgICAgICAgbGluZXNbaSAtIDFdICs9ICdcXHJcXG4nICsgbGluZXNbaV07XG4gICAgICAgICAgICAgICAgbGluZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghaSAmJiAvXkZyb20gL2kudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYm94IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYm94ID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpICYmIC9eUE9TVCAvaS50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhUVFAgUE9TVCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cCA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLl9ub3JtYWxpemVIZWFkZXIobGluZS5zdWJzdHIoMCwgbGluZS5pbmRleE9mKCc6JykpKTtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBsaW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5wYXJzZWQgPSB0cnVlO1xuICAgIH1cbn1cblxuLy8gZXhwb3NlIHRvIHRoZSB3b3JsZFxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJzO1xuIl0sIm5hbWVzIjpbImxpYm1pbWUiLCJyZXF1aXJlIiwiSGVhZGVycyIsImNvbnN0cnVjdG9yIiwiaGVhZGVycyIsImNvbmZpZyIsIkFycmF5IiwiaXNBcnJheSIsImNoYW5nZWQiLCJwYXJzZWQiLCJsaW5lcyIsIm1ib3giLCJodHRwIiwiTGlibWltZSIsIkljb252IiwiaGFzSGVhZGVyIiwia2V5IiwiX3BhcnNlSGVhZGVycyIsIl9ub3JtYWxpemVIZWFkZXIiLCJmaW5kIiwibGluZSIsImdldCIsImZpbHRlciIsIm1hcCIsImdldERlY29kZWQiLCJkZWNvZGVIZWFkZXIiLCJ2YWx1ZSIsImdldEZpcnN0IiwiaGVhZGVyIiwidG9TdHJpbmciLCJ0cmltIiwiZ2V0TGlzdCIsImFkZCIsImluZGV4IiwiQnVmZmVyIiwiZnJvbSIsImFkZEZvcm1hdHRlZCIsImZvbGRMaW5lcyIsInJlcGxhY2UiLCJ1bnNoaWZ0IiwibGVuZ3RoIiwicHVzaCIsInNwbGljZSIsInJlbW92ZSIsImkiLCJ1cGRhdGUiLCJyZWxhdGl2ZUluZGV4Iiwia2V5TmFtZSIsInJlbGF0aXZlSW5kZXhDb3VudCIsInJlbGF0aXZlTWF0Y2hGb3VuZCIsImJ1aWxkIiwibGluZUVuZCIsImpvaW4iLCJ0b0xvd2VyQ2FzZSIsInNwbGl0IiwiY2hyIiwiY2hhckF0IiwidGVzdCIsInN1YnN0ciIsImluZGV4T2YiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-joiner.js":
/*!***************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/message-joiner.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nclass MessageJoiner extends Transform {\n    constructor(){\n        let options = {\n            readableObjectMode: false,\n            writableObjectMode: true\n        };\n        super(options);\n    }\n    _transform(obj, encoding, callback) {\n        if (Buffer.isBuffer(obj)) {\n            this.push(obj);\n        } else if (obj.type === \"node\") {\n            this.push(obj.getHeaders());\n        } else if (obj.value) {\n            this.push(obj.value);\n        }\n        return callback();\n    }\n    _flush(callback) {\n        return callback();\n    }\n}\nmodule.exports = MessageJoiner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9tZXNzYWdlLWpvaW5lci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFlBQVlDLHVEQUEyQjtBQUU3QyxNQUFNQyxzQkFBc0JGO0lBQ3hCRyxhQUFjO1FBQ1YsSUFBSUMsVUFBVTtZQUNWQyxvQkFBb0I7WUFDcEJDLG9CQUFvQjtRQUN4QjtRQUNBLEtBQUssQ0FBQ0Y7SUFDVjtJQUVBRyxXQUFXQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFO1FBQ2hDLElBQUlDLE9BQU9DLFFBQVEsQ0FBQ0osTUFBTTtZQUN0QixJQUFJLENBQUNLLElBQUksQ0FBQ0w7UUFDZCxPQUFPLElBQUlBLElBQUlNLElBQUksS0FBSyxRQUFRO1lBQzVCLElBQUksQ0FBQ0QsSUFBSSxDQUFDTCxJQUFJTyxVQUFVO1FBQzVCLE9BQU8sSUFBSVAsSUFBSVEsS0FBSyxFQUFFO1lBQ2xCLElBQUksQ0FBQ0gsSUFBSSxDQUFDTCxJQUFJUSxLQUFLO1FBQ3ZCO1FBQ0EsT0FBT047SUFDWDtJQUVBTyxPQUFPUCxRQUFRLEVBQUU7UUFDYixPQUFPQTtJQUNYO0FBQ0o7QUFFQVEsT0FBT0MsT0FBTyxHQUFHakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BU1dEIENsaWVudCBIdWIvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9tZXNzYWdlLWpvaW5lci5qcz84YmRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSgnc3RyZWFtJykuVHJhbnNmb3JtO1xuXG5jbGFzcyBNZXNzYWdlSm9pbmVyIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZWFkYWJsZU9iamVjdE1vZGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0ob2JqLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gob2JqKTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoudHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gob2JqLmdldEhlYWRlcnMoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2gob2JqLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VKb2luZXI7XG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtIiwicmVxdWlyZSIsIk1lc3NhZ2VKb2luZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJfdHJhbnNmb3JtIiwib2JqIiwiZW5jb2RpbmciLCJjYWxsYmFjayIsIkJ1ZmZlciIsImlzQnVmZmVyIiwicHVzaCIsInR5cGUiLCJnZXRIZWFkZXJzIiwidmFsdWUiLCJfZmx1c2giLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-joiner.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-splitter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/message-splitter.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst MimeNode = __webpack_require__(/*! ./mime-node */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/mime-node.js\");\nconst MAX_HEAD_SIZE = 1 * 1024 * 1024;\nconst MAX_CHILD_NODES = 1000;\nconst HEAD = 0x01;\nconst BODY = 0x02;\nclass MessageSplitter extends Transform {\n    constructor(config){\n        let options = {\n            readableObjectMode: true,\n            writableObjectMode: false\n        };\n        super(options);\n        this.config = config || {};\n        this.maxHeadSize = this.config.maxHeadSize || MAX_HEAD_SIZE;\n        this.maxChildNodes = this.config.maxChildNodes || MAX_CHILD_NODES;\n        this.tree = [];\n        this.nodeCounter = 0;\n        this.newNode();\n        this.tree.push(this.node);\n        this.line = false;\n        this.hasFailed = false;\n    }\n    _transform(chunk, encoding, callback) {\n        // process line by line\n        // find next line ending\n        let pos = 0;\n        let i = 0;\n        let group = {\n            type: \"none\"\n        };\n        let groupstart = this.line ? -this.line.length : 0;\n        let groupend = 0;\n        let checkTrailingLinebreak = (data)=>{\n            if (data.type === \"body\" && data.node.parentNode && data.value && data.value.length) {\n                if (data.value[data.value.length - 1] === 0x0a) {\n                    groupstart--;\n                    groupend--;\n                    pos--;\n                    if (data.value.length > 1 && data.value[data.value.length - 2] === 0x0d) {\n                        groupstart--;\n                        groupend--;\n                        pos--;\n                        if (groupstart < 0 && !this.line) {\n                            // store only <CR> as <LF> should be on the positive side\n                            this.line = Buffer.allocUnsafe(1);\n                            this.line[0] = 0x0d;\n                        }\n                        data.value = data.value.slice(0, data.value.length - 2);\n                    } else {\n                        data.value = data.value.slice(0, data.value.length - 1);\n                    }\n                } else if (data.value[data.value.length - 1] === 0x0d) {\n                    groupstart--;\n                    groupend--;\n                    pos--;\n                    data.value = data.value.slice(0, data.value.length - 1);\n                }\n            }\n        };\n        let iterateData = ()=>{\n            for(let len = chunk.length; i < len; i++){\n                // find next <LF>\n                if (chunk[i] === 0x0a) {\n                    // line end\n                    let start = Math.max(pos, 0);\n                    pos = ++i;\n                    return this.processLine(chunk.slice(start, i), false, (err, data, flush)=>{\n                        if (err) {\n                            this.hasFailed = true;\n                            return setImmediate(()=>callback(err));\n                        }\n                        if (!data) {\n                            return setImmediate(iterateData);\n                        }\n                        if (flush) {\n                            if (group && group.type !== \"none\") {\n                                if (group.type === \"body\" && groupend >= groupstart && group.node.parentNode) {\n                                    // do not include the last line ending for body\n                                    if (chunk[groupend - 1] === 0x0a) {\n                                        groupend--;\n                                        if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                                            groupend--;\n                                        }\n                                    }\n                                }\n                                if (groupstart !== groupend) {\n                                    group.value = chunk.slice(groupstart, groupend);\n                                    if (groupend < i) {\n                                        data.value = chunk.slice(groupend, i);\n                                    }\n                                }\n                                this.push(group);\n                                group = {\n                                    type: \"none\"\n                                };\n                                groupstart = groupend = i;\n                            }\n                            this.push(data);\n                            groupend = i;\n                            return setImmediate(iterateData);\n                        }\n                        if (data.type === group.type) {\n                            // shift slice end position forward\n                            groupend = i;\n                        } else {\n                            if (group.type === \"body\" && groupend >= groupstart && group.node.parentNode) {\n                                // do not include the last line ending for body\n                                if (chunk[groupend - 1] === 0x0a) {\n                                    groupend--;\n                                    if (groupend >= groupstart && chunk[groupend - 1] === 0x0d) {\n                                        groupend--;\n                                    }\n                                }\n                            }\n                            if (group.type !== \"none\" && group.type !== \"node\") {\n                                // we have a previous data/body chunk to output\n                                if (groupstart !== groupend) {\n                                    group.value = chunk.slice(groupstart, groupend);\n                                    if (group.value && group.value.length) {\n                                        this.push(group);\n                                        group = {\n                                            type: \"none\"\n                                        };\n                                    }\n                                }\n                            }\n                            if (data.type === \"node\") {\n                                this.push(data);\n                                groupstart = i;\n                                groupend = i;\n                            } else if (groupstart < 0) {\n                                groupstart = i;\n                                groupend = i;\n                                checkTrailingLinebreak(data);\n                                if (data.value && data.value.length) {\n                                    this.push(data);\n                                }\n                            } else {\n                                // start new body/data chunk\n                                group = data;\n                                groupstart = groupend;\n                                groupend = i;\n                            }\n                        }\n                        return setImmediate(iterateData);\n                    });\n                }\n            }\n            // skip last linebreak for body\n            if (pos >= groupstart + 1 && group.type === \"body\" && group.node.parentNode) {\n                // do not include the last line ending for body\n                if (chunk[pos - 1] === 0x0a) {\n                    pos--;\n                    if (pos >= groupstart && chunk[pos - 1] === 0x0d) {\n                        pos--;\n                    }\n                }\n            }\n            if (group.type !== \"none\" && group.type !== \"node\" && pos > groupstart) {\n                // we have a leftover data/body chunk to push out\n                group.value = chunk.slice(groupstart, pos);\n                if (group.value && group.value.length) {\n                    this.push(group);\n                    group = {\n                        type: \"none\"\n                    };\n                }\n            }\n            if (pos < chunk.length) {\n                if (this.line) {\n                    this.line = Buffer.concat([\n                        this.line,\n                        chunk.slice(pos)\n                    ]);\n                } else {\n                    this.line = chunk.slice(pos);\n                }\n            }\n            callback();\n        };\n        setImmediate(iterateData);\n    }\n    _flush(callback) {\n        if (this.hasFailed) {\n            return callback();\n        }\n        this.processLine(false, true, (err, data)=>{\n            if (err) {\n                return setImmediate(()=>callback(err));\n            }\n            if (data && (data.type === \"node\" || data.value && data.value.length)) {\n                this.push(data);\n            }\n            callback();\n        });\n    }\n    compareBoundary(line, startpos, boundary) {\n        // --{boundary}\\r\\n or --{boundary}--\\r\\n\n        if (line.length < boundary.length + 3 + startpos || line.length > boundary.length + 6 + startpos) {\n            return false;\n        }\n        for(let i = 0; i < boundary.length; i++){\n            if (line[i + 2 + startpos] !== boundary[i]) {\n                return false;\n            }\n        }\n        let pos = 0;\n        for(let i = boundary.length + 2 + startpos; i < line.length; i++){\n            let c = line[i];\n            if (pos === 0 && (c === 0x0d || c === 0x0a)) {\n                // 1: next node\n                return 1;\n            }\n            if (pos === 0 && c !== 0x2d) {\n                // expecting \"-\"\n                return false;\n            }\n            if (pos === 1 && c !== 0x2d) {\n                // expecting \"-\"\n                return false;\n            }\n            if (pos === 2 && c !== 0x0d && c !== 0x0a) {\n                // expecting line terminator, either <CR> or <LF>\n                return false;\n            }\n            if (pos === 3 && c !== 0x0a) {\n                // expecting line terminator <LF>\n                return false;\n            }\n            pos++;\n        }\n        // 2: multipart end\n        return 2;\n    }\n    checkBoundary(line) {\n        let startpos = 0;\n        if (line.length >= 1 && (line[0] === 0x0d || line[0] === 0x0a)) {\n            startpos++;\n            if (line.length >= 2 && (line[0] === 0x0d || line[1] === 0x0a)) {\n                startpos++;\n            }\n        }\n        if (line.length < 4 || line[startpos] !== 0x2d || line[startpos + 1] !== 0x2d) {\n            // defnitely not a boundary\n            return false;\n        }\n        let boundary;\n        if (this.node._boundary && (boundary = this.compareBoundary(line, startpos, this.node._boundary))) {\n            // 1: next child\n            // 2: multipart end\n            return boundary;\n        }\n        if (this.node._parentBoundary && (boundary = this.compareBoundary(line, startpos, this.node._parentBoundary))) {\n            // 3: next sibling\n            // 4: parent end\n            return boundary + 2;\n        }\n        return false;\n    }\n    processLine(line, final, next) {\n        let flush = false;\n        if (this.line && line) {\n            line = Buffer.concat([\n                this.line,\n                line\n            ]);\n            this.line = false;\n        } else if (this.line && !line) {\n            line = this.line;\n            this.line = false;\n        }\n        if (!line) {\n            line = Buffer.alloc(0);\n        }\n        if (this.nodeCounter > this.maxChildNodes) {\n            let err = new Error(\"Max allowed child nodes exceeded\");\n            err.code = \"EMAXLEN\";\n            return next(err);\n        }\n        // we check boundary outside the HEAD/BODY scope as it may appear anywhere\n        let boundary = this.checkBoundary(line);\n        if (boundary) {\n            // reached boundary, switch context\n            switch(boundary){\n                case 1:\n                    // next child\n                    this.newNode(this.node);\n                    flush = true;\n                    break;\n                case 2:\n                    break;\n                case 3:\n                    {\n                        // next sibling\n                        let parentNode = this.node.parentNode;\n                        if (parentNode && parentNode.contentType === \"message/rfc822\") {\n                            // special case where immediate parent is an inline message block\n                            // move up another step\n                            parentNode = parentNode.parentNode;\n                        }\n                        this.newNode(parentNode);\n                        flush = true;\n                        break;\n                    }\n                case 4:\n                    // special case when boundary close a node with only header.\n                    if (this.node && this.node._headerlen && !this.node.headers) {\n                        this.node.parseHeaders();\n                        this.push(this.node);\n                    }\n                    // move up\n                    if (this.tree.length) {\n                        this.node = this.tree.pop();\n                    }\n                    this.state = BODY;\n                    break;\n            }\n            return next(null, {\n                node: this.node,\n                type: \"data\",\n                value: line\n            }, flush);\n        }\n        switch(this.state){\n            case HEAD:\n                {\n                    this.node.addHeaderChunk(line);\n                    if (this.node._headerlen > this.maxHeadSize) {\n                        let err = new Error(\"Max header size for a MIME node exceeded\");\n                        err.code = \"EMAXLEN\";\n                        return next(err);\n                    }\n                    if (final || line.length === 1 && line[0] === 0x0a || line.length === 2 && line[0] === 0x0d && line[1] === 0x0a) {\n                        let currentNode = this.node;\n                        currentNode.parseHeaders();\n                        // if the content is attached message then just continue\n                        if (currentNode.contentType === \"message/rfc822\" && !this.config.ignoreEmbedded && (!currentNode.encoding || [\n                            \"7bit\",\n                            \"8bit\",\n                            \"binary\"\n                        ].includes(currentNode.encoding)) && (this.config.defaultInlineEmbedded ? currentNode.disposition !== \"attachment\" : currentNode.disposition === \"inline\")) {\n                            currentNode.messageNode = true;\n                            this.newNode(currentNode);\n                            if (currentNode.parentNode) {\n                                this.node._parentBoundary = currentNode.parentNode._boundary;\n                            }\n                        } else {\n                            if (currentNode.contentType === \"message/rfc822\") {\n                                currentNode.messageNode = false;\n                            }\n                            this.state = BODY;\n                            if (currentNode.multipart && currentNode._boundary) {\n                                this.tree.push(currentNode);\n                            }\n                        }\n                        return next(null, currentNode, flush);\n                    }\n                    return next();\n                }\n            case BODY:\n                {\n                    return next(null, {\n                        node: this.node,\n                        type: this.node.multipart ? \"data\" : \"body\",\n                        value: line\n                    }, flush);\n                }\n        }\n        next(null, false);\n    }\n    newNode(parent) {\n        this.node = new MimeNode(parent || false, this.config);\n        this.state = HEAD;\n        this.nodeCounter++;\n    }\n}\nmodule.exports = MessageSplitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9tZXNzYWdlLXNwbGl0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsWUFBWUMsdURBQTJCO0FBQzdDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDO0FBRXpCLE1BQU1FLGdCQUFnQixJQUFJLE9BQU87QUFDakMsTUFBTUMsa0JBQWtCO0FBRXhCLE1BQU1DLE9BQU87QUFDYixNQUFNQyxPQUFPO0FBRWIsTUFBTUMsd0JBQXdCUDtJQUMxQlEsWUFBWUMsTUFBTSxDQUFFO1FBQ2hCLElBQUlDLFVBQVU7WUFDVkMsb0JBQW9CO1lBQ3BCQyxvQkFBb0I7UUFDeEI7UUFDQSxLQUFLLENBQUNGO1FBRU4sSUFBSSxDQUFDRCxNQUFNLEdBQUdBLFVBQVUsQ0FBQztRQUN6QixJQUFJLENBQUNJLFdBQVcsR0FBRyxJQUFJLENBQUNKLE1BQU0sQ0FBQ0ksV0FBVyxJQUFJVjtRQUM5QyxJQUFJLENBQUNXLGFBQWEsR0FBRyxJQUFJLENBQUNMLE1BQU0sQ0FBQ0ssYUFBYSxJQUFJVjtRQUNsRCxJQUFJLENBQUNXLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxPQUFPO1FBQ1osSUFBSSxDQUFDRixJQUFJLENBQUNHLElBQUksQ0FBQyxJQUFJLENBQUNDLElBQUk7UUFDeEIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFNBQVMsR0FBRztJQUNyQjtJQUVBQyxXQUFXQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUSxFQUFFO1FBQ2xDLHVCQUF1QjtRQUN2Qix3QkFBd0I7UUFDeEIsSUFBSUMsTUFBTTtRQUNWLElBQUlDLElBQUk7UUFDUixJQUFJQyxRQUFRO1lBQ1JDLE1BQU07UUFDVjtRQUNBLElBQUlDLGFBQWEsSUFBSSxDQUFDVixJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUNBLElBQUksQ0FBQ1csTUFBTSxH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QUFJLENBQUNBLElBQUk7d0JBQ2ZVLE1BQU0sSUFBSSxDQUFDVixJQUFJLENBQUN5RCxTQUFTLEdBQUcsU0FBUzt3QkFDckN4QyxPQUFPaEI7b0JBQ1gsR0FDQTJCO2dCQUVSO1FBQ0o7UUFFQVksS0FBSyxNQUFNO0lBQ2Y7SUFFQTFDLFFBQVE0RCxNQUFNLEVBQUU7UUFDWixJQUFJLENBQUMxRCxJQUFJLEdBQUcsSUFBSWpCLFNBQVMyRSxVQUFVLE9BQU8sSUFBSSxDQUFDcEUsTUFBTTtRQUNyRCxJQUFJLENBQUMyRCxLQUFLLEdBQUcvRDtRQUNiLElBQUksQ0FBQ1csV0FBVztJQUNwQjtBQUNKO0FBRUE4RCxPQUFPQyxPQUFPLEdBQUd4RSIsInNvdXJjZXMiOlsid2VicGFjazovL0FTV0QgQ2xpZW50IEh1Yi8uL25vZGVfbW9kdWxlcy9Aem9uZS1ldS9tYWlsc3BsaXQvbGliL21lc3NhZ2Utc3BsaXR0ZXIuanM/MWZkNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbmNvbnN0IE1pbWVOb2RlID0gcmVxdWlyZSgnLi9taW1lLW5vZGUnKTtcblxuY29uc3QgTUFYX0hFQURfU0laRSA9IDEgKiAxMDI0ICogMTAyNDtcbmNvbnN0IE1BWF9DSElMRF9OT0RFUyA9IDEwMDA7XG5cbmNvbnN0IEhFQUQgPSAweDAxO1xuY29uc3QgQk9EWSA9IDB4MDI7XG5cbmNsYXNzIE1lc3NhZ2VTcGxpdHRlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgdGhpcy5tYXhIZWFkU2l6ZSA9IHRoaXMuY29uZmlnLm1heEhlYWRTaXplIHx8IE1BWF9IRUFEX1NJWkU7XG4gICAgICAgIHRoaXMubWF4Q2hpbGROb2RlcyA9IHRoaXMuY29uZmlnLm1heENoaWxkTm9kZXMgfHwgTUFYX0NISUxEX05PREVTO1xuICAgICAgICB0aGlzLnRyZWUgPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMubmV3Tm9kZSgpO1xuICAgICAgICB0aGlzLnRyZWUucHVzaCh0aGlzLm5vZGUpO1xuICAgICAgICB0aGlzLmxpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJvY2VzcyBsaW5lIGJ5IGxpbmVcbiAgICAgICAgLy8gZmluZCBuZXh0IGxpbmUgZW5kaW5nXG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBncm91cCA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdub25lJ1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZ3JvdXBzdGFydCA9IHRoaXMubGluZSA/IC10aGlzLmxpbmUubGVuZ3RoIDogMDtcbiAgICAgICAgbGV0IGdyb3VwZW5kID0gMDtcblxuICAgICAgICBsZXQgY2hlY2tUcmFpbGluZ0xpbmVicmVhayA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2JvZHknICYmIGRhdGEubm9kZS5wYXJlbnROb2RlICYmIGRhdGEudmFsdWUgJiYgZGF0YS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS52YWx1ZVtkYXRhLnZhbHVlLmxlbmd0aCAtIDFdID09PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc3RhcnQtLTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnZhbHVlLmxlbmd0aCA+IDEgJiYgZGF0YS52YWx1ZVtkYXRhLnZhbHVlLmxlbmd0aCAtIDJdID09PSAweDBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHN0YXJ0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzdGFydCA8IDAgJiYgIXRoaXMubGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIG9ubHkgPENSPiBhcyA8TEY+IHNob3VsZCBiZSBvbiB0aGUgcG9zaXRpdmUgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGluZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVbMF0gPSAweDBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IGRhdGEudmFsdWUuc2xpY2UoMCwgZGF0YS52YWx1ZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBkYXRhLnZhbHVlLnNsaWNlKDAsIGRhdGEudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEudmFsdWVbZGF0YS52YWx1ZS5sZW5ndGggLSAxXSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHN0YXJ0LS07XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kLS07XG4gICAgICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gZGF0YS52YWx1ZS5zbGljZSgwLCBkYXRhLnZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgaXRlcmF0ZURhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBsZW4gPSBjaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgbmV4dCA8TEY+XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rW2ldID09PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpbmUgZW5kXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gKytpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NMaW5lKGNodW5rLnNsaWNlKHN0YXJ0LCBpKSwgZmFsc2UsIChlcnIsIGRhdGEsIGZsdXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNGYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoaXRlcmF0ZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgJiYgZ3JvdXAudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cC50eXBlID09PSAnYm9keScgJiYgZ3JvdXBlbmQgPj0gZ3JvdXBzdGFydCAmJiBncm91cC5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBpbmNsdWRlIHRoZSBsYXN0IGxpbmUgZW5kaW5nIGZvciBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtbZ3JvdXBlbmQgLSAxXSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZW5kID49IGdyb3Vwc3RhcnQgJiYgY2h1bmtbZ3JvdXBlbmQgLSAxXSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzdGFydCAhPT0gZ3JvdXBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnZhbHVlID0gY2h1bmsuc2xpY2UoZ3JvdXBzdGFydCwgZ3JvdXBlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZW5kIDwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBjaHVuay5zbGljZShncm91cGVuZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzdGFydCA9IGdyb3VwZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGl0ZXJhdGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gZ3JvdXAudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNoaWZ0IHNsaWNlIGVuZCBwb3NpdGlvbiBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudHlwZSA9PT0gJ2JvZHknICYmIGdyb3VwZW5kID49IGdyb3Vwc3RhcnQgJiYgZ3JvdXAubm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBpbmNsdWRlIHRoZSBsYXN0IGxpbmUgZW5kaW5nIGZvciBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua1tncm91cGVuZCAtIDFdID09PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cGVuZC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZW5kID49IGdyb3Vwc3RhcnQgJiYgY2h1bmtbZ3JvdXBlbmQgLSAxXSA9PT0gMHgwZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudHlwZSAhPT0gJ25vbmUnICYmIGdyb3VwLnR5cGUgIT09ICdub2RlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldmlvdXMgZGF0YS9ib2R5IGNodW5rIHRvIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBzdGFydCAhPT0gZ3JvdXBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnZhbHVlID0gY2h1bmsuc2xpY2UoZ3JvdXBzdGFydCwgZ3JvdXBlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLnZhbHVlICYmIGdyb3VwLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUcmFpbGluZ0xpbmVicmVhayhkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudmFsdWUgJiYgZGF0YS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5ldyBib2R5L2RhdGEgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHN0YXJ0ID0gZ3JvdXBlbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKGl0ZXJhdGVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBza2lwIGxhc3QgbGluZWJyZWFrIGZvciBib2R5XG4gICAgICAgICAgICBpZiAocG9zID49IGdyb3Vwc3RhcnQgKyAxICYmIGdyb3VwLnR5cGUgPT09ICdib2R5JyAmJiBncm91cC5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgaW5jbHVkZSB0aGUgbGFzdCBsaW5lIGVuZGluZyBmb3IgYm9keVxuICAgICAgICAgICAgICAgIGlmIChjaHVua1twb3MgLSAxXSA9PT0gMHgwYSkge1xuICAgICAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBncm91cHN0YXJ0ICYmIGNodW5rW3BvcyAtIDFdID09PSAweDBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdyb3VwLnR5cGUgIT09ICdub25lJyAmJiBncm91cC50eXBlICE9PSAnbm9kZScgJiYgcG9zID4gZ3JvdXBzdGFydCkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSBsZWZ0b3ZlciBkYXRhL2JvZHkgY2h1bmsgdG8gcHVzaCBvdXRcbiAgICAgICAgICAgICAgICBncm91cC52YWx1ZSA9IGNodW5rLnNsaWNlKGdyb3Vwc3RhcnQsIHBvcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudmFsdWUgJiYgZ3JvdXAudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChncm91cCk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ25vbmUnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmxpbmUsIGNodW5rLnNsaWNlKHBvcyldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmUgPSBjaHVuay5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKGl0ZXJhdGVEYXRhKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRmFpbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NMaW5lKGZhbHNlLCB0cnVlLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhlcnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhICYmIChkYXRhLnR5cGUgPT09ICdub2RlJyB8fCAoZGF0YS52YWx1ZSAmJiBkYXRhLnZhbHVlLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tcGFyZUJvdW5kYXJ5KGxpbmUsIHN0YXJ0cG9zLCBib3VuZGFyeSkge1xuICAgICAgICAvLyAtLXtib3VuZGFyeX1cXHJcXG4gb3IgLS17Ym91bmRhcnl9LS1cXHJcXG5cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgYm91bmRhcnkubGVuZ3RoICsgMyArIHN0YXJ0cG9zIHx8IGxpbmUubGVuZ3RoID4gYm91bmRhcnkubGVuZ3RoICsgNiArIHN0YXJ0cG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaSArIDIgKyBzdGFydHBvc10gIT09IGJvdW5kYXJ5W2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBib3VuZGFyeS5sZW5ndGggKyAyICsgc3RhcnRwb3M7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IGxpbmVbaV07XG4gICAgICAgICAgICBpZiAocG9zID09PSAwICYmIChjID09PSAweDBkIHx8IGMgPT09IDB4MGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gMTogbmV4dCBub2RlXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID09PSAwICYmIGMgIT09IDB4MmQpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBlY3RpbmcgXCItXCJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID09PSAxICYmIGMgIT09IDB4MmQpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBlY3RpbmcgXCItXCJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID09PSAyICYmIGMgIT09IDB4MGQgJiYgYyAhPT0gMHgwYSkge1xuICAgICAgICAgICAgICAgIC8vIGV4cGVjdGluZyBsaW5lIHRlcm1pbmF0b3IsIGVpdGhlciA8Q1I+IG9yIDxMRj5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID09PSAzICYmIGMgIT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICAvLyBleHBlY3RpbmcgbGluZSB0ZXJtaW5hdG9yIDxMRj5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDI6IG11bHRpcGFydCBlbmRcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgY2hlY2tCb3VuZGFyeShsaW5lKSB7XG4gICAgICAgIGxldCBzdGFydHBvcyA9IDA7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+PSAxICYmIChsaW5lWzBdID09PSAweDBkIHx8IGxpbmVbMF0gPT09IDB4MGEpKSB7XG4gICAgICAgICAgICBzdGFydHBvcysrO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID49IDIgJiYgKGxpbmVbMF0gPT09IDB4MGQgfHwgbGluZVsxXSA9PT0gMHgwYSkpIHtcbiAgICAgICAgICAgICAgICBzdGFydHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IDQgfHwgbGluZVtzdGFydHBvc10gIT09IDB4MmQgfHwgbGluZVtzdGFydHBvcyArIDFdICE9PSAweDJkKSB7XG4gICAgICAgICAgICAvLyBkZWZuaXRlbHkgbm90IGEgYm91bmRhcnlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBib3VuZGFyeTtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5fYm91bmRhcnkgJiYgKGJvdW5kYXJ5ID0gdGhpcy5jb21wYXJlQm91bmRhcnkobGluZSwgc3RhcnRwb3MsIHRoaXMubm9kZS5fYm91bmRhcnkpKSkge1xuICAgICAgICAgICAgLy8gMTogbmV4dCBjaGlsZFxuICAgICAgICAgICAgLy8gMjogbXVsdGlwYXJ0IGVuZFxuICAgICAgICAgICAgcmV0dXJuIGJvdW5kYXJ5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubm9kZS5fcGFyZW50Qm91bmRhcnkgJiYgKGJvdW5kYXJ5ID0gdGhpcy5jb21wYXJlQm91bmRhcnkobGluZSwgc3RhcnRwb3MsIHRoaXMubm9kZS5fcGFyZW50Qm91bmRhcnkpKSkge1xuICAgICAgICAgICAgLy8gMzogbmV4dCBzaWJsaW5nXG4gICAgICAgICAgICAvLyA0OiBwYXJlbnQgZW5kXG4gICAgICAgICAgICByZXR1cm4gYm91bmRhcnkgKyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByb2Nlc3NMaW5lKGxpbmUsIGZpbmFsLCBuZXh0KSB7XG4gICAgICAgIGxldCBmbHVzaCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmxpbmUgJiYgbGluZSkge1xuICAgICAgICAgICAgbGluZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMubGluZSwgbGluZV0pO1xuICAgICAgICAgICAgdGhpcy5saW5lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5saW5lICYmICFsaW5lKSB7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5saW5lO1xuICAgICAgICAgICAgdGhpcy5saW5lID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxpbmUpIHtcbiAgICAgICAgICAgIGxpbmUgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ub2RlQ291bnRlciA+IHRoaXMubWF4Q2hpbGROb2Rlcykge1xuICAgICAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcignTWF4IGFsbG93ZWQgY2hpbGQgbm9kZXMgZXhjZWVkZWQnKTtcbiAgICAgICAgICAgIGVyci5jb2RlID0gJ0VNQVhMRU4nO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIGNoZWNrIGJvdW5kYXJ5IG91dHNpZGUgdGhlIEhFQUQvQk9EWSBzY29wZSBhcyBpdCBtYXkgYXBwZWFyIGFueXdoZXJlXG4gICAgICAgIGxldCBib3VuZGFyeSA9IHRoaXMuY2hlY2tCb3VuZGFyeShsaW5lKTtcbiAgICAgICAgaWYgKGJvdW5kYXJ5KSB7XG4gICAgICAgICAgICAvLyByZWFjaGVkIGJvdW5kYXJ5LCBzd2l0Y2ggY29udGV4dFxuICAgICAgICAgICAgc3dpdGNoIChib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld05vZGUodGhpcy5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZmx1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgZW5kIG9mIGNoaWxkcmVuLCBrZWVwIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBzaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtZXNzYWdlL3JmYzgyMicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSB3aGVyZSBpbW1lZGlhdGUgcGFyZW50IGlzIGFuIGlubGluZSBtZXNzYWdlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHVwIGFub3RoZXIgc3RlcFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld05vZGUocGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHdoZW4gYm91bmRhcnkgY2xvc2UgYSBub2RlIHdpdGggb25seSBoZWFkZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGUgJiYgdGhpcy5ub2RlLl9oZWFkZXJsZW4gJiYgIXRoaXMubm9kZS5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUucGFyc2VIZWFkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHVwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyZWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUgPSB0aGlzLnRyZWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEJPRFk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV4dChcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGF0YScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsaW5lXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmbHVzaFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBIRUFEOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFkZEhlYWRlckNodW5rKGxpbmUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGUuX2hlYWRlcmxlbiA+IHRoaXMubWF4SGVhZFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVyciA9IG5ldyBFcnJvcignTWF4IGhlYWRlciBzaXplIGZvciBhIE1JTUUgbm9kZSBleGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9ICdFTUFYTEVOJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsIHx8IChsaW5lLmxlbmd0aCA9PT0gMSAmJiBsaW5lWzBdID09PSAweDBhKSB8fCAobGluZS5sZW5ndGggPT09IDIgJiYgbGluZVswXSA9PT0gMHgwZCAmJiBsaW5lWzFdID09PSAweDBhKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLm5vZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUucGFyc2VIZWFkZXJzKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgYXR0YWNoZWQgbWVzc2FnZSB0aGVuIGp1c3QgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtZXNzYWdlL3JmYzgyMicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLmNvbmZpZy5pZ25vcmVFbWJlZGRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFjdXJyZW50Tm9kZS5lbmNvZGluZyB8fCBbJzdiaXQnLCAnOGJpdCcsICdiaW5hcnknXS5pbmNsdWRlcyhjdXJyZW50Tm9kZS5lbmNvZGluZykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5jb25maWcuZGVmYXVsdElubGluZUVtYmVkZGVkID8gY3VycmVudE5vZGUuZGlzcG9zaXRpb24gIT09ICdhdHRhY2htZW50JyA6IGN1cnJlbnROb2RlLmRpc3Bvc2l0aW9uID09PSAnaW5saW5lJylcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5tZXNzYWdlTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld05vZGUoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGUuX3BhcmVudEJvdW5kYXJ5ID0gY3VycmVudE5vZGUucGFyZW50Tm9kZS5fYm91bmRhcnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudFR5cGUgPT09ICdtZXNzYWdlL3JmYzgyMicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5tZXNzYWdlTm9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IEJPRFk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubXVsdGlwYXJ0ICYmIGN1cnJlbnROb2RlLl9ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZS5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KG51bGwsIGN1cnJlbnROb2RlLCBmbHVzaCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQk9EWToge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlOiB0aGlzLm5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm5vZGUubXVsdGlwYXJ0ID8gJ2RhdGEnIDogJ2JvZHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZmx1c2hcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChudWxsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgbmV3Tm9kZShwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbmV3IE1pbWVOb2RlKHBhcmVudCB8fCBmYWxzZSwgdGhpcy5jb25maWcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gSEVBRDtcbiAgICAgICAgdGhpcy5ub2RlQ291bnRlcisrO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlU3BsaXR0ZXI7XG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtIiwicmVxdWlyZSIsIk1pbWVOb2RlIiwiTUFYX0hFQURfU0laRSIsIk1BWF9DSElMRF9OT0RFUyIsIkhFQUQiLCJCT0RZIiwiTWVzc2FnZVNwbGl0dGVyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJvcHRpb25zIiwicmVhZGFibGVPYmplY3RNb2RlIiwid3JpdGFibGVPYmplY3RNb2RlIiwibWF4SGVhZFNpemUiLCJtYXhDaGlsZE5vZGVzIiwidHJlZSIsIm5vZGVDb3VudGVyIiwibmV3Tm9kZSIsInB1c2giLCJub2RlIiwibGluZSIsImhhc0ZhaWxlZCIsIl90cmFuc2Zvcm0iLCJjaHVuayIsImVuY29kaW5nIiwiY2FsbGJhY2siLCJwb3MiLCJpIiwiZ3JvdXAiLCJ0eXBlIiwiZ3JvdXBzdGFydCIsImxlbmd0aCIsImdyb3VwZW5kIiwiY2hlY2tUcmFpbGluZ0xpbmVicmVhayIsImRhdGEiLCJwYXJlbnROb2RlIiwidmFsdWUiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsInNsaWNlIiwiaXRlcmF0ZURhdGEiLCJsZW4iLCJzdGFydCIsIk1hdGgiLCJtYXgiLCJwcm9jZXNzTGluZSIsImVyciIsImZsdXNoIiwic2V0SW1tZWRpYXRlIiwiY29uY2F0IiwiX2ZsdXNoIiwiY29tcGFyZUJvdW5kYXJ5Iiwic3RhcnRwb3MiLCJib3VuZGFyeSIsImMiLCJjaGVja0JvdW5kYXJ5IiwiX2JvdW5kYXJ5IiwiX3BhcmVudEJvdW5kYXJ5IiwiZmluYWwiLCJuZXh0IiwiYWxsb2MiLCJFcnJvciIsImNvZGUiLCJjb250ZW50VHlwZSIsIl9oZWFkZXJsZW4iLCJoZWFkZXJzIiwicGFyc2VIZWFkZXJzIiwicG9wIiwic3RhdGUiLCJhZGRIZWFkZXJDaHVuayIsImN1cnJlbnROb2RlIiwiaWdub3JlRW1iZWRkZWQiLCJpbmNsdWRlcyIsImRlZmF1bHRJbmxpbmVFbWJlZGRlZCIsImRpc3Bvc2l0aW9uIiwibWVzc2FnZU5vZGUiLCJtdWx0aXBhcnQiLCJwYXJlbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/message-splitter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/mime-node.js":
/*!**********************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/mime-node.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst Headers = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/headers.js\");\nconst libmime = __webpack_require__(/*! libmime */ \"(rsc)/./node_modules/libmime/lib/libmime.js\");\nconst libqp = __webpack_require__(/*! libqp */ \"(rsc)/./node_modules/libqp/lib/libqp.js\");\nconst libbase64 = __webpack_require__(/*! libbase64 */ \"(rsc)/./node_modules/libbase64/lib/libbase64.js\");\nconst PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst pathlib = __webpack_require__(/*! path */ \"path\");\nclass MimeNode {\n    constructor(parentNode, config){\n        this.type = \"node\";\n        this.root = !parentNode;\n        this.parentNode = parentNode;\n        this._parentBoundary = this.parentNode && this.parentNode._boundary;\n        this._headersLines = [];\n        this._headerlen = 0;\n        this._parsedContentType = false;\n        this._boundary = false;\n        this.multipart = false;\n        this.encoding = false;\n        this.headers = false;\n        this.contentType = false;\n        this.flowed = false;\n        this.delSp = false;\n        this.config = config || {};\n        this.libmime = new libmime.Libmime({\n            Iconv: this.config.Iconv\n        });\n        this.parentPartNumber = parentNode && this.partNr || [];\n        this.partNr = false; // resolved later\n        this.childPartNumbers = 0;\n    }\n    getPartNr(provided) {\n        if (provided) {\n            return [].concat(this.partNr || []).filter((nr)=>!isNaN(nr)).concat(provided);\n        }\n        let childPartNr = ++this.childPartNumbers;\n        return [].concat(this.partNr || []).filter((nr)=>!isNaN(nr)).concat(childPartNr);\n    }\n    addHeaderChunk(line) {\n        if (!line) {\n            return;\n        }\n        this._headersLines.push(line);\n        this._headerlen += line.length;\n    }\n    parseHeaders() {\n        if (this.headers) {\n            return;\n        }\n        this.headers = new Headers(Buffer.concat(this._headersLines, this._headerlen), this.config);\n        this._parsedContentDisposition = this.libmime.parseHeaderValue(this.headers.getFirst(\"Content-Disposition\"));\n        // if content-type is missing default to plaintext\n        let contentHeader;\n        if (this.headers.get(\"Content-Type\").length) {\n            contentHeader = this.headers.getFirst(\"Content-Type\");\n        } else {\n            if (this._parsedContentDisposition.params.filename) {\n                let extension = pathlib.parse(this._parsedContentDisposition.params.filename).ext.replace(/^\\./, \"\");\n                if (extension) {\n                    contentHeader = libmime.detectMimeType(extension);\n                }\n            }\n            if (!contentHeader) {\n                if (/^attachment$/i.test(this._parsedContentDisposition.value)) {\n                    contentHeader = \"application/octet-stream\";\n                } else {\n                    contentHeader = \"text/plain\";\n                }\n            }\n        }\n        this._parsedContentType = this.libmime.parseHeaderValue(contentHeader);\n        this.encoding = this.headers.getFirst(\"Content-Transfer-Encoding\").replace(/\\(.*\\)/g, \"\").toLowerCase().trim();\n        this.contentType = (this._parsedContentType.value || \"\").toLowerCase().trim() || false;\n        this.charset = this._parsedContentType.params.charset || false;\n        this.disposition = (this._parsedContentDisposition.value || \"\").toLowerCase().trim() || false;\n        // fix invalidly encoded disposition values\n        if (this.disposition) {\n            try {\n                this.disposition = this.libmime.decodeWords(this.disposition);\n            } catch (E) {\n            // failed to parse disposition, keep as is (most probably an unknown charset is used)\n            }\n        }\n        this.filename = this._parsedContentDisposition.params.filename || this._parsedContentType.params.name || false;\n        if (this._parsedContentType.params.format && this._parsedContentType.params.format.toLowerCase().trim() === \"flowed\") {\n            this.flowed = true;\n            if (this._parsedContentType.params.delsp && this._parsedContentType.params.delsp.toLowerCase().trim() === \"yes\") {\n                this.delSp = true;\n            }\n        }\n        if (this.filename) {\n            try {\n                this.filename = this.libmime.decodeWords(this.filename);\n            } catch (E) {\n            // failed to parse filename, keep as is (most probably an unknown charset is used)\n            }\n        }\n        this.multipart = this.contentType && this.contentType.substr(0, this.contentType.indexOf(\"/\")) === \"multipart\" && this.contentType.substr(this.contentType.indexOf(\"/\") + 1) || false;\n        this._boundary = this._parsedContentType.params.boundary && Buffer.from(this._parsedContentType.params.boundary) || false;\n        this.rfc822 = this.contentType === \"message/rfc822\";\n        if (!this.parentNode || this.parentNode.rfc822) {\n            this.partNr = this.parentNode ? this.parentNode.getPartNr(\"TEXT\") : [\n                \"TEXT\"\n            ];\n        } else {\n            this.partNr = this.parentNode ? this.parentNode.getPartNr() : [];\n        }\n    }\n    getHeaders() {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n        return this.headers.build();\n    }\n    setContentType(contentType) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n        contentType = (contentType || \"\").toLowerCase().trim();\n        if (contentType) {\n            this._parsedContentType.value = contentType;\n        }\n        if (!this.flowed && this._parsedContentType.params.format) {\n            delete this._parsedContentType.params.format;\n        }\n        if (!this.delSp && this._parsedContentType.params.delsp) {\n            delete this._parsedContentType.params.delsp;\n        }\n        this.headers.update(\"Content-Type\", this.libmime.buildHeaderValue(this._parsedContentType));\n    }\n    setCharset(charset) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n        charset = (charset || \"\").toLowerCase().trim();\n        if (charset === \"ascii\") {\n            charset = \"\";\n        }\n        if (!charset) {\n            if (!this._parsedContentType.value) {\n                // nothing to set or update\n                return;\n            }\n            delete this._parsedContentType.params.charset;\n        } else {\n            this._parsedContentType.params.charset = charset;\n        }\n        if (!this._parsedContentType.value) {\n            this._parsedContentType.value = \"text/plain\";\n        }\n        this.headers.update(\"Content-Type\", this.libmime.buildHeaderValue(this._parsedContentType));\n    }\n    setFilename(filename) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n        this.filename = (filename || \"\").toLowerCase().trim();\n        if (this._parsedContentType.params.name) {\n            delete this._parsedContentType.params.name;\n            this.headers.update(\"Content-Type\", this.libmime.buildHeaderValue(this._parsedContentType));\n        }\n        if (!this.filename) {\n            if (!this._parsedContentDisposition.value) {\n                // nothing to set or update\n                return;\n            }\n            delete this._parsedContentDisposition.params.filename;\n        } else {\n            this._parsedContentDisposition.params.filename = this.filename;\n        }\n        if (!this._parsedContentDisposition.value) {\n            this._parsedContentDisposition.value = \"attachment\";\n        }\n        this.headers.update(\"Content-Disposition\", this.libmime.buildHeaderValue(this._parsedContentDisposition));\n    }\n    getDecoder() {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n        switch(this.encoding){\n            case \"base64\":\n                return new libbase64.Decoder();\n            case \"quoted-printable\":\n                return new libqp.Decoder();\n            default:\n                return new PassThrough();\n        }\n    }\n    getEncoder(encoding) {\n        if (!this.headers) {\n            this.parseHeaders();\n        }\n        encoding = (encoding || \"\").toString().toLowerCase().trim();\n        if (encoding && encoding !== this.encoding) {\n            this.headers.update(\"Content-Transfer-Encoding\", encoding);\n        } else {\n            encoding = this.encoding;\n        }\n        switch(encoding){\n            case \"base64\":\n                return new libbase64.Encoder();\n            case \"quoted-printable\":\n                return new libqp.Encoder();\n            default:\n                return new PassThrough();\n        }\n    }\n}\nmodule.exports = MimeNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9taW1lLW5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUN4QixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN4QixNQUFNRSxRQUFRRixtQkFBT0EsQ0FBQztBQUN0QixNQUFNRyxZQUFZSCxtQkFBT0EsQ0FBQztBQUMxQixNQUFNSSxjQUFjSix5REFBNkI7QUFDakQsTUFBTUssVUFBVUwsbUJBQU9BLENBQUM7QUFFeEIsTUFBTU07SUFDRkMsWUFBWUMsVUFBVSxFQUFFQyxNQUFNLENBQUU7UUFDNUIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLElBQUksR0FBRyxDQUFDSDtRQUNiLElBQUksQ0FBQ0EsVUFBVSxHQUFHQTtRQUVsQixJQUFJLENBQUNJLGVBQWUsR0FBRyxJQUFJLENBQUNKLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQ0ssU0FBUztRQUNuRSxJQUFJLENBQUNDLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBRWxCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDSCxTQUFTLEdBQUc7UUFFakIsSUFBSSxDQUFDSSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsS0FBSyxHQUFHO1FBRWIsSUFBSSxDQUFDYixNQUFNLEdBQUdBLFVBQVUsQ0FBQztRQUN6QixJQUFJLENBQUNSLE9BQU8sR0FBRyxJQUFJQSxRQUFRc0IsT0FBTyxDQUFDO1lBQUVDLE9BQU8sSUFBSSxDQUFDZixNQUFNLENBQUNlLEtBQUs7UUFBQztRQUU5RCxJQUFJLENBQUNDLGdC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LElBQUksQ0FBQ2hDLHlCQUF5QjtJQUMzRztJQUVBbUMsYUFBYTtRQUNULElBQUksQ0FBQyxJQUFJLENBQUN6RCxPQUFPLEVBQUU7WUFDZixJQUFJLENBQUNvQixZQUFZO1FBQ3JCO1FBRUEsT0FBUSxJQUFJLENBQUNyQixRQUFRO1lBQ2pCLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJZixVQUFVMEUsT0FBTztZQUNoQyxLQUFLO2dCQUNELE9BQU8sSUFBSTNFLE1BQU0yRSxPQUFPO1lBQzVCO2dCQUNJLE9BQU8sSUFBSXpFO1FBQ25CO0lBQ0o7SUFFQTBFLFdBQVc1RCxRQUFRLEVBQUU7UUFDakIsSUFBSSxDQUFDLElBQUksQ0FBQ0MsT0FBTyxFQUFFO1lBQ2YsSUFBSSxDQUFDb0IsWUFBWTtRQUNyQjtRQUVBckIsV0FBVyxDQUFDQSxZQUFZLEVBQUMsRUFBRzZELFFBQVEsR0FBR3hCLFdBQVcsR0FBR0MsSUFBSTtRQUV6RCxJQUFJdEMsWUFBWUEsYUFBYSxJQUFJLENBQUNBLFFBQVEsRUFBRTtZQUN4QyxJQUFJLENBQUNDLE9BQU8sQ0FBQ3FELE1BQU0sQ0FBQyw2QkFBNkJ0RDtRQUNyRCxPQUFPO1lBQ0hBLFdBQVcsSUFBSSxDQUFDQSxRQUFRO1FBQzVCO1FBRUEsT0FBUUE7WUFDSixLQUFLO2dCQUNELE9BQU8sSUFBSWYsVUFBVTZFLE9BQU87WUFDaEMsS0FBSztnQkFDRCxPQUFPLElBQUk5RSxNQUFNOEUsT0FBTztZQUM1QjtnQkFDSSxPQUFPLElBQUk1RTtRQUNuQjtJQUNKO0FBQ0o7QUFFQTZFLE9BQU9DLE9BQU8sR0FBRzVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQVNXRCBDbGllbnQgSHViLy4vbm9kZV9tb2R1bGVzL0B6b25lLWV1L21haWxzcGxpdC9saWIvbWltZS1ub2RlLmpzPzA0NzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIZWFkZXJzID0gcmVxdWlyZSgnLi9oZWFkZXJzJyk7XG5jb25zdCBsaWJtaW1lID0gcmVxdWlyZSgnbGlibWltZScpO1xuY29uc3QgbGlicXAgPSByZXF1aXJlKCdsaWJxcCcpO1xuY29uc3QgbGliYmFzZTY0ID0gcmVxdWlyZSgnbGliYmFzZTY0Jyk7XG5jb25zdCBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3N0cmVhbScpLlBhc3NUaHJvdWdoO1xuY29uc3QgcGF0aGxpYiA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY2xhc3MgTWltZU5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudE5vZGUsIGNvbmZpZykge1xuICAgICAgICB0aGlzLnR5cGUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMucm9vdCA9ICFwYXJlbnROb2RlO1xuICAgICAgICB0aGlzLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuXG4gICAgICAgIHRoaXMuX3BhcmVudEJvdW5kYXJ5ID0gdGhpcy5wYXJlbnROb2RlICYmIHRoaXMucGFyZW50Tm9kZS5fYm91bmRhcnk7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNMaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLl9oZWFkZXJsZW4gPSAwO1xuXG4gICAgICAgIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JvdW5kYXJ5ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5tdWx0aXBhcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZsb3dlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbFNwID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIHRoaXMubGlibWltZSA9IG5ldyBsaWJtaW1lLkxpYm1pbWUoeyBJY29udjogdGhpcy5jb25maWcuSWNvbnYgfSk7XG5cbiAgICAgICAgdGhpcy5wYXJlbnRQYXJ0TnVtYmVyID0gKHBhcmVudE5vZGUgJiYgdGhpcy5wYXJ0TnIpIHx8IFtdO1xuICAgICAgICB0aGlzLnBhcnROciA9IGZhbHNlOyAvLyByZXNvbHZlZCBsYXRlclxuICAgICAgICB0aGlzLmNoaWxkUGFydE51bWJlcnMgPSAwO1xuICAgIH1cblxuICAgIGdldFBhcnROcihwcm92aWRlZCkge1xuICAgICAgICBpZiAocHJvdmlkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5wYXJ0TnIgfHwgW10pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihuciA9PiAhaXNOYU4obnIpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocHJvdmlkZWQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZFBhcnROciA9ICsrdGhpcy5jaGlsZFBhcnROdW1iZXJzO1xuICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5wYXJ0TnIgfHwgW10pXG4gICAgICAgICAgICAuZmlsdGVyKG5yID0+ICFpc05hTihucikpXG4gICAgICAgICAgICAuY29uY2F0KGNoaWxkUGFydE5yKTtcbiAgICB9XG5cbiAgICBhZGRIZWFkZXJDaHVuayhsaW5lKSB7XG4gICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWRlcnNMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB0aGlzLl9oZWFkZXJsZW4gKz0gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcGFyc2VIZWFkZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoQnVmZmVyLmNvbmNhdCh0aGlzLl9oZWFkZXJzTGluZXMsIHRoaXMuX2hlYWRlcmxlbiksIHRoaXMuY29uZmlnKTtcblxuICAgICAgICB0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24gPSB0aGlzLmxpYm1pbWUucGFyc2VIZWFkZXJWYWx1ZSh0aGlzLmhlYWRlcnMuZ2V0Rmlyc3QoJ0NvbnRlbnQtRGlzcG9zaXRpb24nKSk7XG5cbiAgICAgICAgLy8gaWYgY29udGVudC10eXBlIGlzIG1pc3NpbmcgZGVmYXVsdCB0byBwbGFpbnRleHRcbiAgICAgICAgbGV0IGNvbnRlbnRIZWFkZXI7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRlbnRIZWFkZXIgPSB0aGlzLmhlYWRlcnMuZ2V0Rmlyc3QoJ0NvbnRlbnQtVHlwZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi5wYXJhbXMuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW5zaW9uID0gcGF0aGxpYi5wYXJzZSh0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24ucGFyYW1zLmZpbGVuYW1lKS5leHQucmVwbGFjZSgvXlxcLi8sICcnKTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIZWFkZXIgPSBsaWJtaW1lLmRldGVjdE1pbWVUeXBlKGV4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb250ZW50SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eYXR0YWNobWVudCQvaS50ZXN0KHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEhlYWRlciA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRIZWFkZXIgPSAndGV4dC9wbGFpbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFyc2VkQ29udGVudFR5cGUgPSB0aGlzLmxpYm1pbWUucGFyc2VIZWFkZXJWYWx1ZShjb250ZW50SGVhZGVyKTtcblxuICAgICAgICB0aGlzLmVuY29kaW5nID0gdGhpcy5oZWFkZXJzXG4gICAgICAgICAgICAuZ2V0Rmlyc3QoJ0NvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC4qXFwpL2csICcnKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSAodGhpcy5fcGFyc2VkQ29udGVudFR5cGUudmFsdWUgfHwgJycpLnRvTG93ZXJDYXNlKCkudHJpbSgpIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYXJzZXQgPSB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuY2hhcnNldCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXNwb3NpdGlvbiA9ICh0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24udmFsdWUgfHwgJycpLnRvTG93ZXJDYXNlKCkudHJpbSgpIHx8IGZhbHNlO1xuXG4gICAgICAgIC8vIGZpeCBpbnZhbGlkbHkgZW5jb2RlZCBkaXNwb3NpdGlvbiB2YWx1ZXNcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NpdGlvbiA9IHRoaXMubGlibWltZS5kZWNvZGVXb3Jkcyh0aGlzLmRpc3Bvc2l0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAvLyBmYWlsZWQgdG8gcGFyc2UgZGlzcG9zaXRpb24sIGtlZXAgYXMgaXMgKG1vc3QgcHJvYmFibHkgYW4gdW5rbm93biBjaGFyc2V0IGlzIHVzZWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbGVuYW1lID0gdGhpcy5fcGFyc2VkQ29udGVudERpc3Bvc2l0aW9uLnBhcmFtcy5maWxlbmFtZSB8fCB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMubmFtZSB8fCBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5fcGFyc2VkQ29udGVudFR5cGUucGFyYW1zLmZvcm1hdCAmJiB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuZm9ybWF0LnRvTG93ZXJDYXNlKCkudHJpbSgpID09PSAnZmxvd2VkJykge1xuICAgICAgICAgICAgdGhpcy5mbG93ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5kZWxzcCAmJiB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuZGVsc3AudG9Mb3dlckNhc2UoKS50cmltKCkgPT09ICd5ZXMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxTcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maWxlbmFtZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVuYW1lID0gdGhpcy5saWJtaW1lLmRlY29kZVdvcmRzKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgICAgIC8vIGZhaWxlZCB0byBwYXJzZSBmaWxlbmFtZSwga2VlcCBhcyBpcyAobW9zdCBwcm9iYWJseSBhbiB1bmtub3duIGNoYXJzZXQgaXMgdXNlZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubXVsdGlwYXJ0ID1cbiAgICAgICAgICAgICh0aGlzLmNvbnRlbnRUeXBlICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZS5zdWJzdHIoMCwgdGhpcy5jb250ZW50VHlwZS5pbmRleE9mKCcvJykpID09PSAnbXVsdGlwYXJ0JyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFR5cGUuc3Vic3RyKHRoaXMuY29udGVudFR5cGUuaW5kZXhPZignLycpICsgMSkpIHx8XG4gICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgdGhpcy5fYm91bmRhcnkgPSAodGhpcy5fcGFyc2VkQ29udGVudFR5cGUucGFyYW1zLmJvdW5kYXJ5ICYmIEJ1ZmZlci5mcm9tKHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5ib3VuZGFyeSkpIHx8IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucmZjODIyID0gdGhpcy5jb250ZW50VHlwZSA9PT0gJ21lc3NhZ2UvcmZjODIyJztcblxuICAgICAgICBpZiAoIXRoaXMucGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGUucmZjODIyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnROciA9IHRoaXMucGFyZW50Tm9kZSA/IHRoaXMucGFyZW50Tm9kZS5nZXRQYXJ0TnIoJ1RFWFQnKSA6IFsnVEVYVCddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJ0TnIgPSB0aGlzLnBhcmVudE5vZGUgPyB0aGlzLnBhcmVudE5vZGUuZ2V0UGFydE5yKCkgOiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEhlYWRlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnMuYnVpbGQoKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnRUeXBlID0gKGNvbnRlbnRUeXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS52YWx1ZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmZsb3dlZCAmJiB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuZm9ybWF0KSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcGFyc2VkQ29udGVudFR5cGUucGFyYW1zLmZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5kZWxTcCAmJiB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuZGVsc3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuZGVsc3A7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYWRlcnMudXBkYXRlKCdDb250ZW50LVR5cGUnLCB0aGlzLmxpYm1pbWUuYnVpbGRIZWFkZXJWYWx1ZSh0aGlzLl9wYXJzZWRDb250ZW50VHlwZSkpO1xuICAgIH1cblxuICAgIHNldENoYXJzZXQoY2hhcnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYXJzZXQgPSAoY2hhcnNldCB8fCAnJykudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cbiAgICAgICAgaWYgKGNoYXJzZXQgPT09ICdhc2NpaScpIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hhcnNldCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJzZWRDb250ZW50VHlwZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gc2V0IG9yIHVwZGF0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMuY2hhcnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5jaGFyc2V0ID0gY2hhcnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcGFyc2VkQ29udGVudFR5cGUudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnZhbHVlID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oZWFkZXJzLnVwZGF0ZSgnQ29udGVudC1UeXBlJywgdGhpcy5saWJtaW1lLmJ1aWxkSGVhZGVyVmFsdWUodGhpcy5fcGFyc2VkQ29udGVudFR5cGUpKTtcbiAgICB9XG5cbiAgICBzZXRGaWxlbmFtZShmaWxlbmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSAoZmlsZW5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wYXJzZWRDb250ZW50VHlwZS5wYXJhbXMubmFtZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BhcnNlZENvbnRlbnRUeXBlLnBhcmFtcy5uYW1lO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnVwZGF0ZSgnQ29udGVudC1UeXBlJywgdGhpcy5saWJtaW1lLmJ1aWxkSGVhZGVyVmFsdWUodGhpcy5fcGFyc2VkQ29udGVudFR5cGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5maWxlbmFtZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RoaW5nIHRvIHNldCBvciB1cGRhdGVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcGFyc2VkQ29udGVudERpc3Bvc2l0aW9uLnBhcmFtcy5maWxlbmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi5wYXJhbXMuZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24udmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlZENvbnRlbnREaXNwb3NpdGlvbi52YWx1ZSA9ICdhdHRhY2htZW50JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGVhZGVycy51cGRhdGUoJ0NvbnRlbnQtRGlzcG9zaXRpb24nLCB0aGlzLmxpYm1pbWUuYnVpbGRIZWFkZXJWYWx1ZSh0aGlzLl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24pKTtcbiAgICB9XG5cbiAgICBnZXREZWNvZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgICAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGxpYmJhc2U2NC5EZWNvZGVyKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtcHJpbnRhYmxlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGxpYnFwLkRlY29kZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0RW5jb2RlcihlbmNvZGluZykge1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUhlYWRlcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nIHx8ICcnKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuXG4gICAgICAgIGlmIChlbmNvZGluZyAmJiBlbmNvZGluZyAhPT0gdGhpcy5lbmNvZGluZykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnVwZGF0ZSgnQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZycsIGVuY29kaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJiYXNlNjQuRW5jb2RlcigpO1xuICAgICAgICAgICAgY2FzZSAncXVvdGVkLXByaW50YWJsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsaWJxcC5FbmNvZGVyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNaW1lTm9kZTtcbiJdLCJuYW1lcyI6WyJIZWFkZXJzIiwicmVxdWlyZSIsImxpYm1pbWUiLCJsaWJxcCIsImxpYmJhc2U2NCIsIlBhc3NUaHJvdWdoIiwicGF0aGxpYiIsIk1pbWVOb2RlIiwiY29uc3RydWN0b3IiLCJwYXJlbnROb2RlIiwiY29uZmlnIiwidHlwZSIsInJvb3QiLCJfcGFyZW50Qm91bmRhcnkiLCJfYm91bmRhcnkiLCJfaGVhZGVyc0xpbmVzIiwiX2hlYWRlcmxlbiIsIl9wYXJzZWRDb250ZW50VHlwZSIsIm11bHRpcGFydCIsImVuY29kaW5nIiwiaGVhZGVycyIsImNvbnRlbnRUeXBlIiwiZmxvd2VkIiwiZGVsU3AiLCJMaWJtaW1lIiwiSWNvbnYiLCJwYXJlbnRQYXJ0TnVtYmVyIiwicGFydE5yIiwiY2hpbGRQYXJ0TnVtYmVycyIsImdldFBhcnROciIsInByb3ZpZGVkIiwiY29uY2F0IiwiZmlsdGVyIiwibnIiLCJpc05hTiIsImNoaWxkUGFydE5yIiwiYWRkSGVhZGVyQ2h1bmsiLCJsaW5lIiwicHVzaCIsImxlbmd0aCIsInBhcnNlSGVhZGVycyIsIkJ1ZmZlciIsIl9wYXJzZWRDb250ZW50RGlzcG9zaXRpb24iLCJwYXJzZUhlYWRlclZhbHVlIiwiZ2V0Rmlyc3QiLCJjb250ZW50SGVhZGVyIiwiZ2V0IiwicGFyYW1zIiwiZmlsZW5hbWUiLCJleHRlbnNpb24iLCJwYXJzZSIsImV4dCIsInJlcGxhY2UiLCJkZXRlY3RNaW1lVHlwZSIsInRlc3QiLCJ2YWx1ZSIsInRvTG93ZXJDYXNlIiwidHJpbSIsImNoYXJzZXQiLCJkaXNwb3NpdGlvbiIsImRlY29kZVdvcmRzIiwiRSIsIm5hbWUiLCJmb3JtYXQiLCJkZWxzcCIsInN1YnN0ciIsImluZGV4T2YiLCJib3VuZGFyeSIsImZyb20iLCJyZmM4MjIiLCJnZXRIZWFkZXJzIiwiYnVpbGQiLCJzZXRDb250ZW50VHlwZSIsInVwZGF0ZSIsImJ1aWxkSGVhZGVyVmFsdWUiLCJzZXRDaGFyc2V0Iiwic2V0RmlsZW5hbWUiLCJnZXREZWNvZGVyIiwiRGVjb2RlciIsImdldEVuY29kZXIiLCJ0b1N0cmluZyIsIkVuY29kZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/mime-node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// Helper class to rewrite nodes with specific mime type\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst FlowedDecoder = __webpack_require__(/*! ./flowed-decoder */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\");\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} rewriteAction Function to run with the node content\n */ class NodeRewriter extends Transform {\n    constructor(filterFunc, rewriteAction){\n        let options = {\n            readableObjectMode: true,\n            writableObjectMode: true\n        };\n        super(options);\n        this.filterFunc = filterFunc;\n        this.rewriteAction = rewriteAction;\n        this.decoder = false;\n        this.encoder = false;\n        this.continue = false;\n    }\n    _transform(data, encoding, callback) {\n        this.processIncoming(data, callback);\n    }\n    _flush(callback) {\n        if (this.decoder) {\n            // emit an empty node just in case there is pending data to end\n            return this.processIncoming({\n                type: \"none\"\n            }, callback);\n        }\n        return callback();\n    }\n    processIncoming(data, callback) {\n        if (this.decoder && data.type === \"body\") {\n            // data to parse\n            if (!this.decoder.write(data.value)) {\n                return this.decoder.once(\"drain\", callback);\n            } else {\n                return callback();\n            }\n        } else if (this.decoder && data.type !== \"body\") {\n            // stop decoding.\n            // we can not process the current data chunk as we need to wait until\n            // the parsed data is completely processed, so we store a reference to the\n            // continue callback\n            this.continue = ()=>{\n                this.continue = false;\n                this.decoder = false;\n                this.encoder = false;\n                this.processIncoming(data, callback);\n            };\n            return this.decoder.end();\n        } else if (data.type === \"node\" && this.filterFunc(data)) {\n            // found matching node, create new handler\n            this.emit(\"node\", this.createDecodePair(data));\n        } else if (this.readable && data.type !== \"none\") {\n            // we don't care about this data, just pass it over to the joiner\n            this.push(data);\n        }\n        callback();\n    }\n    createDecodePair(node) {\n        this.decoder = node.getDecoder();\n        if ([\n            \"base64\",\n            \"quoted-printable\"\n        ].includes(node.encoding)) {\n            this.encoder = node.getEncoder();\n        } else {\n            this.encoder = node.getEncoder(\"quoted-printable\");\n        }\n        let lastByte = false;\n        let decoder = this.decoder;\n        let encoder = this.encoder;\n        let firstChunk = true;\n        decoder.$reading = false;\n        let readFromEncoder = ()=>{\n            decoder.$reading = true;\n            let data = encoder.read();\n            if (data === null) {\n                decoder.$reading = false;\n                return;\n            }\n            if (firstChunk) {\n                firstChunk = false;\n                if (this.readable) {\n                    this.push(node);\n                    if (node.type === \"body\") {\n                        lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n                    }\n                }\n            }\n            let writeMore = true;\n            if (this.readable) {\n                writeMore = this.push({\n                    node,\n                    type: \"body\",\n                    value: data\n                });\n                lastByte = data && data.length && data[data.length - 1];\n            }\n            if (writeMore) {\n                return setImmediate(readFromEncoder);\n            } else {\n                encoder.pause();\n                // no idea how to catch drain? use timeout for now as poor man's substitute\n                // this.once('drain', () => encoder.resume());\n                setTimeout(()=>{\n                    encoder.resume();\n                    setImmediate(readFromEncoder);\n                }, 100);\n            }\n        };\n        encoder.on(\"readable\", ()=>{\n            if (!decoder.$reading) {\n                return readFromEncoder();\n            }\n        });\n        encoder.on(\"end\", ()=>{\n            if (firstChunk) {\n                firstChunk = false;\n                if (this.readable) {\n                    this.push(node);\n                    if (node.type === \"body\") {\n                        lastByte = node.value && node.value.length && node.value[node.value.length - 1];\n                    }\n                }\n            }\n            if (lastByte !== 0x0a) {\n                // make sure there is a terminating line break\n                this.push({\n                    node,\n                    type: \"body\",\n                    value: Buffer.from([\n                        0x0a\n                    ])\n                });\n            }\n            if (this.continue) {\n                return this.continue();\n            }\n        });\n        if (/^text\\//.test(node.contentType) && node.flowed) {\n            // text/plain; format=flowed is a special case\n            let flowDecoder = decoder;\n            decoder = new FlowedDecoder({\n                delSp: node.delSp,\n                encoding: node.encoding\n            });\n            flowDecoder.on(\"error\", (err)=>{\n                decoder.emit(\"error\", err);\n            });\n            flowDecoder.pipe(decoder);\n            // we don't know what kind of data we are going to get, does it comply with the\n            // requirements of format=flowed, so we just cancel it\n            node.flowed = false;\n            node.delSp = false;\n            node.setContentType();\n        }\n        return {\n            node,\n            decoder,\n            encoder\n        };\n    }\n}\nmodule.exports = NodeRewriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9ub2RlLXJld3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsd0RBQXdEO0FBRXhELE1BQU1BLFlBQVlDLHVEQUEyQjtBQUM3QyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBRTlCOzs7Ozs7Q0FNQyxHQUNELE1BQU1FLHFCQUFxQkg7SUFDdkJJLFlBQVlDLFVBQVUsRUFBRUMsYUFBYSxDQUFFO1FBQ25DLElBQUlDLFVBQVU7WUFDVkMsb0JBQW9CO1lBQ3BCQyxvQkFBb0I7UUFDeEI7UUFDQSxLQUFLLENBQUNGO1FBRU4sSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtRQUVyQixJQUFJLENBQUNJLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDcEI7SUFFQUMsV0FBV0MsSUFBSSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRTtRQUNqQyxJQUFJLENBQUNDLGVBQWUsQ0FBQ0gsTUFBTUU7SUFDL0I7SUFFQUUsT0FBT0YsUUFBUSxFQUFFO1FBQ2IsSUFBSSxJQUFJLENBQUNOLE9BQU8sRUFBRTtZQUNkLCtEQUErRDtZQUMvRCxPQUFPLElBQUksQ0FBQ08sZUFBZSxDQUN2QjtnQkFDSUUsTUFBTTtZQUNWLEdBQ0FIO1FBRVI7UUFDQSxPQUFPQTtJQUNYO0lBRUFDLGdCQUFnQkgsSUFBSSxFQUFFRSxRQUFRLEVBQUU7UUFDNUIsSUFBSSxJQUFJLENBQUNOLE9BQU8sSUFBSUksS0FBS0ssSUFBSSxLQUFLLFFBQVE7WUFDdEMsZ0JBQWdCO1lBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUNULE9BQU8sQ0FBQ1UsS0FBSyxDQUFDTixLQUFLTyxLQUFLLEdBQUc7Z0JBQ2pDLE9BQU8sSUFBSSxDQUFDWCxPQUFPLENBQUNZLElBQUksQ0FBQyxTQUFTTjtZQUN0QyxPQUFPO2dC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IENsaWVudCBIdWIvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9ub2RlLXJld3JpdGVyLmpzP2NlNjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBIZWxwZXIgY2xhc3MgdG8gcmV3cml0ZSBub2RlcyB3aXRoIHNwZWNpZmljIG1pbWUgdHlwZVxuXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm07XG5jb25zdCBGbG93ZWREZWNvZGVyID0gcmVxdWlyZSgnLi9mbG93ZWQtZGVjb2RlcicpO1xuXG4vKipcbiAqIE5vZGVSZXdyaXRlciBUcmFuc2Zvcm0gc3RyZWFtLiBVcGRhdGVzIGNvbnRlbnQgZm9yIGFsbCBub2RlcyB3aXRoIHNwZWNpZmllZCBtaW1lIHR5cGVcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSBEZWZpbmUgdGhlIE1pbWUtVHlwZSB0byBsb29rIGZvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmV3cml0ZUFjdGlvbiBGdW5jdGlvbiB0byBydW4gd2l0aCB0aGUgbm9kZSBjb250ZW50XG4gKi9cbmNsYXNzIE5vZGVSZXdyaXRlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVyRnVuYywgcmV3cml0ZUFjdGlvbikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmZpbHRlckZ1bmMgPSBmaWx0ZXJGdW5jO1xuICAgICAgICB0aGlzLnJld3JpdGVBY3Rpb24gPSByZXdyaXRlQWN0aW9uO1xuXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250aW51ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0luY29taW5nKGRhdGEsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZGVjb2Rlcikge1xuICAgICAgICAgICAgLy8gZW1pdCBhbiBlbXB0eSBub2RlIGp1c3QgaW4gY2FzZSB0aGVyZSBpcyBwZW5kaW5nIGRhdGEgdG8gZW5kXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzSW5jb21pbmcoXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHByb2Nlc3NJbmNvbWluZyhkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5kZWNvZGVyICYmIGRhdGEudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBkYXRhIHRvIHBhcnNlXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVjb2Rlci53cml0ZShkYXRhLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZXIub25jZSgnZHJhaW4nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVjb2RlciAmJiBkYXRhLnR5cGUgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gc3RvcCBkZWNvZGluZy5cbiAgICAgICAgICAgIC8vIHdlIGNhbiBub3QgcHJvY2VzcyB0aGUgY3VycmVudCBkYXRhIGNodW5rIGFzIHdlIG5lZWQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAgICAgLy8gdGhlIHBhcnNlZCBkYXRhIGlzIGNvbXBsZXRlbHkgcHJvY2Vzc2VkLCBzbyB3ZSBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGVcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbmNvbWluZyhkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdub2RlJyAmJiB0aGlzLmZpbHRlckZ1bmMoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1hdGNoaW5nIG5vZGUsIGNyZWF0ZSBuZXcgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdub2RlJywgdGhpcy5jcmVhdGVEZWNvZGVQYWlyKGRhdGEpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlYWRhYmxlICYmIGRhdGEudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgZGF0YSwganVzdCBwYXNzIGl0IG92ZXIgdG8gdGhlIGpvaW5lclxuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVjb2RlUGFpcihub2RlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5vZGUuZ2V0RGVjb2RlcigpO1xuXG4gICAgICAgIGlmIChbJ2Jhc2U2NCcsICdxdW90ZWQtcHJpbnRhYmxlJ10uaW5jbHVkZXMobm9kZS5lbmNvZGluZykpIHtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlciA9IG5vZGUuZ2V0RW5jb2RlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGVyID0gbm9kZS5nZXRFbmNvZGVyKCdxdW90ZWQtcHJpbnRhYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGFzdEJ5dGUgPSBmYWxzZTtcblxuICAgICAgICBsZXQgZGVjb2RlciA9IHRoaXMuZGVjb2RlcjtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLmVuY29kZXI7XG4gICAgICAgIGxldCBmaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgZGVjb2Rlci4kcmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGxldCByZWFkRnJvbUVuY29kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBkZWNvZGVyLiRyZWFkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgbGV0IGRhdGEgPSBlbmNvZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVjb2Rlci4kcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICBmaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCeXRlID0gbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLmxlbmd0aCAmJiBub2RlLnZhbHVlW25vZGUudmFsdWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB3cml0ZU1vcmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZU1vcmUgPSB0aGlzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGFzdEJ5dGUgPSBkYXRhICYmIGRhdGEubGVuZ3RoICYmIGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdyaXRlTW9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUocmVhZEZyb21FbmNvZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rlci5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIC8vIG5vIGlkZWEgaG93IHRvIGNhdGNoIGRyYWluPyB1c2UgdGltZW91dCBmb3Igbm93IGFzIHBvb3IgbWFuJ3Mgc3Vic3RpdHV0ZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMub25jZSgnZHJhaW4nLCAoKSA9PiBlbmNvZGVyLnJlc3VtZSgpKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2Rlci5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHJlYWRGcm9tRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBlbmNvZGVyLm9uKCdyZWFkYWJsZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZGVjb2Rlci4kcmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkRnJvbUVuY29kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW5jb2Rlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICBmaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCeXRlID0gbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLmxlbmd0aCAmJiBub2RlLnZhbHVlW25vZGUudmFsdWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYXN0Qnl0ZSAhPT0gMHgwYSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBhIHRlcm1pbmF0aW5nIGxpbmUgYnJlYWtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBCdWZmZXIuZnJvbShbMHgwYV0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGludWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKC9edGV4dFxcLy8udGVzdChub2RlLmNvbnRlbnRUeXBlKSAmJiBub2RlLmZsb3dlZCkge1xuICAgICAgICAgICAgLy8gdGV4dC9wbGFpbjsgZm9ybWF0PWZsb3dlZCBpcyBhIHNwZWNpYWwgY2FzZVxuICAgICAgICAgICAgbGV0IGZsb3dEZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgICAgIGRlY29kZXIgPSBuZXcgRmxvd2VkRGVjb2Rlcih7XG4gICAgICAgICAgICAgICAgZGVsU3A6IG5vZGUuZGVsU3AsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IG5vZGUuZW5jb2RpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmxvd0RlY29kZXIub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmxvd0RlY29kZXIucGlwZShkZWNvZGVyKTtcblxuICAgICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGF0IGtpbmQgb2YgZGF0YSB3ZSBhcmUgZ29pbmcgdG8gZ2V0LCBkb2VzIGl0IGNvbXBseSB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIG9mIGZvcm1hdD1mbG93ZWQsIHNvIHdlIGp1c3QgY2FuY2VsIGl0XG4gICAgICAgICAgICBub2RlLmZsb3dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5kZWxTcCA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5zZXRDb250ZW50VHlwZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBkZWNvZGVyLFxuICAgICAgICAgICAgZW5jb2RlclxuICAgICAgICB9O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlUmV3cml0ZXI7XG4iXSwibmFtZXMiOlsiVHJhbnNmb3JtIiwicmVxdWlyZSIsIkZsb3dlZERlY29kZXIiLCJOb2RlUmV3cml0ZXIiLCJjb25zdHJ1Y3RvciIsImZpbHRlckZ1bmMiLCJyZXdyaXRlQWN0aW9uIiwib3B0aW9ucyIsInJlYWRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImRlY29kZXIiLCJlbmNvZGVyIiwiY29udGludWUiLCJfdHJhbnNmb3JtIiwiZGF0YSIsImVuY29kaW5nIiwiY2FsbGJhY2siLCJwcm9jZXNzSW5jb21pbmciLCJfZmx1c2giLCJ0eXBlIiwid3JpdGUiLCJ2YWx1ZSIsIm9uY2UiLCJlbmQiLCJlbWl0IiwiY3JlYXRlRGVjb2RlUGFpciIsInJlYWRhYmxlIiwicHVzaCIsIm5vZGUiLCJnZXREZWNvZGVyIiwiaW5jbHVkZXMiLCJnZXRFbmNvZGVyIiwibGFzdEJ5dGUiLCJmaXJzdENodW5rIiwiJHJlYWRpbmciLCJyZWFkRnJvbUVuY29kZXIiLCJyZWFkIiwibGVuZ3RoIiwid3JpdGVNb3JlIiwic2V0SW1tZWRpYXRlIiwicGF1c2UiLCJzZXRUaW1lb3V0IiwicmVzdW1lIiwib24iLCJCdWZmZXIiLCJmcm9tIiwidGVzdCIsImNvbnRlbnRUeXBlIiwiZmxvd2VkIiwiZmxvd0RlY29kZXIiLCJkZWxTcCIsImVyciIsInBpcGUiLCJzZXRDb250ZW50VHlwZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-rewriter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-streamer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zone-eu/mailsplit/lib/node-streamer.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// Helper class to rewrite nodes with specific mime type\nconst Transform = (__webpack_require__(/*! stream */ \"stream\").Transform);\nconst FlowedDecoder = __webpack_require__(/*! ./flowed-decoder */ \"(rsc)/./node_modules/@zone-eu/mailsplit/lib/flowed-decoder.js\");\n/**\n * NodeRewriter Transform stream. Updates content for all nodes with specified mime type\n *\n * @constructor\n * @param {String} mimeType Define the Mime-Type to look for\n * @param {Function} streamAction Function to run with the node content\n */ class NodeStreamer extends Transform {\n    constructor(filterFunc, streamAction){\n        let options = {\n            readableObjectMode: true,\n            writableObjectMode: true\n        };\n        super(options);\n        this.filterFunc = filterFunc;\n        this.streamAction = streamAction;\n        this.decoder = false;\n        this.canContinue = false;\n        this.continue = false;\n    }\n    _transform(data, encoding, callback) {\n        this.processIncoming(data, callback);\n    }\n    _flush(callback) {\n        if (this.decoder) {\n            // emit an empty node just in case there is pending data to end\n            return this.processIncoming({\n                type: \"none\"\n            }, callback);\n        }\n        return callback();\n    }\n    processIncoming(data, callback) {\n        if (this.decoder && data.type === \"body\") {\n            // data to parse\n            this.push(data);\n            if (!this.decoder.write(data.value)) {\n                return this.decoder.once(\"drain\", callback);\n            } else {\n                return callback();\n            }\n        } else if (this.decoder && data.type !== \"body\") {\n            // stop decoding.\n            // we can not process the current data chunk as we need to wait until\n            // the parsed data is completely processed, so we store a reference to the\n            // continue callback\n            let doContinue = ()=>{\n                this.continue = false;\n                this.decoder = false;\n                this.canContinue = false;\n                this.processIncoming(data, callback);\n            };\n            if (this.canContinue) {\n                setImmediate(doContinue);\n            } else {\n                this.continue = ()=>doContinue();\n            }\n            return this.decoder.end();\n        } else if (data.type === \"node\" && this.filterFunc(data)) {\n            this.push(data);\n            // found matching node, create new handler\n            this.emit(\"node\", this.createDecoder(data));\n        } else if (this.readable && data.type !== \"none\") {\n            // we don't care about this data, just pass it over to the joiner\n            this.push(data);\n        }\n        callback();\n    }\n    createDecoder(node) {\n        this.decoder = node.getDecoder();\n        let decoder = this.decoder;\n        decoder.$reading = false;\n        if (/^text\\//.test(node.contentType) && node.flowed) {\n            let flowDecoder = decoder;\n            decoder = new FlowedDecoder({\n                delSp: node.delSp\n            });\n            flowDecoder.on(\"error\", (err)=>{\n                decoder.emit(\"error\", err);\n            });\n            flowDecoder.pipe(decoder);\n        }\n        return {\n            node,\n            decoder,\n            done: ()=>{\n                if (typeof this.continue === \"function\") {\n                    // called once input stream is processed\n                    this.continue();\n                } else {\n                    // called before input stream is processed\n                    this.canContinue = true;\n                }\n            }\n        };\n    }\n}\nmodule.exports = NodeStreamer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHpvbmUtZXUvbWFpbHNwbGl0L2xpYi9ub2RlLXN0cmVhbWVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsd0RBQXdEO0FBRXhELE1BQU1BLFlBQVlDLHVEQUEyQjtBQUM3QyxNQUFNQyxnQkFBZ0JELG1CQUFPQSxDQUFDO0FBRTlCOzs7Ozs7Q0FNQyxHQUNELE1BQU1FLHFCQUFxQkg7SUFDdkJJLFlBQVlDLFVBQVUsRUFBRUMsWUFBWSxDQUFFO1FBQ2xDLElBQUlDLFVBQVU7WUFDVkMsb0JBQW9CO1lBQ3BCQyxvQkFBb0I7UUFDeEI7UUFDQSxLQUFLLENBQUNGO1FBRU4sSUFBSSxDQUFDRixVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0MsWUFBWSxHQUFHQTtRQUVwQixJQUFJLENBQUNJLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBRUFDLFdBQVdDLElBQUksRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUU7UUFDakMsSUFBSSxDQUFDQyxlQUFlLENBQUNILE1BQU1FO0lBQy9CO0lBRUFFLE9BQU9GLFFBQVEsRUFBRTtRQUNiLElBQUksSUFBSSxDQUFDTixPQUFPLEVBQUU7WUFDZCwrREFBK0Q7WUFDL0QsT0FBTyxJQUFJLENBQUNPLGVBQWUsQ0FDdkI7Z0JBQ0lFLE1BQU07WUFDVixHQUNBSDtRQUVSO1FBQ0EsT0FBT0E7SUFDWDtJQUVBQyxnQkFBZ0JILElBQUksRUFBRUUsUUFBUSxFQUFFO1FBQzVCLElBQUksSUFBSSxDQUFDTixPQUFPLElBQUlJLEtBQUtLLElBQUksS0FBSyxRQUFRO1lBQ3RDLGdCQUFnQjtZQUNoQixJQUFJLENBQUNDLElBQUksQ0FBQ047WUFDVixJQUFJLENBQUMsSUFBSSxDQUFDSixPQUFPLENBQUNXLEtBQUssQ0FBQ1AsS0FBS1EsS0FBSyxHQUFHO2dCQUNqQyxPQUFPLElBQUksQ0FBQ1osT0FBTyxDQUFDYSxJQUFJLENBQUMsU0FBU1A7WUFDdEMsT0FBTztnQkFDSCxPQUFPQTtZQUNYO1FBQ0osT0FBTyxJQUFJLElBQUksQ0FBQ04sT0FBTyxJQUFJSSxLQUFLSyxJQUFJLEtBQUssUUFBUTtZQUM3QyxpQkFBaUI7WUFDakIscUVBQXFFO1lBQ3JFLDBFQUEwRTtZQUMxRSxvQkFBb0I7WUFFcEIsSUFBSUssYUFBYTtnQkFDYixJQUFJLENBQUNaLFFBQVEsR0FBRztnQkFDaEIsSUFBSSxDQUFDRixPQUFPLEdBQUc7Z0JBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUc7Z0JBQ25CLElBQUksQ0FBQ00sZUFBZSxDQUFDSCxNQUFNRTtZQUMvQjtZQUVBLElBQUksSUFBSSxDQUFDTCxXQUFXLEVBQUU7Z0JBQ2xCYyxhQUFhRDtZQUNqQixPQUFPO2dCQUNILElBQUksQ0FBQ1osUUFBUSxHQUFHLElBQU1ZO1lBQzFCO1lBRUEsT0FBTyxJQUFJLENBQUNkLE9BQU8sQ0FBQ2dCLEdBQUc7UUFDM0IsT0FBTyxJQUFJWixLQUFLSyxJQUFJLEtBQUssVUFBVSxJQUFJLENBQUNkLFVBQVUsQ0FBQ1MsT0FBTztZQUN0RCxJQUFJLENBQUNNLElBQUksQ0FBQ047WUFDViwwQ0FBMEM7WUFDMUMsSUFBSSxDQUFDYSxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUNDLGFBQWEsQ0FBQ2Q7UUFDekMsT0FBTyxJQUFJLElBQUksQ0FBQ2UsUUFBUSxJQUFJZixLQUFLSyxJQUFJLEtBQUssUUFBUTtZQUM5QyxpRUFBaUU7WUFDakUsSUFBSSxDQUFDQyxJQUFJLENBQUNOO1FBQ2Q7UUFDQUU7SUFDSjtJQUVBWSxjQUFjRSxJQUFJLEVBQUU7UUFDaEIsSUFBSSxDQUFDcEIsT0FBTyxHQUFHb0IsS0FBS0MsVUFBVTtRQUU5QixJQUFJckIsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDMUJBLFFBQVFzQixRQUFRLEdBQUc7UUFFbkIsSUFBSSxVQUFVQyxJQUFJLENBQUNILEtBQUtJLFdBQVcsS0FBS0osS0FBS0ssTUFBTSxFQUFFO1lBQ2pELElBQUlDLGNBQWMxQjtZQUNsQkEsVUFBVSxJQUFJUixjQUFjO2dCQUN4Qm1DLE9BQU9QLEtBQUtPLEtBQUs7WUFDckI7WUFDQUQsWUFBWUUsRUFBRSxDQUFDLFNBQVNDLENBQUFBO2dCQUNwQjdCLFFBQVFpQixJQUFJLENBQUMsU0FBU1k7WUFDMUI7WUFDQUgsWUFBWUksSUFBSSxDQUFDOUI7UUFDckI7UUFFQSxPQUFPO1lBQ0hvQjtZQUNBcEI7WUFDQStCLE1BQU07Z0JBQ0YsSUFBSSxPQUFPLElBQUksQ0FBQzdCLFFBQVEsS0FBSyxZQUFZO29CQUNyQyx3Q0FBd0M7b0JBQ3hDLElBQUksQ0FBQ0EsUUFBUTtnQkFDakIsT0FBTztvQkFDSCwwQ0FBMEM7b0JBQzFDLElBQUksQ0FBQ0QsV0FBVyxHQUFHO2dCQUN2QjtZQUNKO1FBQ0o7SUFDSjtBQUNKO0FBRUErQixPQUFPQyxPQUFPLEdBQUd4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0FTV0QgQ2xpZW50IEh1Yi8uL25vZGVfbW9kdWxlcy9Aem9uZS1ldS9tYWlsc3BsaXQvbGliL25vZGUtc3RyZWFtZXIuanM/OGQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIEhlbHBlciBjbGFzcyB0byByZXdyaXRlIG5vZGVzIHdpdGggc3BlY2lmaWMgbWltZSB0eXBlXG5cbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbmNvbnN0IEZsb3dlZERlY29kZXIgPSByZXF1aXJlKCcuL2Zsb3dlZC1kZWNvZGVyJyk7XG5cbi8qKlxuICogTm9kZVJld3JpdGVyIFRyYW5zZm9ybSBzdHJlYW0uIFVwZGF0ZXMgY29udGVudCBmb3IgYWxsIG5vZGVzIHdpdGggc3BlY2lmaWVkIG1pbWUgdHlwZVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIERlZmluZSB0aGUgTWltZS1UeXBlIHRvIGxvb2sgZm9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJlYW1BY3Rpb24gRnVuY3Rpb24gdG8gcnVuIHdpdGggdGhlIG5vZGUgY29udGVudFxuICovXG5jbGFzcyBOb2RlU3RyZWFtZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlckZ1bmMsIHN0cmVhbUFjdGlvbikge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmZpbHRlckZ1bmMgPSBmaWx0ZXJGdW5jO1xuICAgICAgICB0aGlzLnN0cmVhbUFjdGlvbiA9IHN0cmVhbUFjdGlvbjtcblxuICAgICAgICB0aGlzLmRlY29kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5Db250aW51ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRpbnVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzSW5jb21pbmcoZGF0YSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIF9mbHVzaChjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5kZWNvZGVyKSB7XG4gICAgICAgICAgICAvLyBlbWl0IGFuIGVtcHR5IG5vZGUganVzdCBpbiBjYXNlIHRoZXJlIGlzIHBlbmRpbmcgZGF0YSB0byBlbmRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NJbmNvbWluZyhcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdub25lJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0luY29taW5nKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmRlY29kZXIgJiYgZGF0YS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIGRhdGEgdG8gcGFyc2VcbiAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5kZWNvZGVyLndyaXRlKGRhdGEudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5vbmNlKCdkcmFpbicsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWNvZGVyICYmIGRhdGEudHlwZSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBzdG9wIGRlY29kaW5nLlxuICAgICAgICAgICAgLy8gd2UgY2FuIG5vdCBwcm9jZXNzIHRoZSBjdXJyZW50IGRhdGEgY2h1bmsgYXMgd2UgbmVlZCB0byB3YWl0IHVudGlsXG4gICAgICAgICAgICAvLyB0aGUgcGFyc2VkIGRhdGEgaXMgY29tcGxldGVseSBwcm9jZXNzZWQsIHNvIHdlIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAgICAgICAgICAgLy8gY29udGludWUgY2FsbGJhY2tcblxuICAgICAgICAgICAgbGV0IGRvQ29udGludWUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuQ29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbmNvbWluZyhkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShkb0NvbnRpbnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZSA9ICgpID0+IGRvQ29udGludWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5lbmQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdub2RlJyAmJiB0aGlzLmZpbHRlckZ1bmMoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChkYXRhKTtcbiAgICAgICAgICAgIC8vIGZvdW5kIG1hdGNoaW5nIG5vZGUsIGNyZWF0ZSBuZXcgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdub2RlJywgdGhpcy5jcmVhdGVEZWNvZGVyKGRhdGEpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlYWRhYmxlICYmIGRhdGEudHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgZGF0YSwganVzdCBwYXNzIGl0IG92ZXIgdG8gdGhlIGpvaW5lclxuICAgICAgICAgICAgdGhpcy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVjb2Rlcihub2RlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5vZGUuZ2V0RGVjb2RlcigpO1xuXG4gICAgICAgIGxldCBkZWNvZGVyID0gdGhpcy5kZWNvZGVyO1xuICAgICAgICBkZWNvZGVyLiRyZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKC9edGV4dFxcLy8udGVzdChub2RlLmNvbnRlbnRUeXBlKSAmJiBub2RlLmZsb3dlZCkge1xuICAgICAgICAgICAgbGV0IGZsb3dEZWNvZGVyID0gZGVjb2RlcjtcbiAgICAgICAgICAgIGRlY29kZXIgPSBuZXcgRmxvd2VkRGVjb2Rlcih7XG4gICAgICAgICAgICAgICAgZGVsU3A6IG5vZGUuZGVsU3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmxvd0RlY29kZXIub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBkZWNvZGVyLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmxvd0RlY29kZXIucGlwZShkZWNvZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgZGVjb2RlcixcbiAgICAgICAgICAgIGRvbmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGludWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIG9uY2UgaW5wdXQgc3RyZWFtIGlzIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGVkIGJlZm9yZSBpbnB1dCBzdHJlYW0gaXMgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuQ29udGludWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVN0cmVhbWVyO1xuIl0sIm5hbWVzIjpbIlRyYW5zZm9ybSIsInJlcXVpcmUiLCJGbG93ZWREZWNvZGVyIiwiTm9kZVN0cmVhbWVyIiwiY29uc3RydWN0b3IiLCJmaWx0ZXJGdW5jIiwic3RyZWFtQWN0aW9uIiwib3B0aW9ucyIsInJlYWRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImRlY29kZXIiLCJjYW5Db250aW51ZSIsImNvbnRpbnVlIiwiX3RyYW5zZm9ybSIsImRhdGEiLCJlbmNvZGluZyIsImNhbGxiYWNrIiwicHJvY2Vzc0luY29taW5nIiwiX2ZsdXNoIiwidHlwZSIsInB1c2giLCJ3cml0ZSIsInZhbHVlIiwib25jZSIsImRvQ29udGludWUiLCJzZXRJbW1lZGlhdGUiLCJlbmQiLCJlbWl0IiwiY3JlYXRlRGVjb2RlciIsInJlYWRhYmxlIiwibm9kZSIsImdldERlY29kZXIiLCIkcmVhZGluZyIsInRlc3QiLCJjb250ZW50VHlwZSIsImZsb3dlZCIsImZsb3dEZWNvZGVyIiwiZGVsU3AiLCJvbiIsImVyciIsInBpcGUiLCJkb25lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@zone-eu/mailsplit/lib/node-streamer.js\n");

/***/ })

};
;