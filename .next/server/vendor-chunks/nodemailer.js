"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nodemailer";
exports.ids = ["vendor-chunks/nodemailer"];
exports.modules = {

/***/ "(rsc)/./node_modules/nodemailer/lib/addressparser/index.js":
/*!************************************************************!*\
  !*** ./node_modules/nodemailer/lib/addressparser/index.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n/**\n * Converts tokens for a single address into an address object\n *\n * @param {Array} tokens Tokens object\n * @param {Number} depth Current recursion depth for nested group protection\n * @return {Object} Address object\n */ function _handleAddress(tokens, depth) {\n    let isGroup = false;\n    let state = \"text\";\n    let address;\n    let addresses = [];\n    let data = {\n        address: [],\n        comment: [],\n        group: [],\n        text: [],\n        textWasQuoted: [] // Track which text tokens came from inside quotes\n    };\n    let i;\n    let len;\n    let insideQuotes = false; // Track if we're currently inside a quoted string\n    // Filter out <addresses>, (comments) and regular text\n    for(i = 0, len = tokens.length; i < len; i++){\n        let token = tokens[i];\n        let prevToken = i ? tokens[i - 1] : null;\n        if (token.type === \"operator\") {\n            switch(token.value){\n                case \"<\":\n                    state = \"address\";\n                    insideQuotes = false;\n                    break;\n                case \"(\":\n                    state = \"comment\";\n                    insideQuotes = false;\n                    break;\n                case \":\":\n                    state = \"group\";\n                    isGroup = true;\n                    insideQuotes = false;\n                    break;\n                case '\"':\n                    // Track quote state for text tokens\n                    insideQuotes = !insideQuotes;\n                    state = \"text\";\n                    break;\n                default:\n                    state = \"text\";\n                    insideQuotes = false;\n                    break;\n            }\n        } else if (token.value) {\n            if (state === \"address\") {\n                // handle use case where unquoted name includes a \"<\"\n                // Apple Mail truncates everything between an unexpected < and an address\n                // and so will we\n                token.value = token.value.replace(/^[^<]*<\\s*/, \"\");\n            }\n            if (prevToken && prevToken.noBreak && data[state].length) {\n                // join values\n                data[state][data[state].length - 1] += token.value;\n                if (state === \"text\" && insideQuotes) {\n                    data.textWasQuoted[data.textWasQuoted.length - 1] = true;\n                }\n            } else {\n                data[state].push(token.value);\n                if (state === \"text\") {\n                    data.textWasQuoted.push(insideQuotes);\n                }\n            }\n        }\n    }\n    // If there is no text but a comment, replace the two\n    if (!data.text.length && data.comment.length) {\n        data.text = data.comment;\n        data.comment = [];\n    }\n    if (isGroup) {\n        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3\n        data.text = data.text.join(\" \");\n        // Parse group members, but flatten any nested groups (RFC 5322 doesn't allow nesting)\n        let groupMembers = [];\n        if (data.group.length) {\n            let parsedGroup = addressparser(data.group.join(\",\"), {\n                _depth: depth + 1\n            });\n            // Flatten: if any member is itself a group, extract its members into the sequence\n            parsedGroup.forEach((member)=>{\n                if (member.group) {\n                    // Nested group detected - flatten it by adding its members directly\n                    groupMembers = groupMembers.concat(member.group);\n                } else {\n                    groupMembers.push(member);\n                }\n            });\n        }\n        addresses.push({\n            name: data.text || address && address.name,\n            group: groupMembers\n        });\n    } else {\n        // If no address was found, try to detect one from regular text\n        if (!data.address.length && data.text.length) {\n            for(i = data.text.length - 1; i >= 0; i--){\n                // Security fix: Do not extract email addresses from quoted strings\n                // RFC 5321 allows @ inside quoted local-parts like \"user@domain\"@example.com\n                // Extracting emails from quoted text leads to misrouting vulnerabilities\n                if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\\s]+@[^@\\s]+$/)) {\n                    data.address = data.text.splice(i, 1);\n                    data.textWasQuoted.splice(i, 1);\n                    break;\n                }\n            }\n            let _regexHandler = function(address) {\n                if (!data.address.length) {\n                    data.address = [\n                        address.trim()\n                    ];\n                    return \" \";\n                } else {\n                    return address;\n                }\n            };\n            // still no address\n            if (!data.address.length) {\n                for(i = data.text.length - 1; i >= 0; i--){\n                    // Security fix: Do not extract email addresses from quoted strings\n                    if (!data.textWasQuoted[i]) {\n                        // fixed the regex to parse email address correctly when email address has more than one @\n                        data.text[i] = data.text[i].replace(/\\s*\\b[^@\\s]+@[^\\s]+\\b\\s*/, _regexHandler).trim();\n                        if (data.address.length) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        // If there's still is no text but a comment exixts, replace the two\n        if (!data.text.length && data.comment.length) {\n            data.text = data.comment;\n            data.comment = [];\n        }\n        // Keep only the first address occurence, push others to regular text\n        if (data.address.length > 1) {\n            data.text = data.text.concat(data.address.splice(1));\n        }\n        // Join values with spaces\n        data.text = data.text.join(\" \");\n        data.address = data.address.join(\" \");\n        if (!data.address && isGroup) {\n            return [];\n        } else {\n            address = {\n                address: data.address || data.text || \"\",\n                name: data.text || data.address || \"\"\n            };\n            if (address.address === address.name) {\n                if ((address.address || \"\").match(/@/)) {\n                    address.name = \"\";\n                } else {\n                    address.address = \"\";\n                }\n            }\n            addresses.push(address);\n        }\n    }\n    return addresses;\n}\n/**\n * Creates a Tokenizer object for tokenizing address field strings\n *\n * @constructor\n * @param {String} str Address field string\n */ class Tokenizer {\n    constructor(str){\n        this.str = (str || \"\").toString();\n        this.operatorCurrent = \"\";\n        this.operatorExpecting = \"\";\n        this.node = null;\n        this.escaped = false;\n        this.list = [];\n        /**\n         * Operator tokens and which tokens are expected to end the sequence\n         */ this.operators = {\n            '\"': '\"',\n            \"(\": \")\",\n            \"<\": \">\",\n            \",\": \"\",\n            \":\": \";\",\n            // Semicolons are not a legal delimiter per the RFC2822 grammar other\n            // than for terminating a group, but they are also not valid for any\n            // other use in this context.  Given that some mail clients have\n            // historically allowed the semicolon as a delimiter equivalent to the\n            // comma in their UI, it makes sense to treat them the same as a comma\n            // when used outside of a group.\n            \";\": \"\"\n        };\n    }\n    /**\n     * Tokenizes the original input string\n     *\n     * @return {Array} An array of operator|text tokens\n     */ tokenize() {\n        let list = [];\n        for(let i = 0, len = this.str.length; i < len; i++){\n            let chr = this.str.charAt(i);\n            let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;\n            this.checkChar(chr, nextChr);\n        }\n        this.list.forEach((node)=>{\n            node.value = (node.value || \"\").toString().trim();\n            if (node.value) {\n                list.push(node);\n            }\n        });\n        return list;\n    }\n    /**\n     * Checks if a character is an operator or text and acts accordingly\n     *\n     * @param {String} chr Character from the address field\n     */ checkChar(chr, nextChr) {\n        if (this.escaped) {\n        // ignore next condition blocks\n        } else if (chr === this.operatorExpecting) {\n            this.node = {\n                type: \"operator\",\n                value: chr\n            };\n            if (nextChr && ![\n                \" \",\n                \"\t\",\n                \"\\r\",\n                \"\\n\",\n                \",\",\n                \";\"\n            ].includes(nextChr)) {\n                this.node.noBreak = true;\n            }\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = \"\";\n            this.escaped = false;\n            return;\n        } else if (!this.operatorExpecting && chr in this.operators) {\n            this.node = {\n                type: \"operator\",\n                value: chr\n            };\n            this.list.push(this.node);\n            this.node = null;\n            this.operatorExpecting = this.operators[chr];\n            this.escaped = false;\n            return;\n        } else if ([\n            '\"',\n            \"'\"\n        ].includes(this.operatorExpecting) && chr === \"\\\\\") {\n            this.escaped = true;\n            return;\n        }\n        if (!this.node) {\n            this.node = {\n                type: \"text\",\n                value: \"\"\n            };\n            this.list.push(this.node);\n        }\n        if (chr === \"\\n\") {\n            // Convert newlines to spaces. Carriage return is ignored as \\r and \\n usually\n            // go together anyway and there already is a WS for \\n. Lone \\r means something is fishy.\n            chr = \" \";\n        }\n        if (chr.charCodeAt(0) >= 0x21 || [\n            \" \",\n            \"\t\"\n        ].includes(chr)) {\n            // skip command bytes\n            this.node.value += chr;\n        }\n        this.escaped = false;\n    }\n}\n/**\n * Maximum recursion depth for parsing nested groups.\n * RFC 5322 doesn't allow nested groups, so this is a safeguard against\n * malicious input that could cause stack overflow.\n */ const MAX_NESTED_GROUP_DEPTH = 50;\n/**\n * Parses structured e-mail addresses from an address field\n *\n * Example:\n *\n *    'Name <address@domain>'\n *\n * will be converted to\n *\n *     [{name: 'Name', address: 'address@domain'}]\n *\n * @param {String} str Address field\n * @param {Object} options Optional options object\n * @param {Number} options._depth Internal recursion depth counter (do not set manually)\n * @return {Array} An array of address objects\n */ function addressparser(str, options) {\n    options = options || {};\n    let depth = options._depth || 0;\n    // Prevent stack overflow from deeply nested groups (DoS protection)\n    if (depth > MAX_NESTED_GROUP_DEPTH) {\n        return [];\n    }\n    let tokenizer = new Tokenizer(str);\n    let tokens = tokenizer.tokenize();\n    let addresses = [];\n    let address = [];\n    let parsedAddresses = [];\n    tokens.forEach((token)=>{\n        if (token.type === \"operator\" && (token.value === \",\" || token.value === \";\")) {\n            if (address.length) {\n                addresses.push(address);\n            }\n            address = [];\n        } else {\n            address.push(token);\n        }\n    });\n    if (address.length) {\n        addresses.push(address);\n    }\n    addresses.forEach((address)=>{\n        address = _handleAddress(address, depth);\n        if (address.length) {\n            parsedAddresses = parsedAddresses.concat(address);\n        }\n    });\n    if (options.flatten) {\n        let addresses = [];\n        let walkAddressList = (list)=>{\n            list.forEach((address)=>{\n                if (address.group) {\n                    return walkAddressList(address.group);\n                } else {\n                    addresses.push(address);\n                }\n            });\n        };\n        walkAddressList(parsedAddresses);\n        return addresses;\n    }\n    return parsedAddresses;\n}\n// expose to the world\nmodule.exports = addressparser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9saWIvYWRkcmVzc3BhcnNlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNBLGVBQWVDLE1BQU0sRUFBRUMsS0FBSztJQUNqQyxJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsUUFBUTtJQUNaLElBQUlDO0lBQ0osSUFBSUMsWUFBWSxFQUFFO0lBQ2xCLElBQUlDLE9BQU87UUFDUEYsU0FBUyxFQUFFO1FBQ1hHLFNBQVMsRUFBRTtRQUNYQyxPQUFPLEVBQUU7UUFDVEMsTUFBTSxFQUFFO1FBQ1JDLGVBQWUsRUFBRSxDQUFDLGtEQUFrRDtJQUN4RTtJQUNBLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQyxlQUFlLE9BQU8sa0RBQWtEO0lBRTVFLHNEQUFzRDtJQUN0RCxJQUFLRixJQUFJLEdBQUdDLE1BQU1aLE9BQU9jLE1BQU0sRUFBRUgsSUFBSUMsS0FBS0QsSUFBSztRQUMzQyxJQUFJSSxRQUFRZixNQUFNLENBQUNXLEVBQUU7UUFDckIsSUFBSUssWUFBWUwsSUFBSVgsTUFBTSxDQUFDVyxJQUFJLEVBQUUsR0FBRztRQUNwQyxJQUFJSSxNQUFNRSxJQUFJLEtBQUssWUFBWTtZQUMzQixPQUFRRixNQUFNRyxLQUFLO2dCQUNmLEtBQUs7b0JBQ0RmLFFBQVE7b0JBQ1JVLGVBQWU7b0JBQ2Y7Z0JBQ0osS0FBSztvQkFDRFYsUUFBUTtvQkFDUlUsZUFBZTtvQkFDZjtnQkFDSixLQUFLO29CQUNEVixRQUFRO29CQUNSRCxVQUFVO29CQUNWVyxlQUFlO29CQUNmO2dCQUNKLEtBQUs7b0JBQ0Qsb0NBQW9DO29CQUNwQ0EsZUFBZSxDQUFDQTtvQkFDaEJWLFFBQVE7b0JBQ1I7Z0JBQ0o7b0JBQ0lBLFFBQVE7b0JBQ1JVLGVBQWU7b0JBQ2Y7WUFDUjtRQUNKLE9BQU8sSUFBSUUsTUFBTUcsS0FBSyxFQUFFO1lBQ3BCLElBQUlmLFVBQVUsV0FBVztnQkFDckIscURBQXFEO2dC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VVQsUUFBUTtJQUUvQixJQUFJeEMsWUFBWSxFQUFFO0lBQ2xCLElBQUlELFVBQVUsRUFBRTtJQUNoQixJQUFJbUQsa0JBQWtCLEVBQUU7SUFFeEJ2RCxPQUFPMkIsT0FBTyxDQUFDWixDQUFBQTtRQUNYLElBQUlBLE1BQU1FLElBQUksS0FBSyxjQUFlRixDQUFBQSxNQUFNRyxLQUFLLEtBQUssT0FBT0gsTUFBTUcsS0FBSyxLQUFLLEdBQUUsR0FBSTtZQUMzRSxJQUFJZCxRQUFRVSxNQUFNLEVBQUU7Z0JBQ2hCVCxVQUFVZ0IsSUFBSSxDQUFDakI7WUFDbkI7WUFDQUEsVUFBVSxFQUFFO1FBQ2hCLE9BQU87WUFDSEEsUUFBUWlCLElBQUksQ0FBQ047UUFDakI7SUFDSjtJQUVBLElBQUlYLFFBQVFVLE1BQU0sRUFBRTtRQUNoQlQsVUFBVWdCLElBQUksQ0FBQ2pCO0lBQ25CO0lBRUFDLFVBQVVzQixPQUFPLENBQUN2QixDQUFBQTtRQUNkQSxVQUFVTCxlQUFlSyxTQUFTSDtRQUNsQyxJQUFJRyxRQUFRVSxNQUFNLEVBQUU7WUFDaEJ5QyxrQkFBa0JBLGdCQUFnQjFCLE1BQU0sQ0FBQ3pCO1FBQzdDO0lBQ0o7SUFFQSxJQUFJaUQsUUFBUUcsT0FBTyxFQUFFO1FBQ2pCLElBQUluRCxZQUFZLEVBQUU7UUFDbEIsSUFBSW9ELGtCQUFrQmQsQ0FBQUE7WUFDbEJBLEtBQUtoQixPQUFPLENBQUN2QixDQUFBQTtnQkFDVCxJQUFJQSxRQUFRSSxLQUFLLEVBQUU7b0JBQ2YsT0FBT2lELGdCQUFnQnJELFFBQVFJLEtBQUs7Z0JBQ3hDLE9BQU87b0JBQ0hILFVBQVVnQixJQUFJLENBQUNqQjtnQkFDbkI7WUFDSjtRQUNKO1FBQ0FxRCxnQkFBZ0JGO1FBQ2hCLE9BQU9sRDtJQUNYO0lBRUEsT0FBT2tEO0FBQ1g7QUFFQSxzQkFBc0I7QUFDdEJHLE9BQU9DLE9BQU8sR0FBR2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQVNXRCBDbGllbnQgSHViLy4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL2FkZHJlc3NwYXJzZXIvaW5kZXguanM/YzVjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29udmVydHMgdG9rZW5zIGZvciBhIHNpbmdsZSBhZGRyZXNzIGludG8gYW4gYWRkcmVzcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbnMgVG9rZW5zIG9iamVjdFxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIEN1cnJlbnQgcmVjdXJzaW9uIGRlcHRoIGZvciBuZXN0ZWQgZ3JvdXAgcHJvdGVjdGlvblxuICogQHJldHVybiB7T2JqZWN0fSBBZGRyZXNzIG9iamVjdFxuICovXG5mdW5jdGlvbiBfaGFuZGxlQWRkcmVzcyh0b2tlbnMsIGRlcHRoKSB7XG4gICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcbiAgICBsZXQgc3RhdGUgPSAndGV4dCc7XG4gICAgbGV0IGFkZHJlc3M7XG4gICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgIGxldCBkYXRhID0ge1xuICAgICAgICBhZGRyZXNzOiBbXSxcbiAgICAgICAgY29tbWVudDogW10sXG4gICAgICAgIGdyb3VwOiBbXSxcbiAgICAgICAgdGV4dDogW10sXG4gICAgICAgIHRleHRXYXNRdW90ZWQ6IFtdIC8vIFRyYWNrIHdoaWNoIHRleHQgdG9rZW5zIGNhbWUgZnJvbSBpbnNpZGUgcXVvdGVzXG4gICAgfTtcbiAgICBsZXQgaTtcbiAgICBsZXQgbGVuO1xuICAgIGxldCBpbnNpZGVRdW90ZXMgPSBmYWxzZTsgLy8gVHJhY2sgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIHF1b3RlZCBzdHJpbmdcblxuICAgIC8vIEZpbHRlciBvdXQgPGFkZHJlc3Nlcz4sIChjb21tZW50cykgYW5kIHJlZ3VsYXIgdGV4dFxuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGxldCBwcmV2VG9rZW4gPSBpID8gdG9rZW5zW2kgLSAxXSA6IG51bGw7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2FkZHJlc3MnO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2NvbW1lbnQnO1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2dyb3VwJztcbiAgICAgICAgICAgICAgICAgICAgaXNHcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHF1b3RlIHN0YXRlIGZvciB0ZXh0IHRva2Vuc1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGVRdW90ZXMgPSAhaW5zaWRlUXVvdGVzO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9ICd0ZXh0JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdXNlIGNhc2Ugd2hlcmUgdW5xdW90ZWQgbmFtZSBpbmNsdWRlcyBhIFwiPFwiXG4gICAgICAgICAgICAgICAgLy8gQXBwbGUgTWFpbCB0cnVuY2F0ZXMgZXZlcnl0aGluZyBiZXR3ZWVuIGFuIHVuZXhwZWN0ZWQgPCBhbmQgYW4gYWRkcmVzc1xuICAgICAgICAgICAgICAgIC8vIGFuZCBzbyB3aWxsIHdlXG4gICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi52YWx1ZS5yZXBsYWNlKC9eW148XSo8XFxzKi8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZUb2tlbiAmJiBwcmV2VG9rZW4ubm9CcmVhayAmJiBkYXRhW3N0YXRlXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBqb2luIHZhbHVlc1xuICAgICAgICAgICAgICAgIGRhdGFbc3RhdGVdW2RhdGFbc3RhdGVdLmxlbmd0aCAtIDFdICs9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3RleHQnICYmIGluc2lkZVF1b3Rlcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRleHRXYXNRdW90ZWRbZGF0YS50ZXh0V2FzUXVvdGVkLmxlbmd0aCAtIDFdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFbc3RhdGVdLnB1c2godG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFdhc1F1b3RlZC5wdXNoKGluc2lkZVF1b3Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdGV4dCBidXQgYSBjb21tZW50LCByZXBsYWNlIHRoZSB0d29cbiAgICBpZiAoIWRhdGEudGV4dC5sZW5ndGggJiYgZGF0YS5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICBkYXRhLnRleHQgPSBkYXRhLmNvbW1lbnQ7XG4gICAgICAgIGRhdGEuY29tbWVudCA9IFtdO1xuICAgIH1cblxuICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjYXBwZW5kaXgtQS4xLjNcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS50ZXh0LmpvaW4oJyAnKTtcblxuICAgICAgICAvLyBQYXJzZSBncm91cCBtZW1iZXJzLCBidXQgZmxhdHRlbiBhbnkgbmVzdGVkIGdyb3VwcyAoUkZDIDUzMjIgZG9lc24ndCBhbGxvdyBuZXN0aW5nKVxuICAgICAgICBsZXQgZ3JvdXBNZW1iZXJzID0gW107XG4gICAgICAgIGlmIChkYXRhLmdyb3VwLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZEdyb3VwID0gYWRkcmVzc3BhcnNlcihkYXRhLmdyb3VwLmpvaW4oJywnKSwgeyBfZGVwdGg6IGRlcHRoICsgMSB9KTtcbiAgICAgICAgICAgIC8vIEZsYXR0ZW46IGlmIGFueSBtZW1iZXIgaXMgaXRzZWxmIGEgZ3JvdXAsIGV4dHJhY3QgaXRzIG1lbWJlcnMgaW50byB0aGUgc2VxdWVuY2VcbiAgICAgICAgICAgIHBhcnNlZEdyb3VwLmZvckVhY2gobWVtYmVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWVtYmVyLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5lc3RlZCBncm91cCBkZXRlY3RlZCAtIGZsYXR0ZW4gaXQgYnkgYWRkaW5nIGl0cyBtZW1iZXJzIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwTWVtYmVycyA9IGdyb3VwTWVtYmVycy5jb25jYXQobWVtYmVyLmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cE1lbWJlcnMucHVzaChtZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogZGF0YS50ZXh0IHx8IChhZGRyZXNzICYmIGFkZHJlc3MubmFtZSksXG4gICAgICAgICAgICBncm91cDogZ3JvdXBNZW1iZXJzXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vIGFkZHJlc3Mgd2FzIGZvdW5kLCB0cnkgdG8gZGV0ZWN0IG9uZSBmcm9tIHJlZ3VsYXIgdGV4dFxuICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5sZW5ndGggJiYgZGF0YS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChpID0gZGF0YS50ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VjdXJpdHkgZml4OiBEbyBub3QgZXh0cmFjdCBlbWFpbCBhZGRyZXNzZXMgZnJvbSBxdW90ZWQgc3RyaW5nc1xuICAgICAgICAgICAgICAgIC8vIFJGQyA1MzIxIGFsbG93cyBAIGluc2lkZSBxdW90ZWQgbG9jYWwtcGFydHMgbGlrZSBcInVzZXJAZG9tYWluXCJAZXhhbXBsZS5jb21cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0aW5nIGVtYWlscyBmcm9tIHF1b3RlZCB0ZXh0IGxlYWRzIHRvIG1pc3JvdXRpbmcgdnVsbmVyYWJpbGl0aWVzXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLnRleHRXYXNRdW90ZWRbaV0gJiYgZGF0YS50ZXh0W2ldLm1hdGNoKC9eW15AXFxzXStAW15AXFxzXSskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0gZGF0YS50ZXh0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0V2FzUXVvdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgX3JlZ2V4SGFuZGxlciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuYWRkcmVzcyA9IFthZGRyZXNzLnRyaW0oKV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnICc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gc3RpbGwgbm8gYWRkcmVzc1xuICAgICAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gZGF0YS50ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlY3VyaXR5IGZpeDogRG8gbm90IGV4dHJhY3QgZW1haWwgYWRkcmVzc2VzIGZyb20gcXVvdGVkIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnRleHRXYXNRdW90ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeGVkIHRoZSByZWdleCB0byBwYXJzZSBlbWFpbCBhZGRyZXNzIGNvcnJlY3RseSB3aGVuIGVtYWlsIGFkZHJlc3MgaGFzIG1vcmUgdGhhbiBvbmUgQFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0W2ldID0gZGF0YS50ZXh0W2ldLnJlcGxhY2UoL1xccypcXGJbXkBcXHNdK0BbXlxcc10rXFxiXFxzKi8sIF9yZWdleEhhbmRsZXIpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIGlzIG5vIHRleHQgYnV0IGEgY29tbWVudCBleGl4dHMsIHJlcGxhY2UgdGhlIHR3b1xuICAgICAgICBpZiAoIWRhdGEudGV4dC5sZW5ndGggJiYgZGF0YS5jb21tZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS5jb21tZW50O1xuICAgICAgICAgICAgZGF0YS5jb21tZW50ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIG9ubHkgdGhlIGZpcnN0IGFkZHJlc3Mgb2NjdXJlbmNlLCBwdXNoIG90aGVycyB0byByZWd1bGFyIHRleHRcbiAgICAgICAgaWYgKGRhdGEuYWRkcmVzcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkYXRhLnRleHQgPSBkYXRhLnRleHQuY29uY2F0KGRhdGEuYWRkcmVzcy5zcGxpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSm9pbiB2YWx1ZXMgd2l0aCBzcGFjZXNcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS50ZXh0LmpvaW4oJyAnKTtcbiAgICAgICAgZGF0YS5hZGRyZXNzID0gZGF0YS5hZGRyZXNzLmpvaW4oJyAnKTtcblxuICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcyAmJiBpc0dyb3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGRhdGEuYWRkcmVzcyB8fCBkYXRhLnRleHQgfHwgJycsXG4gICAgICAgICAgICAgICAgbmFtZTogZGF0YS50ZXh0IHx8IGRhdGEuYWRkcmVzcyB8fCAnJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGFkZHJlc3MuYWRkcmVzcyA9PT0gYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKChhZGRyZXNzLmFkZHJlc3MgfHwgJycpLm1hdGNoKC9ALykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5uYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5hZGRyZXNzID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhZGRyZXNzZXM7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuaXplciBvYmplY3QgZm9yIHRva2VuaXppbmcgYWRkcmVzcyBmaWVsZCBzdHJpbmdzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIEFkZHJlc3MgZmllbGQgc3RyaW5nXG4gKi9cbmNsYXNzIFRva2VuaXplciB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHRoaXMuc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5vcGVyYXRvckN1cnJlbnQgPSAnJztcbiAgICAgICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9ICcnO1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmxpc3QgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wZXJhdG9yIHRva2VucyBhbmQgd2hpY2ggdG9rZW5zIGFyZSBleHBlY3RlZCB0byBlbmQgdGhlIHNlcXVlbmNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9wZXJhdG9ycyA9IHtcbiAgICAgICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICAgICAnKCc6ICcpJyxcbiAgICAgICAgICAgICc8JzogJz4nLFxuICAgICAgICAgICAgJywnOiAnJyxcbiAgICAgICAgICAgICc6JzogJzsnLFxuICAgICAgICAgICAgLy8gU2VtaWNvbG9ucyBhcmUgbm90IGEgbGVnYWwgZGVsaW1pdGVyIHBlciB0aGUgUkZDMjgyMiBncmFtbWFyIG90aGVyXG4gICAgICAgICAgICAvLyB0aGFuIGZvciB0ZXJtaW5hdGluZyBhIGdyb3VwLCBidXQgdGhleSBhcmUgYWxzbyBub3QgdmFsaWQgZm9yIGFueVxuICAgICAgICAgICAgLy8gb3RoZXIgdXNlIGluIHRoaXMgY29udGV4dC4gIEdpdmVuIHRoYXQgc29tZSBtYWlsIGNsaWVudHMgaGF2ZVxuICAgICAgICAgICAgLy8gaGlzdG9yaWNhbGx5IGFsbG93ZWQgdGhlIHNlbWljb2xvbiBhcyBhIGRlbGltaXRlciBlcXVpdmFsZW50IHRvIHRoZVxuICAgICAgICAgICAgLy8gY29tbWEgaW4gdGhlaXIgVUksIGl0IG1ha2VzIHNlbnNlIHRvIHRyZWF0IHRoZW0gdGhlIHNhbWUgYXMgYSBjb21tYVxuICAgICAgICAgICAgLy8gd2hlbiB1c2VkIG91dHNpZGUgb2YgYSBncm91cC5cbiAgICAgICAgICAgICc7JzogJydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZXMgdGhlIG9yaWdpbmFsIGlucHV0IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG9wZXJhdG9yfHRleHQgdG9rZW5zXG4gICAgICovXG4gICAgdG9rZW5pemUoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hyID0gdGhpcy5zdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgbGV0IG5leHRDaHIgPSBpIDwgbGVuIC0gMSA/IHRoaXMuc3RyLmNoYXJBdChpICsgMSkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGVja0NoYXIoY2hyLCBuZXh0Q2hyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IChub2RlLnZhbHVlIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaXMgYW4gb3BlcmF0b3Igb3IgdGV4dCBhbmQgYWN0cyBhY2NvcmRpbmdseVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNociBDaGFyYWN0ZXIgZnJvbSB0aGUgYWRkcmVzcyBmaWVsZFxuICAgICAqL1xuICAgIGNoZWNrQ2hhcihjaHIsIG5leHRDaHIpIHtcbiAgICAgICAgaWYgKHRoaXMuZXNjYXBlZCkge1xuICAgICAgICAgICAgLy8gaWdub3JlIG5leHQgY29uZGl0aW9uIGJsb2Nrc1xuICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gdGhpcy5vcGVyYXRvckV4cGVjdGluZykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5leHRDaHIgJiYgIVsnICcsICdcXHQnLCAnXFxyJywgJ1xcbicsICcsJywgJzsnXS5pbmNsdWRlcyhuZXh0Q2hyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5ub0JyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yRXhwZWN0aW5nID0gJyc7XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wZXJhdG9yRXhwZWN0aW5nICYmIGNociBpbiB0aGlzLm9wZXJhdG9ycykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdvcGVyYXRvcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubGlzdC5wdXNoKHRoaXMubm9kZSk7XG4gICAgICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9IHRoaXMub3BlcmF0b3JzW2Nocl07XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChbJ1wiJywgXCInXCJdLmluY2x1ZGVzKHRoaXMub3BlcmF0b3JFeHBlY3RpbmcpICYmIGNociA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB0aGlzLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaHIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IG5ld2xpbmVzIHRvIHNwYWNlcy4gQ2FycmlhZ2UgcmV0dXJuIGlzIGlnbm9yZWQgYXMgXFxyIGFuZCBcXG4gdXN1YWxseVxuICAgICAgICAgICAgLy8gZ28gdG9nZXRoZXIgYW55d2F5IGFuZCB0aGVyZSBhbHJlYWR5IGlzIGEgV1MgZm9yIFxcbi4gTG9uZSBcXHIgbWVhbnMgc29tZXRoaW5nIGlzIGZpc2h5LlxuICAgICAgICAgICAgY2hyID0gJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoci5jaGFyQ29kZUF0KDApID49IDB4MjEgfHwgWycgJywgJ1xcdCddLmluY2x1ZGVzKGNocikpIHtcbiAgICAgICAgICAgIC8vIHNraXAgY29tbWFuZCBieXRlc1xuICAgICAgICAgICAgdGhpcy5ub2RlLnZhbHVlICs9IGNocjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBNYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aCBmb3IgcGFyc2luZyBuZXN0ZWQgZ3JvdXBzLlxuICogUkZDIDUzMjIgZG9lc24ndCBhbGxvdyBuZXN0ZWQgZ3JvdXBzLCBzbyB0aGlzIGlzIGEgc2FmZWd1YXJkIGFnYWluc3RcbiAqIG1hbGljaW91cyBpbnB1dCB0aGF0IGNvdWxkIGNhdXNlIHN0YWNrIG92ZXJmbG93LlxuICovXG5jb25zdCBNQVhfTkVTVEVEX0dST1VQX0RFUFRIID0gNTA7XG5cbi8qKlxuICogUGFyc2VzIHN0cnVjdHVyZWQgZS1tYWlsIGFkZHJlc3NlcyBmcm9tIGFuIGFkZHJlc3MgZmllbGRcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICdOYW1lIDxhZGRyZXNzQGRvbWFpbj4nXG4gKlxuICogd2lsbCBiZSBjb252ZXJ0ZWQgdG9cbiAqXG4gKiAgICAgW3tuYW1lOiAnTmFtZScsIGFkZHJlc3M6ICdhZGRyZXNzQGRvbWFpbid9XVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQWRkcmVzcyBmaWVsZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLl9kZXB0aCBJbnRlcm5hbCByZWN1cnNpb24gZGVwdGggY291bnRlciAoZG8gbm90IHNldCBtYW51YWxseSlcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBhZGRyZXNzIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gYWRkcmVzc3BhcnNlcihzdHIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgZGVwdGggPSBvcHRpb25zLl9kZXB0aCB8fCAwO1xuXG4gICAgLy8gUHJldmVudCBzdGFjayBvdmVyZmxvdyBmcm9tIGRlZXBseSBuZXN0ZWQgZ3JvdXBzIChEb1MgcHJvdGVjdGlvbilcbiAgICBpZiAoZGVwdGggPiBNQVhfTkVTVEVEX0dST1VQX0RFUFRIKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcihzdHIpO1xuICAgIGxldCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoKTtcblxuICAgIGxldCBhZGRyZXNzZXMgPSBbXTtcbiAgICBsZXQgYWRkcmVzcyA9IFtdO1xuICAgIGxldCBwYXJzZWRBZGRyZXNzZXMgPSBbXTtcblxuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgKHRva2VuLnZhbHVlID09PSAnLCcgfHwgdG9rZW4udmFsdWUgPT09ICc7JykpIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgIH1cblxuICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGFkZHJlc3MgPT4ge1xuICAgICAgICBhZGRyZXNzID0gX2hhbmRsZUFkZHJlc3MoYWRkcmVzcywgZGVwdGgpO1xuICAgICAgICBpZiAoYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnNlZEFkZHJlc3NlcyA9IHBhcnNlZEFkZHJlc3Nlcy5jb25jYXQoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBsZXQgd2Fsa0FkZHJlc3NMaXN0ID0gbGlzdCA9PiB7XG4gICAgICAgICAgICBsaXN0LmZvckVhY2goYWRkcmVzcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtBZGRyZXNzTGlzdChhZGRyZXNzLmdyb3VwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2Fsa0FkZHJlc3NMaXN0KHBhcnNlZEFkZHJlc3Nlcyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZEFkZHJlc3Nlcztcbn1cblxuLy8gZXhwb3NlIHRvIHRoZSB3b3JsZFxubW9kdWxlLmV4cG9ydHMgPSBhZGRyZXNzcGFyc2VyO1xuIl0sIm5hbWVzIjpbIl9oYW5kbGVBZGRyZXNzIiwidG9rZW5zIiwiZGVwdGgiLCJpc0dyb3VwIiwic3RhdGUiLCJhZGRyZXNzIiwiYWRkcmVzc2VzIiwiZGF0YSIsImNvbW1lbnQiLCJncm91cCIsInRleHQiLCJ0ZXh0V2FzUXVvdGVkIiwiaSIsImxlbiIsImluc2lkZVF1b3RlcyIsImxlbmd0aCIsInRva2VuIiwicHJldlRva2VuIiwidHlwZSIsInZhbHVlIiwicmVwbGFjZSIsIm5vQnJlYWsiLCJwdXNoIiwiam9pbiIsImdyb3VwTWVtYmVycyIsInBhcnNlZEdyb3VwIiwiYWRkcmVzc3BhcnNlciIsIl9kZXB0aCIsImZvckVhY2giLCJtZW1iZXIiLCJjb25jYXQiLCJuYW1lIiwibWF0Y2giLCJzcGxpY2UiLCJfcmVnZXhIYW5kbGVyIiwidHJpbSIsIlRva2VuaXplciIsImNvbnN0cnVjdG9yIiwic3RyIiwidG9TdHJpbmciLCJvcGVyYXRvckN1cnJlbnQiLCJvcGVyYXRvckV4cGVjdGluZyIsIm5vZGUiLCJlc2NhcGVkIiwibGlzdCIsIm9wZXJhdG9ycyIsInRva2VuaXplIiwiY2hyIiwiY2hhckF0IiwibmV4dENociIsImNoZWNrQ2hhciIsImluY2x1ZGVzIiwiY2hhckNvZGVBdCIsIk1BWF9ORVNURURfR1JPVVBfREVQVEgiLCJvcHRpb25zIiwidG9rZW5pemVyIiwicGFyc2VkQWRkcmVzc2VzIiwiZmxhdHRlbiIsIndhbGtBZGRyZXNzTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer/lib/addressparser/index.js\n");

/***/ })

};
;