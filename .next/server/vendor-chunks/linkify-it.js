"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/linkify-it";
exports.ids = ["vendor-chunks/linkify-it"];
exports.modules = {

/***/ "(rsc)/./node_modules/linkify-it/build/index.cjs.js":
/*!****************************************************!*\
  !*** ./node_modules/linkify-it/build/index.cjs.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar uc_micro = __webpack_require__(/*! uc.micro */ \"(rsc)/./node_modules/uc.micro/build/index.cjs.js\");\nfunction reFactory(opts) {\n    const re = {};\n    opts = opts || {};\n    re.src_Any = uc_micro.Any.source;\n    re.src_Cc = uc_micro.Cc.source;\n    re.src_Z = uc_micro.Z.source;\n    re.src_P = uc_micro.P.source;\n    // \\p{\\Z\\P\\Cc\\CF} (white spaces + control + format + punctuation)\n    re.src_ZPCc = [\n        re.src_Z,\n        re.src_P,\n        re.src_Cc\n    ].join(\"|\");\n    // \\p{\\Z\\Cc} (white spaces + control)\n    re.src_ZCc = [\n        re.src_Z,\n        re.src_Cc\n    ].join(\"|\");\n    // Experimental. List of chars, completely prohibited in links\n    // because can separate it from other part of text\n    const text_separators = \"[><｜]\";\n    // All possible word characters (everything without punctuation, spaces & controls)\n    // Defined via punctuation & spaces to save space\n    // Should be something like \\p{\\L\\N\\S\\M} (\\w but without `_`)\n    re.src_pseudo_letter = \"(?:(?!\" + text_separators + \"|\" + re.src_ZPCc + \")\" + re.src_Any + \")\";\n    // The same as abothe but without [0-9]\n    // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';\n    re.src_ip4 = \"(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\";\n    // Prohibit any of \"@/[]()\" in user/pass to avoid wrong domain fetch.\n    re.src_auth = \"(?:(?:(?!\" + re.src_ZCc + \"|[@/\\\\[\\\\]()]).)+@)?\";\n    re.src_port = \"(?::(?:6(?:[0-4]\\\\d{3}|5(?:[0-4]\\\\d{2}|5(?:[0-2]\\\\d|3[0-5])))|[1-5]?\\\\d{1,4}))?\";\n    re.src_host_terminator = \"(?=$|\" + text_separators + \"|\" + re.src_ZPCc + \")\" + \"(?!\" + (opts[\"---\"] ? \"-(?!--)|\" : \"-|\") + \"_|:\\\\d|\\\\.-|\\\\.(?!$|\" + re.src_ZPCc + \"))\";\n    re.src_path = \"(?:\" + \"[/?#]\" + \"(?:\" + \"(?!\" + re.src_ZCc + \"|\" + text_separators + \"|[()[\\\\]{}.,\\\"'?!\\\\-;]).|\" + \"\\\\[(?:(?!\" + re.src_ZCc + \"|\\\\]).)*\\\\]|\" + \"\\\\((?:(?!\" + re.src_ZCc + \"|[)]).)*\\\\)|\" + \"\\\\{(?:(?!\" + re.src_ZCc + \"|[}]).)*\\\\}|\" + '\\\\\"(?:(?!' + re.src_ZCc + '|[\"]).)+\\\\\"|' + \"\\\\'(?:(?!\" + re.src_ZCc + \"|[']).)+\\\\'|\" + // allow `I'm_king` if no pair found\n    \"\\\\'(?=\" + re.src_pseudo_letter + \"|[-])|\" + // google has many dots in \"google search\" links (#66, #81).\n    // github has ... in commit range links,\n    // Restrict to\n    // - english\n    // - percent-encoded\n    // - parts of file path\n    // - params separator\n    // until more examples found.\n    \"\\\\.{2,}[a-zA-Z0-9%/&]|\" + \"\\\\.(?!\" + re.src_ZCc + \"|[.]|$)|\" + (opts[\"---\"] ? \"\\\\-(?!--(?:[^-]|$))(?:-*)|\" // `---` => long dash, terminate\n     : \"\\\\-+|\") + // allow `,,,` in paths\n    \",(?!\" + re.src_ZCc + \"|$)|\" + // allow `;` if not followed by space-like char\n    \";(?!\" + re.src_ZCc + \"|$)|\" + // allow `!!!` in paths, but not at the end\n    \"\\\\!+(?!\" + re.src_ZCc + \"|[!]|$)|\" + \"\\\\?(?!\" + re.src_ZCc + \"|[?]|$)\" + \")+\" + \"|\\\\/\" + \")?\";\n    // Allow anything in markdown spec, forbid quote (\") at the first position\n    // because emails enclosed in quotes are far more common\n    re.src_email_name = '[\\\\-;:&=\\\\+\\\\$,\\\\.a-zA-Z0-9_][\\\\-;:&=\\\\+\\\\$,\\\\\"\\\\.a-zA-Z0-9_]*';\n    re.src_xn = \"xn--[a-z0-9\\\\-]{1,59}\";\n    // More to read about domain names\n    // http://serverfault.com/questions/638260/\n    re.src_domain_root = // Allow letters & digits (http://test1)\n    \"(?:\" + re.src_xn + \"|\" + re.src_pseudo_letter + \"{1,63}\" + \")\";\n    re.src_domain = \"(?:\" + re.src_xn + \"|\" + \"(?:\" + re.src_pseudo_letter + \")\" + \"|\" + \"(?:\" + re.src_pseudo_letter + \"(?:-|\" + re.src_pseudo_letter + \"){0,61}\" + re.src_pseudo_letter + \")\" + \")\";\n    re.src_host = \"(?:\" + // Don't need IP check, because digits are already allowed in normal domain names\n    //   src_ip4 +\n    // '|' +\n    \"(?:(?:(?:\" + re.src_domain + \")\\\\.)*\" + re.src_domain /* _root */  + \")\" + \")\";\n    re.tpl_host_fuzzy = \"(?:\" + re.src_ip4 + \"|\" + \"(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%))\" + \")\";\n    re.tpl_host_no_ip_fuzzy = \"(?:(?:(?:\" + re.src_domain + \")\\\\.)+(?:%TLDS%))\";\n    re.src_host_strict = re.src_host + re.src_host_terminator;\n    re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;\n    re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;\n    re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;\n    re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;\n    //\n    // Main rules\n    //\n    // Rude test fuzzy links by host, for quick deny\n    re.tpl_host_fuzzy_test = \"localhost|www\\\\.|\\\\.\\\\d{1,3}\\\\.|(?:\\\\.(?:%TLDS%)(?:\" + re.src_ZPCc + \"|>|$))\";\n    re.tpl_email_fuzzy = \"(^|\" + text_separators + '|\"|\\\\(|' + re.src_ZCc + \")\" + \"(\" + re.src_email_name + \"@\" + re.tpl_host_fuzzy_strict + \")\";\n    re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n    // but can start with > (markdown blockquote)\n    \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|｜]|\" + re.src_ZPCc + \"))\" + \"((?![$+<=>^`|｜])\" + re.tpl_host_port_fuzzy_strict + re.src_path + \")\";\n    re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\\- and non punctuation.\n    // but can start with > (markdown blockquote)\n    \"(^|(?![.:/\\\\-_@])(?:[$+<=>^`|｜]|\" + re.src_ZPCc + \"))\" + \"((?![$+<=>^`|｜])\" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + \")\";\n    return re;\n}\n//\n// Helpers\n//\n// Merge objects\n//\nfunction assign(obj /* from1, from2, from3, ... */ ) {\n    const sources = Array.prototype.slice.call(arguments, 1);\n    sources.forEach(function(source) {\n        if (!source) {\n            return;\n        }\n        Object.keys(source).forEach(function(key) {\n            obj[key] = source[key];\n        });\n    });\n    return obj;\n}\nfunction _class(obj) {\n    return Object.prototype.toString.call(obj);\n}\nfunction isString(obj) {\n    return _class(obj) === \"[object String]\";\n}\nfunction isObject(obj) {\n    return _class(obj) === \"[object Object]\";\n}\nfunction isRegExp(obj) {\n    return _class(obj) === \"[object RegExp]\";\n}\nfunction isFunction(obj) {\n    return _class(obj) === \"[object Function]\";\n}\nfunction escapeRE(str) {\n    return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n}\n//\nconst defaultOptions = {\n    fuzzyLink: true,\n    fuzzyEmail: true,\n    fuzzyIP: false\n};\nfunction isOptionsObj(obj) {\n    return Object.keys(obj || {}).reduce(function(acc, k) {\n        /* eslint-disable-next-line no-prototype-builtins */ return acc || defaultOptions.hasOwnProperty(k);\n    }, false);\n}\nconst defaultSchemas = {\n    \"http:\": {\n        validate: function(text, pos, self) {\n            const tail = text.slice(pos);\n            if (!self.re.http) {\n                // compile lazily, because \"host\"-containing variables can change on tlds update.\n                self.re.http = new RegExp(\"^\\\\/\\\\/\" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, \"i\");\n            }\n            if (self.re.http.test(tail)) {\n                return tail.match(self.re.http)[0].length;\n            }\n            return 0;\n        }\n    },\n    \"https:\": \"http:\",\n    \"ftp:\": \"http:\",\n    \"//\": {\n        validate: function(text, pos, self) {\n            const tail = text.slice(pos);\n            if (!self.re.no_http) {\n                // compile lazily, because \"host\"-containing variables can change on tlds update.\n                self.re.no_http = new RegExp(\"^\" + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'\n                // with code comments\n                \"(?:localhost|(?:(?:\" + self.re.src_domain + \")\\\\.)+\" + self.re.src_domain_root + \")\" + self.re.src_port + self.re.src_host_terminator + self.re.src_path, \"i\");\n            }\n            if (self.re.no_http.test(tail)) {\n                // should not be `://` & `///`, that protects from errors in protocol name\n                if (pos >= 3 && text[pos - 3] === \":\") {\n                    return 0;\n                }\n                if (pos >= 3 && text[pos - 3] === \"/\") {\n                    return 0;\n                }\n                return tail.match(self.re.no_http)[0].length;\n            }\n            return 0;\n        }\n    },\n    \"mailto:\": {\n        validate: function(text, pos, self) {\n            const tail = text.slice(pos);\n            if (!self.re.mailto) {\n                self.re.mailto = new RegExp(\"^\" + self.re.src_email_name + \"@\" + self.re.src_host_strict, \"i\");\n            }\n            if (self.re.mailto.test(tail)) {\n                return tail.match(self.re.mailto)[0].length;\n            }\n            return 0;\n        }\n    }\n};\n// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)\n/* eslint-disable-next-line max-len */ const tlds_2ch_src_re = \"a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]\";\n// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead\nconst tlds_default = \"biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф\".split(\"|\");\nfunction resetScanCache(self) {\n    self.__index__ = -1;\n    self.__text_cache__ = \"\";\n}\nfunction createValidator(re) {\n    return function(text, pos) {\n        const tail = text.slice(pos);\n        if (re.test(tail)) {\n            return tail.match(re)[0].length;\n        }\n        return 0;\n    };\n}\nfunction createNormalizer() {\n    return function(match, self) {\n        self.normalize(match);\n    };\n}\n// Schemas compiler. Build regexps.\n//\nfunction compile(self) {\n    // Load & clone RE patterns.\n    const re = self.re = reFactory(self.__opts__);\n    // Define dynamic patterns\n    const tlds = self.__tlds__.slice();\n    self.onCompile();\n    if (!self.__tlds_replaced__) {\n        tlds.push(tlds_2ch_src_re);\n    }\n    tlds.push(re.src_xn);\n    re.src_tlds = tlds.join(\"|\");\n    function untpl(tpl) {\n        return tpl.replace(\"%TLDS%\", re.src_tlds);\n    }\n    re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), \"i\");\n    re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), \"i\");\n    re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), \"i\");\n    re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), \"i\");\n    //\n    // Compile each schema\n    //\n    const aliases = [];\n    self.__compiled__ = {}; // Reset compiled data\n    function schemaError(name, val) {\n        throw new Error('(LinkifyIt) Invalid schema \"' + name + '\": ' + val);\n    }\n    Object.keys(self.__schemas__).forEach(function(name) {\n        const val = self.__schemas__[name];\n        // skip disabled methods\n        if (val === null) {\n            return;\n        }\n        const compiled = {\n            validate: null,\n            link: null\n        };\n        self.__compiled__[name] = compiled;\n        if (isObject(val)) {\n            if (isRegExp(val.validate)) {\n                compiled.validate = createValidator(val.validate);\n            } else if (isFunction(val.validate)) {\n                compiled.validate = val.validate;\n            } else {\n                schemaError(name, val);\n            }\n            if (isFunction(val.normalize)) {\n                compiled.normalize = val.normalize;\n            } else if (!val.normalize) {\n                compiled.normalize = createNormalizer();\n            } else {\n                schemaError(name, val);\n            }\n            return;\n        }\n        if (isString(val)) {\n            aliases.push(name);\n            return;\n        }\n        schemaError(name, val);\n    });\n    //\n    // Compile postponed aliases\n    //\n    aliases.forEach(function(alias) {\n        if (!self.__compiled__[self.__schemas__[alias]]) {\n            // Silently fail on missed schemas to avoid errons on disable.\n            // schemaError(alias, self.__schemas__[alias]);\n            return;\n        }\n        self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;\n        self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;\n    });\n    //\n    // Fake record for guessed links\n    //\n    self.__compiled__[\"\"] = {\n        validate: null,\n        normalize: createNormalizer()\n    };\n    //\n    // Build schema condition\n    //\n    const slist = Object.keys(self.__compiled__).filter(function(name) {\n        // Filter disabled & fake schemas\n        return name.length > 0 && self.__compiled__[name];\n    }).map(escapeRE).join(\"|\");\n    // (?!_) cause 1.5x slowdown\n    self.re.schema_test = RegExp(\"(^|(?!_)(?:[><｜]|\" + re.src_ZPCc + \"))(\" + slist + \")\", \"i\");\n    self.re.schema_search = RegExp(\"(^|(?!_)(?:[><｜]|\" + re.src_ZPCc + \"))(\" + slist + \")\", \"ig\");\n    self.re.schema_at_start = RegExp(\"^\" + self.re.schema_search.source, \"i\");\n    self.re.pretest = RegExp(\"(\" + self.re.schema_test.source + \")|(\" + self.re.host_fuzzy_test.source + \")|@\", \"i\");\n    //\n    // Cleanup\n    //\n    resetScanCache(self);\n}\n/**\n * class Match\n *\n * Match result. Single element of array, returned by [[LinkifyIt#match]]\n **/ function Match(self, shift) {\n    const start = self.__index__;\n    const end = self.__last_index__;\n    const text = self.__text_cache__.slice(start, end);\n    /**\n   * Match#schema -> String\n   *\n   * Prefix (protocol) for matched string.\n   **/ this.schema = self.__schema__.toLowerCase();\n    /**\n   * Match#index -> Number\n   *\n   * First position of matched string.\n   **/ this.index = start + shift;\n    /**\n   * Match#lastIndex -> Number\n   *\n   * Next position after matched string.\n   **/ this.lastIndex = end + shift;\n    /**\n   * Match#raw -> String\n   *\n   * Matched string.\n   **/ this.raw = text;\n    /**\n   * Match#text -> String\n   *\n   * Notmalized text of matched string.\n   **/ this.text = text;\n    /**\n   * Match#url -> String\n   *\n   * Normalized url of matched string.\n   **/ this.url = text;\n}\nfunction createMatch(self, shift) {\n    const match = new Match(self, shift);\n    self.__compiled__[match.schema].normalize(match, self);\n    return match;\n}\n/**\n * class LinkifyIt\n **/ /**\n * new LinkifyIt(schemas, options)\n * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Creates new linkifier instance with optional additional schemas.\n * Can be called without `new` keyword for convenience.\n *\n * By default understands:\n *\n * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links\n * - \"fuzzy\" links and emails (example.com, foo@bar.com).\n *\n * `schemas` is an object, where each key/value describes protocol/rule:\n *\n * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`\n *   for example). `linkify-it` makes shure that prefix is not preceeded with\n *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.\n * - __value__ - rule to check tail after link prefix\n *   - _String_ - just alias to existing rule\n *   - _Object_\n *     - _validate_ - validator function (should return matched length on success),\n *       or `RegExp`.\n *     - _normalize_ - optional function to normalize text & url of matched result\n *       (for example, for @twitter mentions).\n *\n * `options`:\n *\n * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.\n * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts\n *   like version numbers. Default `false`.\n * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.\n *\n **/ function LinkifyIt(schemas, options) {\n    if (!(this instanceof LinkifyIt)) {\n        return new LinkifyIt(schemas, options);\n    }\n    if (!options) {\n        if (isOptionsObj(schemas)) {\n            options = schemas;\n            schemas = {};\n        }\n    }\n    this.__opts__ = assign({}, defaultOptions, options);\n    // Cache last tested result. Used to skip repeating steps on next `match` call.\n    this.__index__ = -1;\n    this.__last_index__ = -1; // Next scan position\n    this.__schema__ = \"\";\n    this.__text_cache__ = \"\";\n    this.__schemas__ = assign({}, defaultSchemas, schemas);\n    this.__compiled__ = {};\n    this.__tlds__ = tlds_default;\n    this.__tlds_replaced__ = false;\n    this.re = {};\n    compile(this);\n}\n/** chainable\n * LinkifyIt#add(schema, definition)\n * - schema (String): rule name (fixed pattern prefix)\n * - definition (String|RegExp|Object): schema definition\n *\n * Add new rule definition. See constructor description for details.\n **/ LinkifyIt.prototype.add = function add(schema, definition) {\n    this.__schemas__[schema] = definition;\n    compile(this);\n    return this;\n};\n/** chainable\n * LinkifyIt#set(options)\n * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }\n *\n * Set recognition options for links without schema.\n **/ LinkifyIt.prototype.set = function set(options) {\n    this.__opts__ = assign(this.__opts__, options);\n    return this;\n};\n/**\n * LinkifyIt#test(text) -> Boolean\n *\n * Searches linkifiable pattern and returns `true` on success or `false` on fail.\n **/ LinkifyIt.prototype.test = function test(text) {\n    // Reset scan cache\n    this.__text_cache__ = text;\n    this.__index__ = -1;\n    if (!text.length) {\n        return false;\n    }\n    let m, ml, me, len, shift, next, re, tld_pos, at_pos;\n    // try to scan for link with schema - that's the most simple rule\n    if (this.re.schema_test.test(text)) {\n        re = this.re.schema_search;\n        re.lastIndex = 0;\n        while((m = re.exec(text)) !== null){\n            len = this.testSchemaAt(text, m[2], re.lastIndex);\n            if (len) {\n                this.__schema__ = m[2];\n                this.__index__ = m.index + m[1].length;\n                this.__last_index__ = m.index + m[0].length + len;\n                break;\n            }\n        }\n    }\n    if (this.__opts__.fuzzyLink && this.__compiled__[\"http:\"]) {\n        // guess schemaless links\n        tld_pos = text.search(this.re.host_fuzzy_test);\n        if (tld_pos >= 0) {\n            // if tld is located after found link - no need to check fuzzy pattern\n            if (this.__index__ < 0 || tld_pos < this.__index__) {\n                if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {\n                    shift = ml.index + ml[1].length;\n                    if (this.__index__ < 0 || shift < this.__index__) {\n                        this.__schema__ = \"\";\n                        this.__index__ = shift;\n                        this.__last_index__ = ml.index + ml[0].length;\n                    }\n                }\n            }\n        }\n    }\n    if (this.__opts__.fuzzyEmail && this.__compiled__[\"mailto:\"]) {\n        // guess schemaless emails\n        at_pos = text.indexOf(\"@\");\n        if (at_pos >= 0) {\n            // We can't skip this check, because this cases are possible:\n            // 192.168.1.1@gmail.com, my.in@example.com\n            if ((me = text.match(this.re.email_fuzzy)) !== null) {\n                shift = me.index + me[1].length;\n                next = me.index + me[0].length;\n                if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {\n                    this.__schema__ = \"mailto:\";\n                    this.__index__ = shift;\n                    this.__last_index__ = next;\n                }\n            }\n        }\n    }\n    return this.__index__ >= 0;\n};\n/**\n * LinkifyIt#pretest(text) -> Boolean\n *\n * Very quick check, that can give false positives. Returns true if link MAY BE\n * can exists. Can be used for speed optimization, when you need to check that\n * link NOT exists.\n **/ LinkifyIt.prototype.pretest = function pretest(text) {\n    return this.re.pretest.test(text);\n};\n/**\n * LinkifyIt#testSchemaAt(text, name, position) -> Number\n * - text (String): text to scan\n * - name (String): rule (schema) name\n * - position (Number): text offset to check from\n *\n * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly\n * at given position. Returns length of found pattern (0 on fail).\n **/ LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {\n    // If not supported schema check requested - terminate\n    if (!this.__compiled__[schema.toLowerCase()]) {\n        return 0;\n    }\n    return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);\n};\n/**\n * LinkifyIt#match(text) -> Array|null\n *\n * Returns array of found link descriptions or `null` on fail. We strongly\n * recommend to use [[LinkifyIt#test]] first, for best speed.\n *\n * ##### Result match description\n *\n * - __schema__ - link schema, can be empty for fuzzy links, or `//` for\n *   protocol-neutral  links.\n * - __index__ - offset of matched text\n * - __lastIndex__ - index of next char after mathch end\n * - __raw__ - matched text\n * - __text__ - normalized text\n * - __url__ - link, generated from matched text\n **/ LinkifyIt.prototype.match = function match(text) {\n    const result = [];\n    let shift = 0;\n    // Try to take previous element from cache, if .test() called before\n    if (this.__index__ >= 0 && this.__text_cache__ === text) {\n        result.push(createMatch(this, shift));\n        shift = this.__last_index__;\n    }\n    // Cut head if cache was used\n    let tail = shift ? text.slice(shift) : text;\n    // Scan string until end reached\n    while(this.test(tail)){\n        result.push(createMatch(this, shift));\n        tail = tail.slice(this.__last_index__);\n        shift += this.__last_index__;\n    }\n    if (result.length) {\n        return result;\n    }\n    return null;\n};\n/**\n * LinkifyIt#matchAtStart(text) -> Match|null\n *\n * Returns fully-formed (not fuzzy) link if it starts at the beginning\n * of the string, and null otherwise.\n **/ LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {\n    // Reset scan cache\n    this.__text_cache__ = text;\n    this.__index__ = -1;\n    if (!text.length) return null;\n    const m = this.re.schema_at_start.exec(text);\n    if (!m) return null;\n    const len = this.testSchemaAt(text, m[2], m[0].length);\n    if (!len) return null;\n    this.__schema__ = m[2];\n    this.__index__ = m.index + m[1].length;\n    this.__last_index__ = m.index + m[0].length + len;\n    return createMatch(this, 0);\n};\n/** chainable\n * LinkifyIt#tlds(list [, keepOld]) -> this\n * - list (Array): list of tlds\n * - keepOld (Boolean): merge with current list if `true` (`false` by default)\n *\n * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)\n * to avoid false positives. By default this algorythm used:\n *\n * - hostname with any 2-letter root zones are ok.\n * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф\n *   are ok.\n * - encoded (`xn--...`) root zones are ok.\n *\n * If list is replaced, then exact match for 2-chars root zones will be checked.\n **/ LinkifyIt.prototype.tlds = function tlds(list, keepOld) {\n    list = Array.isArray(list) ? list : [\n        list\n    ];\n    if (!keepOld) {\n        this.__tlds__ = list.slice();\n        this.__tlds_replaced__ = true;\n        compile(this);\n        return this;\n    }\n    this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {\n        return el !== arr[idx - 1];\n    }).reverse();\n    compile(this);\n    return this;\n};\n/**\n * LinkifyIt#normalize(match)\n *\n * Default normalizer (if schema does not define it's own).\n **/ LinkifyIt.prototype.normalize = function normalize(match) {\n    // Do minimal possible changes by default. Need to collect feedback prior\n    // to move forward https://github.com/markdown-it/linkify-it/issues/1\n    if (!match.schema) {\n        match.url = \"http://\" + match.url;\n    }\n    if (match.schema === \"mailto:\" && !/^mailto:/i.test(match.url)) {\n        match.url = \"mailto:\" + match.url;\n    }\n};\n/**\n * LinkifyIt#onCompile()\n *\n * Override to modify basic RegExp-s.\n **/ LinkifyIt.prototype.onCompile = function onCompile() {};\nmodule.exports = LinkifyIt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGlua2lmeS1pdC9idWlsZC9pbmRleC5janMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxXQUFXQyxtQkFBT0EsQ0FBQztBQUV2QixTQUFTQyxVQUFXQyxJQUFJO0lBQ3RCLE1BQU1DLEtBQUssQ0FBQztJQUNaRCxPQUFPQSxRQUFRLENBQUM7SUFFaEJDLEdBQUdDLE9BQU8sR0FBR0wsU0FBU00sR0FBRyxDQUFDQyxNQUFNO0lBQ2hDSCxHQUFHSSxNQUFNLEdBQUdSLFNBQVNTLEVBQUUsQ0FBQ0YsTUFBTTtJQUM5QkgsR0FBR00sS0FBSyxHQUFHVixTQUFTVyxDQUFDLENBQUNKLE1BQU07SUFDNUJILEdBQUdRLEtBQUssR0FBR1osU0FBU2EsQ0FBQyxDQUFDTixNQUFNO0lBRTVCLGlFQUFpRTtJQUNqRUgsR0FBR1UsUUFBUSxHQUFHO1FBQUNWLEdBQUdNLEtBQUs7UUFBRU4sR0FBR1EsS0FBSztRQUFFUixHQUFHSSxNQUFNO0tBQUMsQ0FBQ08sSUFBSSxDQUFDO0lBRW5ELHFDQUFxQztJQUNyQ1gsR0FBR1ksT0FBTyxHQUFHO1FBQUNaLEdBQUdNLEtBQUs7UUFBRU4sR0FBR0ksTUFBTTtLQUFDLENBQUNPLElBQUksQ0FBQztJQUV4Qyw4REFBOEQ7SUFDOUQsa0RBQWtEO0lBQ2xELE1BQU1FLGtCQUFrQjtJQUV4QixtRkFBbUY7SUFDbkYsaURBQWlEO0lBQ2pELDZEQUE2RDtJQUM3RGIsR0FBR2MsaUJBQWlCLEdBQUcsV0FBV0Qsa0JBQWtCLE1BQU1iLEdBQUdVLFFBQVEsR0FBRyxNQUFNVixHQUFHQyxPQUFPLEdBQUc7SUFDM0YsdUNBQXVDO0lBQ3ZDLGlGQUFpRjtJQUVqRkQsR0FBR2UsT0FBTyxHQUVSO0lBRUYscUVBQXFFO0lBQ3JFZixHQUFHZ0IsUUFBUSxHQUFHLGNBQWNoQixHQUFHWSxPQUFPLEdBQUc7SUFFekNaLEdBQUdpQixRQUFRLEdBRVQ7SUFFRmpCLEdBQUdrQixtQkFBbUIsR0FFcEIsVUFBVUws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QUksQ0FBQzdELFFBQVEsR0FBRzRELEtBQUs5RyxLQUFLO1FBQzFCLElBQUksQ0FBQ29ELGlCQUFpQixHQUFHO1FBQ3pCTCxRQUFRLElBQUk7UUFDWixPQUFPLElBQUk7SUFDYjtJQUVBLElBQUksQ0FBQ0csUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUSxDQUFDK0QsTUFBTSxDQUFDSCxNQUNsQ0ksSUFBSSxHQUNKMUMsTUFBTSxDQUFDLFNBQVUyQyxFQUFFLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUM1QixPQUFPRixPQUFPRSxHQUFHLENBQUNELE1BQU0sRUFBRTtJQUM1QixHQUNDRSxPQUFPO0lBRVZ2RSxRQUFRLElBQUk7SUFDWixPQUFPLElBQUk7QUFDYjtBQUVBOzs7O0VBSUUsR0FDRjRDLFVBQVU1RixTQUFTLENBQUMrQyxTQUFTLEdBQUcsU0FBU0EsVUFBV1osS0FBSztJQUN2RCx5RUFBeUU7SUFDekUscUVBQXFFO0lBRXJFLElBQUksQ0FBQ0EsTUFBTWlELE1BQU0sRUFBRTtRQUFFakQsTUFBTXVELEdBQUcsR0FBRyxZQUFZdkQsTUFBTXVELEdBQUc7SUFBRTtJQUV4RCxJQUFJdkQsTUFBTWlELE1BQU0sS0FBSyxhQUFhLENBQUMsWUFBWWxELElBQUksQ0FBQ0MsTUFBTXVELEdBQUcsR0FBRztRQUM5RHZELE1BQU11RCxHQUFHLEdBQUcsWUFBWXZELE1BQU11RCxHQUFHO0lBQ25DO0FBQ0Y7QUFFQTs7OztFQUlFLEdBQ0ZFLFVBQVU1RixTQUFTLENBQUNvRCxTQUFTLEdBQUcsU0FBU0EsYUFDekM7QUFFQW9FLE9BQU9DLE9BQU8sR0FBRzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQVNXRCBDbGllbnQgSHViLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvYnVpbGQvaW5kZXguY2pzLmpzPzIzNDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdWNfbWljcm8gPSByZXF1aXJlKCd1Yy5taWNybycpO1xuXG5mdW5jdGlvbiByZUZhY3RvcnkgKG9wdHMpIHtcbiAgY29uc3QgcmUgPSB7fTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgcmUuc3JjX0FueSA9IHVjX21pY3JvLkFueS5zb3VyY2U7XG4gIHJlLnNyY19DYyA9IHVjX21pY3JvLkNjLnNvdXJjZTtcbiAgcmUuc3JjX1ogPSB1Y19taWNyby5aLnNvdXJjZTtcbiAgcmUuc3JjX1AgPSB1Y19taWNyby5QLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gW3JlLnNyY19aLCByZS5zcmNfUCwgcmUuc3JjX0NjXS5qb2luKCd8Jyk7XG5cbiAgLy8gXFxwe1xcWlxcQ2N9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sKVxuICByZS5zcmNfWkNjID0gW3JlLnNyY19aLCByZS5zcmNfQ2NdLmpvaW4oJ3wnKTtcblxuICAvLyBFeHBlcmltZW50YWwuIExpc3Qgb2YgY2hhcnMsIGNvbXBsZXRlbHkgcHJvaGliaXRlZCBpbiBsaW5rc1xuICAvLyBiZWNhdXNlIGNhbiBzZXBhcmF0ZSBpdCBmcm9tIG90aGVyIHBhcnQgb2YgdGV4dFxuICBjb25zdCB0ZXh0X3NlcGFyYXRvcnMgPSAnWz48XFx1ZmY1Y10nO1xuXG4gIC8vIEFsbCBwb3NzaWJsZSB3b3JkIGNoYXJhY3RlcnMgKGV2ZXJ5dGhpbmcgd2l0aG91dCBwdW5jdHVhdGlvbiwgc3BhY2VzICYgY29udHJvbHMpXG4gIC8vIERlZmluZWQgdmlhIHB1bmN0dWF0aW9uICYgc3BhY2VzIHRvIHNhdmUgc3BhY2VcbiAgLy8gU2hvdWxkIGJlIHNvbWV0aGluZyBsaWtlIFxccHtcXExcXE5cXFNcXE19IChcXHcgYnV0IHdpdGhvdXQgYF9gKVxuICByZS5zcmNfcHNldWRvX2xldHRlciA9ICcoPzooPyEnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKScgKyByZS5zcmNfQW55ICsgJyknO1xuICAvLyBUaGUgc2FtZSBhcyBhYm90aGUgYnV0IHdpdGhvdXQgWzAtOV1cbiAgLy8gdmFyIHNyY19wc2V1ZG9fbGV0dGVyX25vbl9kID0gJyg/Oig/IVswLTldfCcgKyBzcmNfWlBDYyArICcpJyArIHNyY19BbnkgKyAnKSc7XG5cbiAgcmUuc3JjX2lwNCA9XG5cbiAgICAnKD86KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXFxcLil7M30oMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSc7XG5cbiAgLy8gUHJvaGliaXQgYW55IG9mIFwiQC9bXSgpXCIgaW4gdXNlci9wYXNzIHRvIGF2b2lkIHdyb25nIGRvbWFpbiBmZXRjaC5cbiAgcmUuc3JjX2F1dGggPSAnKD86KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtAL1xcXFxbXFxcXF0oKV0pLikrQCk/JztcblxuICByZS5zcmNfcG9ydCA9XG5cbiAgICAnKD86Oig/OjYoPzpbMC00XVxcXFxkezN9fDUoPzpbMC00XVxcXFxkezJ9fDUoPzpbMC0yXVxcXFxkfDNbMC01XSkpKXxbMS01XT9cXFxcZHsxLDR9KSk/JztcblxuICByZS5zcmNfaG9zdF90ZXJtaW5hdG9yID1cblxuICAgICcoPz0kfCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArXG4gICAgJyg/IScgKyAob3B0c1snLS0tJ10gPyAnLSg/IS0tKXwnIDogJy18JykgKyAnX3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtO10pLnwnICtcbiAgICAgICAgICAnXFxcXFsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8XFxcXF0pLikqXFxcXF18JyArXG4gICAgICAgICAgJ1xcXFwoKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFspXSkuKSpcXFxcKXwnICtcbiAgICAgICAgICAnXFxcXHsoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W31dKS4pKlxcXFx9fCcgK1xuICAgICAgICAgICdcXFxcXCIoPzooPyEnICsgcmUuc3JjX1pDYyArICd8W1wiXSkuKStcXFxcXCJ8JyArXG4gICAgICAgICAgXCJcXFxcJyg/Oig/IVwiICsgcmUuc3JjX1pDYyArIFwifFsnXSkuKStcXFxcJ3xcIiArXG5cbiAgICAgICAgICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKXwnICtcblxuICAgICAgICAgIC8vIGdvb2dsZSBoYXMgbWFueSBkb3RzIGluIFwiZ29vZ2xlIHNlYXJjaFwiIGxpbmtzICgjNjYsICM4MSkuXG4gICAgICAgICAgLy8gZ2l0aHViIGhhcyAuLi4gaW4gY29tbWl0IHJhbmdlIGxpbmtzLFxuICAgICAgICAgIC8vIFJlc3RyaWN0IHRvXG4gICAgICAgICAgLy8gLSBlbmdsaXNoXG4gICAgICAgICAgLy8gLSBwZXJjZW50LWVuY29kZWRcbiAgICAgICAgICAvLyAtIHBhcnRzIG9mIGZpbGUgcGF0aFxuICAgICAgICAgIC8vIC0gcGFyYW1zIHNlcGFyYXRvclxuICAgICAgICAgIC8vIHVudGlsIG1vcmUgZXhhbXBsZXMgZm91bmQuXG4gICAgICAgICAgJ1xcXFwuezIsfVthLXpBLVowLTklLyZdfCcgK1xuXG4gICAgICAgICAgJ1xcXFwuKD8hJyArIHJlLnNyY19aQ2MgKyAnfFsuXXwkKXwnICtcbiAgICAgICAgICAob3B0c1snLS0tJ11cbiAgICAgICAgICAgID8gJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgICA6ICdcXFxcLSt8J1xuICAgICAgICAgICkgK1xuICAgICAgICAgIC8vIGFsbG93IGAsLCxgIGluIHBhdGhzXG4gICAgICAgICAgJywoPyEnICsgcmUuc3JjX1pDYyArICd8JCl8JyArXG5cbiAgICAgICAgICAvLyBhbGxvdyBgO2AgaWYgbm90IGZvbGxvd2VkIGJ5IHNwYWNlLWxpa2UgY2hhclxuICAgICAgICAgICc7KD8hJyArIHJlLnNyY19aQ2MgKyAnfCQpfCcgK1xuXG4gICAgICAgICAgLy8gYWxsb3cgYCEhIWAgaW4gcGF0aHMsIGJ1dCBub3QgYXQgdGhlIGVuZFxuICAgICAgICAgICdcXFxcISsoPyEnICsgcmUuc3JjX1pDYyArICd8WyFdfCQpfCcgK1xuXG4gICAgICAgICAgJ1xcXFw/KD8hJyArIHJlLnNyY19aQ2MgKyAnfFs/XXwkKScgK1xuICAgICAgICAnKSsnICtcbiAgICAgICd8XFxcXC8nICtcbiAgICAnKT8nO1xuXG4gIC8vIEFsbG93IGFueXRoaW5nIGluIG1hcmtkb3duIHNwZWMsIGZvcmJpZCBxdW90ZSAoXCIpIGF0IHRoZSBmaXJzdCBwb3NpdGlvblxuICAvLyBiZWNhdXNlIGVtYWlscyBlbmNsb3NlZCBpbiBxdW90ZXMgYXJlIGZhciBtb3JlIGNvbW1vblxuICByZS5zcmNfZW1haWxfbmFtZSA9XG5cbiAgICAnW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXC5hLXpBLVowLTlfXVtcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFxcIlxcXFwuYS16QS1aMC05X10qJztcblxuICByZS5zcmNfeG4gPVxuXG4gICAgJ3huLS1bYS16MC05XFxcXC1dezEsNTl9JztcblxuICAvLyBNb3JlIHRvIHJlYWQgYWJvdXQgZG9tYWluIG5hbWVzXG4gIC8vIGh0dHA6Ly9zZXJ2ZXJmYXVsdC5jb20vcXVlc3Rpb25zLzYzODI2MC9cblxuICByZS5zcmNfZG9tYWluX3Jvb3QgPVxuXG4gICAgLy8gQWxsb3cgbGV0dGVycyAmIGRpZ2l0cyAoaHR0cDovL3Rlc3QxKVxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnezEsNjN9JyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19kb21haW4gPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAgICd8JyArXG4gICAgICAnKD86JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyg/Oi18JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyl7MCw2MX0nICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICcpJztcblxuICByZS5zcmNfaG9zdCA9XG5cbiAgICAnKD86JyArXG4gICAgLy8gRG9uJ3QgbmVlZCBJUCBjaGVjaywgYmVjYXVzZSBkaWdpdHMgYXJlIGFscmVhZHkgYWxsb3dlZCBpbiBub3JtYWwgZG9tYWluIG5hbWVzXG4gICAgLy8gICBzcmNfaXA0ICtcbiAgICAvLyAnfCcgK1xuICAgICAgJyg/Oig/Oig/OicgKyByZS5zcmNfZG9tYWluICsgJylcXFxcLikqJyArIHJlLnNyY19kb21haW4vKiBfcm9vdCAqLyArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5ID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY19pcDQgK1xuICAgICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9XG5cbiAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKSc7XG5cbiAgcmUuc3JjX2hvc3Rfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIC8vXG4gIC8vIE1haW4gcnVsZXNcbiAgLy9cblxuICAvLyBSdWRlIHRlc3QgZnV6enkgbGlua3MgYnkgaG9zdCwgZm9yIHF1aWNrIGRlbnlcbiAgcmUudHBsX2hvc3RfZnV6enlfdGVzdCA9XG5cbiAgICAnbG9jYWxob3N0fHd3d1xcXFwufFxcXFwuXFxcXGR7MSwzfVxcXFwufCg/OlxcXFwuKD86JVRMRFMlKSg/OicgKyByZS5zcmNfWlBDYyArICd8PnwkKSknO1xuXG4gIHJlLnRwbF9lbWFpbF9mdXp6eSA9XG5cbiAgICAgICcoXnwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xcInxcXFxcKHwnICsgcmUuc3JjX1pDYyArICcpJyArXG4gICAgICAnKCcgKyByZS5zcmNfZW1haWxfbmFtZSArICdAJyArIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCArICcpJztcblxuICByZS50cGxfbGlua19mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZS50cGxfbGlua19ub19pcF9mdXp6eSA9XG4gICAgICAvLyBGdXp6eSBsaW5rIGNhbid0IGJlIHByZXBlbmRlZCB3aXRoIC46L1xcLSBhbmQgbm9uIHB1bmN0dWF0aW9uLlxuICAgICAgLy8gYnV0IGNhbiBzdGFydCB3aXRoID4gKG1hcmtkb3duIGJsb2NrcXVvdGUpXG4gICAgICAnKF58KD8hWy46L1xcXFwtX0BdKSg/OlskKzw9Pl5gfFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKScgK1xuICAgICAgJygoPyFbJCs8PT5eYHxcXHVmZjVjXSknICsgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgKyByZS5zcmNfcGF0aCArICcpJztcblxuICByZXR1cm4gcmVcbn1cblxuLy9cbi8vIEhlbHBlcnNcbi8vXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24gKG9iaiAvKiBmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4gKi8pIHtcbiAgY29uc3Qgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm4gfVxuXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gX2NsYXNzIChvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIH1cbmZ1bmN0aW9uIGlzU3RyaW5nIChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBTdHJpbmddJyB9XG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfVxuZnVuY3Rpb24gaXNSZWdFeHAgKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nIH1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfVxuXG5mdW5jdGlvbiBlc2NhcGVSRSAoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJykgfVxuXG4vL1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgZnV6enlMaW5rOiB0cnVlLFxuICBmdXp6eUVtYWlsOiB0cnVlLFxuICBmdXp6eUlQOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGspIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG4gICAgcmV0dXJuIGFjYyB8fCBkZWZhdWx0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrKVxuICB9LCBmYWxzZSlcbn1cblxuY29uc3QgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgY29uc3QgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLmh0dHApIHtcbiAgICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5odHRwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLmh0dHApWzBdLmxlbmd0aFxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH0sXG4gICdodHRwczonOiAnaHR0cDonLFxuICAnZnRwOic6ICdodHRwOicsXG4gICcvLyc6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgY29uc3QgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm5vX2h0dHApIHtcbiAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwIH1cbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICcvJykgeyByZXR1cm4gMCB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoXG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfSxcbiAgJ21haWx0bzonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIGNvbnN0IHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5tYWlsdG8pIHtcbiAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoXG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfVxufTtcblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlbiAqL1xuY29uc3QgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nO1xuXG4vLyBET04nVCB0cnkgdG8gbWFrZSBQUnMgd2l0aCBjaGFuZ2VzLiBFeHRlbmQgVExEcyB3aXRoIExpbmtpZnlJdC50bGRzKCkgaW5zdGVhZFxuY29uc3QgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG5mdW5jdGlvbiByZXNldFNjYW5DYWNoZSAoc2VsZikge1xuICBzZWxmLl9faW5kZXhfXyA9IC0xO1xuICBzZWxmLl9fdGV4dF9jYWNoZV9fID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvciAocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBwb3MpIHtcbiAgICBjb25zdCB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgc2VsZikge1xuICAgIHNlbGYubm9ybWFsaXplKG1hdGNoKTtcbiAgfVxufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUgKHNlbGYpIHtcbiAgLy8gTG9hZCAmIGNsb25lIFJFIHBhdHRlcm5zLlxuICBjb25zdCByZSA9IHNlbGYucmUgPSByZUZhY3Rvcnkoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgY29uc3QgdGxkcyA9IHNlbGYuX190bGRzX18uc2xpY2UoKTtcblxuICBzZWxmLm9uQ29tcGlsZSgpO1xuXG4gIGlmICghc2VsZi5fX3RsZHNfcmVwbGFjZWRfXykge1xuICAgIHRsZHMucHVzaCh0bGRzXzJjaF9zcmNfcmUpO1xuICB9XG4gIHRsZHMucHVzaChyZS5zcmNfeG4pO1xuXG4gIHJlLnNyY190bGRzID0gdGxkcy5qb2luKCd8Jyk7XG5cbiAgZnVuY3Rpb24gdW50cGwgKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKSB9XG5cbiAgcmUuZW1haWxfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgPSBSZWdFeHAodW50cGwocmUudHBsX2hvc3RfZnV6enlfdGVzdCksICdpJyk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBlYWNoIHNjaGVtYVxuICAvL1xuXG4gIGNvbnN0IGFsaWFzZXMgPSBbXTtcblxuICBzZWxmLl9fY29tcGlsZWRfXyA9IHt9OyAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IgKG5hbWUsIHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignKExpbmtpZnlJdCkgSW52YWxpZCBzY2hlbWEgXCInICsgbmFtZSArICdcIjogJyArIHZhbClcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBjb25zdCB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm4gfVxuXG4gICAgY29uc3QgY29tcGlsZWQgPSB7IHZhbGlkYXRlOiBudWxsLCBsaW5rOiBudWxsIH07XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwubm9ybWFsaXplKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IGNyZWF0ZU5vcm1hbGl6ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzY2hlbWFFcnJvcihuYW1lLCB2YWwpO1xuICB9KTtcblxuICAvL1xuICAvLyBDb21waWxlIHBvc3Rwb25lZCBhbGlhc2VzXG4gIC8vXG5cbiAgYWxpYXNlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgIGlmICghc2VsZi5fX2NvbXBpbGVkX19bc2VsZi5fX3NjaGVtYXNfX1thbGlhc11dKSB7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIG9uIG1pc3NlZCBzY2hlbWFzIHRvIGF2b2lkIGVycm9ucyBvbiBkaXNhYmxlLlxuICAgICAgLy8gc2NoZW1hRXJyb3IoYWxpYXMsIHNlbGYuX19zY2hlbWFzX19bYWxpYXNdKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLm5vcm1hbGl6ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICB9KTtcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9O1xuXG4gIC8vXG4gIC8vIEJ1aWxkIHNjaGVtYSBjb25kaXRpb25cbiAgLy9cbiAgY29uc3Qgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV1cbiAgICB9KVxuICAgIC5tYXAoZXNjYXBlUkUpXG4gICAgLmpvaW4oJ3wnKTtcbiAgLy8gKD8hXykgY2F1c2UgMS41eCBzbG93ZG93blxuICBzZWxmLnJlLnNjaGVtYV90ZXN0ID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcbiAgc2VsZi5yZS5zY2hlbWFfYXRfc3RhcnQgPSBSZWdFeHAoJ14nICsgc2VsZi5yZS5zY2hlbWFfc2VhcmNoLnNvdXJjZSwgJ2knKTtcblxuICBzZWxmLnJlLnByZXRlc3QgPSBSZWdFeHAoXG4gICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwoJyArIHNlbGYucmUuaG9zdF9mdXp6eV90ZXN0LnNvdXJjZSArICcpfEAnLFxuICAgICdpJ1xuICApO1xuXG4gIC8vXG4gIC8vIENsZWFudXBcbiAgLy9cblxuICByZXNldFNjYW5DYWNoZShzZWxmKTtcbn1cblxuLyoqXG4gKiBjbGFzcyBNYXRjaFxuICpcbiAqIE1hdGNoIHJlc3VsdC4gU2luZ2xlIGVsZW1lbnQgb2YgYXJyYXksIHJldHVybmVkIGJ5IFtbTGlua2lmeUl0I21hdGNoXV1cbiAqKi9cbmZ1bmN0aW9uIE1hdGNoIChzZWxmLCBzaGlmdCkge1xuICBjb25zdCBzdGFydCA9IHNlbGYuX19pbmRleF9fO1xuICBjb25zdCBlbmQgPSBzZWxmLl9fbGFzdF9pbmRleF9fO1xuICBjb25zdCB0ZXh0ID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ID0gc3RhcnQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI2xhc3RJbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmxhc3RJbmRleCA9IGVuZCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjcmF3IC0+IFN0cmluZ1xuICAgKlxuICAgKiBNYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnJhdyA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN0ZXh0IC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3RtYWxpemVkIHRleHQgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaCAoc2VsZiwgc2hpZnQpIHtcbiAgY29uc3QgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2hcbn1cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdCAoc2NoZW1hcywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTGlua2lmeUl0KSkge1xuICAgIHJldHVybiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gQ2FjaGUgbGFzdCB0ZXN0ZWQgcmVzdWx0LiBVc2VkIHRvIHNraXAgcmVwZWF0aW5nIHN0ZXBzIG9uIG5leHQgYG1hdGNoYCBjYWxsLlxuICB0aGlzLl9faW5kZXhfXyA9IC0xO1xuICB0aGlzLl9fbGFzdF9pbmRleF9fID0gLTE7IC8vIE5leHQgc2NhbiBwb3NpdGlvblxuICB0aGlzLl9fc2NoZW1hX18gPSAnJztcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9ICcnO1xuXG4gIHRoaXMuX19zY2hlbWFzX18gPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gPSB7fTtcblxuICB0aGlzLl9fdGxkc19fID0gdGxkc19kZWZhdWx0O1xuICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gZmFsc2U7XG5cbiAgdGhpcy5yZSA9IHt9O1xuXG4gIGNvbXBpbGUodGhpcyk7XG59XG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNhZGQoc2NoZW1hLCBkZWZpbml0aW9uKVxuICogLSBzY2hlbWEgKFN0cmluZyk6IHJ1bGUgbmFtZSAoZml4ZWQgcGF0dGVybiBwcmVmaXgpXG4gKiAtIGRlZmluaXRpb24gKFN0cmluZ3xSZWdFeHB8T2JqZWN0KTogc2NoZW1hIGRlZmluaXRpb25cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgZGVmaW5pdGlvbi4gU2VlIGNvbnN0cnVjdG9yIGRlc2NyaXB0aW9uIGZvciBkZXRhaWxzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpc1xufTtcblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChvcHRpb25zKSB7XG4gIHRoaXMuX19vcHRzX18gPSBhc3NpZ24odGhpcy5fX29wdHNfXywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzXG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCN0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBTZWFyY2hlcyBsaW5raWZpYWJsZSBwYXR0ZXJuIGFuZCByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzIG9yIGBmYWxzZWAgb24gZmFpbC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIHRlc3QgKHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcbiAgdGhpcy5fX2luZGV4X18gPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgbGV0IG0sIG1sLCBtZSwgbGVuLCBzaGlmdCwgbmV4dCwgcmUsIHRsZF9wb3MsIGF0X3BvcztcblxuICAvLyB0cnkgdG8gc2NhbiBmb3IgbGluayB3aXRoIHNjaGVtYSAtIHRoYXQncyB0aGUgbW9zdCBzaW1wbGUgcnVsZVxuICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQpKSB7XG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2g7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgcmUubGFzdEluZGV4KTtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy5fX3NjaGVtYV9fID0gbVsyXTtcbiAgICAgICAgdGhpcy5fX2luZGV4X18gPSBtLmluZGV4ICsgbVsxXS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtLmluZGV4ICsgbVswXS5sZW5ndGggKyBsZW47XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlMaW5rICYmIHRoaXMuX19jb21waWxlZF9fWydodHRwOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBsaW5rc1xuICAgIHRsZF9wb3MgPSB0ZXh0LnNlYXJjaCh0aGlzLnJlLmhvc3RfZnV6enlfdGVzdCk7XG4gICAgaWYgKHRsZF9wb3MgPj0gMCkge1xuICAgICAgLy8gaWYgdGxkIGlzIGxvY2F0ZWQgYWZ0ZXIgZm91bmQgbGluayAtIG5vIG5lZWQgdG8gY2hlY2sgZnV6enkgcGF0dGVyblxuICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCB0bGRfcG9zIDwgdGhpcy5fX2luZGV4X18pIHtcbiAgICAgICAgaWYgKChtbCA9IHRleHQubWF0Y2godGhpcy5fX29wdHNfXy5mdXp6eUlQID8gdGhpcy5yZS5saW5rX2Z1enp5IDogdGhpcy5yZS5saW5rX25vX2lwX2Z1enp5KSkgIT09IG51bGwpIHtcbiAgICAgICAgICBzaGlmdCA9IG1sLmluZGV4ICsgbWxbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gPSAnJztcbiAgICAgICAgICAgIHRoaXMuX19pbmRleF9fID0gc2hpZnQ7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlFbWFpbCAmJiB0aGlzLl9fY29tcGlsZWRfX1snbWFpbHRvOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBlbWFpbHNcbiAgICBhdF9wb3MgPSB0ZXh0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgIC8vIFdlIGNhbid0IHNraXAgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGlzIGNhc2VzIGFyZSBwb3NzaWJsZTpcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cbiAgICAgIGlmICgobWUgPSB0ZXh0Lm1hdGNoKHRoaXMucmUuZW1haWxfZnV6enkpKSAhPT0gbnVsbCkge1xuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ID0gbWUuaW5kZXggKyBtZVswXS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8XG4gICAgICAgICAgICAoc2hpZnQgPT09IHRoaXMuX19pbmRleF9fICYmIG5leHQgPiB0aGlzLl9fbGFzdF9pbmRleF9fKSkge1xuICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyA9ICdtYWlsdG86JztcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyA9IHNoaWZ0O1xuICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX19pbmRleF9fID49IDBcbn07XG5cbi8qKlxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFZlcnkgcXVpY2sgY2hlY2ssIHRoYXQgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzLiBSZXR1cm5zIHRydWUgaWYgbGluayBNQVkgQkVcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxuICogbGluayBOT1QgZXhpc3RzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCAodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dClcbn07XG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0ICh0ZXh0LCBzY2hlbWEsIHBvcykge1xuICAvLyBJZiBub3Qgc3VwcG9ydGVkIHNjaGVtYSBjaGVjayByZXF1ZXN0ZWQgLSB0ZXJtaW5hdGVcbiAgaWYgKCF0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0pIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKVxufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAodGV4dCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHNoaWZ0ID0gMDtcblxuICAvLyBUcnkgdG8gdGFrZSBwcmV2aW91cyBlbGVtZW50IGZyb20gY2FjaGUsIGlmIC50ZXN0KCkgY2FsbGVkIGJlZm9yZVxuICBpZiAodGhpcy5fX2luZGV4X18gPj0gMCAmJiB0aGlzLl9fdGV4dF9jYWNoZV9fID09PSB0ZXh0KSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcbiAgICBzaGlmdCA9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICAvLyBDdXQgaGVhZCBpZiBjYWNoZSB3YXMgdXNlZFxuICBsZXQgdGFpbCA9IHNoaWZ0ID8gdGV4dC5zbGljZShzaGlmdCkgOiB0ZXh0O1xuXG4gIC8vIFNjYW4gc3RyaW5nIHVudGlsIGVuZCByZWFjaGVkXG4gIHdoaWxlICh0aGlzLnRlc3QodGFpbCkpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuXG4gICAgdGFpbCA9IHRhaWwuc2xpY2UodGhpcy5fX2xhc3RfaW5kZXhfXyk7XG4gICAgc2hpZnQgKz0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogTGlua2lmeUl0I21hdGNoQXRTdGFydCh0ZXh0KSAtPiBNYXRjaHxudWxsXG4gKlxuICogUmV0dXJucyBmdWxseS1mb3JtZWQgKG5vdCBmdXp6eSkgbGluayBpZiBpdCBzdGFydHMgYXQgdGhlIGJlZ2lubmluZ1xuICogb2YgdGhlIHN0cmluZywgYW5kIG51bGwgb3RoZXJ3aXNlLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5tYXRjaEF0U3RhcnQgPSBmdW5jdGlvbiBtYXRjaEF0U3RhcnQgKHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcbiAgdGhpcy5fX2luZGV4X18gPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IG0gPSB0aGlzLnJlLnNjaGVtYV9hdF9zdGFydC5leGVjKHRleHQpO1xuICBpZiAoIW0pIHJldHVybiBudWxsXG5cbiAgY29uc3QgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgbVswXS5sZW5ndGgpO1xuICBpZiAoIWxlbikgcmV0dXJuIG51bGxcblxuICB0aGlzLl9fc2NoZW1hX18gPSBtWzJdO1xuICB0aGlzLl9faW5kZXhfXyA9IG0uaW5kZXggKyBtWzFdLmxlbmd0aDtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG0uaW5kZXggKyBtWzBdLmxlbmd0aCArIGxlbjtcblxuICByZXR1cm4gY3JlYXRlTWF0Y2godGhpcywgMClcbn07XG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzIChsaXN0LCBrZWVwT2xkKSB7XG4gIGxpc3QgPSBBcnJheS5pc0FycmF5KGxpc3QpID8gbGlzdCA6IFtsaXN0XTtcblxuICBpZiAoIWtlZXBPbGQpIHtcbiAgICB0aGlzLl9fdGxkc19fID0gbGlzdC5zbGljZSgpO1xuICAgIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSB0cnVlO1xuICAgIGNvbXBpbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHRoaXMuX190bGRzX18gPSB0aGlzLl9fdGxkc19fLmNvbmNhdChsaXN0KVxuICAgIC5zb3J0KClcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbCwgaWR4LCBhcnIpIHtcbiAgICAgIHJldHVybiBlbCAhPT0gYXJyW2lkeCAtIDFdXG4gICAgfSlcbiAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzXG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCNub3JtYWxpemUobWF0Y2gpXG4gKlxuICogRGVmYXVsdCBub3JtYWxpemVyIChpZiBzY2hlbWEgZG9lcyBub3QgZGVmaW5lIGl0J3Mgb3duKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplIChtYXRjaCkge1xuICAvLyBEbyBtaW5pbWFsIHBvc3NpYmxlIGNoYW5nZXMgYnkgZGVmYXVsdC4gTmVlZCB0byBjb2xsZWN0IGZlZWRiYWNrIHByaW9yXG4gIC8vIHRvIG1vdmUgZm9yd2FyZCBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbGlua2lmeS1pdC9pc3N1ZXMvMVxuXG4gIGlmICghbWF0Y2guc2NoZW1hKSB7IG1hdGNoLnVybCA9ICdodHRwOi8vJyArIG1hdGNoLnVybDsgfVxuXG4gIGlmIChtYXRjaC5zY2hlbWEgPT09ICdtYWlsdG86JyAmJiAhL15tYWlsdG86L2kudGVzdChtYXRjaC51cmwpKSB7XG4gICAgbWF0Y2gudXJsID0gJ21haWx0bzonICsgbWF0Y2gudXJsO1xuICB9XG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCNvbkNvbXBpbGUoKVxuICpcbiAqIE92ZXJyaWRlIHRvIG1vZGlmeSBiYXNpYyBSZWdFeHAtcy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUub25Db21waWxlID0gZnVuY3Rpb24gb25Db21waWxlICgpIHtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2lmeUl0O1xuIl0sIm5hbWVzIjpbInVjX21pY3JvIiwicmVxdWlyZSIsInJlRmFjdG9yeSIsIm9wdHMiLCJyZSIsInNyY19BbnkiLCJBbnkiLCJzb3VyY2UiLCJzcmNfQ2MiLCJDYyIsInNyY19aIiwiWiIsInNyY19QIiwiUCIsInNyY19aUENjIiwiam9pbiIsInNyY19aQ2MiLCJ0ZXh0X3NlcGFyYXRvcnMiLCJzcmNfcHNldWRvX2xldHRlciIsInNyY19pcDQiLCJzcmNfYXV0aCIsInNyY19wb3J0Iiwic3JjX2hvc3RfdGVybWluYXRvciIsInNyY19wYXRoIiwic3JjX2VtYWlsX25hbWUiLCJzcmNfeG4iLCJzcmNfZG9tYWluX3Jvb3QiLCJzcmNfZG9tYWluIiwic3JjX2hvc3QiLCJ0cGxfaG9zdF9mdXp6eSIsInRwbF9ob3N0X25vX2lwX2Z1enp5Iiwic3JjX2hvc3Rfc3RyaWN0IiwidHBsX2hvc3RfZnV6enlfc3RyaWN0Iiwic3JjX2hvc3RfcG9ydF9zdHJpY3QiLCJ0cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfZnV6enlfdGVzdCIsInRwbF9lbWFpbF9mdXp6eSIsInRwbF9saW5rX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJhc3NpZ24iLCJvYmoiLCJzb3VyY2VzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsIl9jbGFzcyIsInRvU3RyaW5nIiwiaXNTdHJpbmciLCJpc09iamVjdCIsImlzUmVnRXhwIiwiaXNGdW5jdGlvbiIsImVzY2FwZVJFIiwic3RyIiwicmVwbGFjZSIsImRlZmF1bHRPcHRpb25zIiwiZnV6enlMaW5rIiwiZnV6enlFbWFpbCIsImZ1enp5SVAiLCJpc09wdGlvbnNPYmoiLCJyZWR1Y2UiLCJhY2MiLCJrIiwiaGFzT3duUHJvcGVydHkiLCJkZWZhdWx0U2NoZW1hcyIsInZhbGlkYXRlIiwidGV4dCIsInBvcyIsInNlbGYiLCJ0YWlsIiwiaHR0cCIsIlJlZ0V4cCIsInRlc3QiLCJtYXRjaCIsImxlbmd0aCIsIm5vX2h0dHAiLCJtYWlsdG8iLCJ0bGRzXzJjaF9zcmNfcmUiLCJ0bGRzX2RlZmF1bHQiLCJzcGxpdCIsInJlc2V0U2NhbkNhY2hlIiwiX19pbmRleF9fIiwiX190ZXh0X2NhY2hlX18iLCJjcmVhdGVWYWxpZGF0b3IiLCJjcmVhdGVOb3JtYWxpemVyIiwibm9ybWFsaXplIiwiY29tcGlsZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJwdXNoIiwic3JjX3RsZHMiLCJ1bnRwbCIsInRwbCIsImVtYWlsX2Z1enp5IiwibGlua19mdXp6eSIsImxpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJhbGlhc2VzIiwiX19jb21waWxlZF9fIiwic2NoZW1hRXJyb3IiLCJuYW1lIiwidmFsIiwiRXJyb3IiLCJfX3NjaGVtYXNfXyIsImNvbXBpbGVkIiwibGluayIsImFsaWFzIiwic2xpc3QiLCJmaWx0ZXIiLCJtYXAiLCJzY2hlbWFfdGVzdCIsInNjaGVtYV9zZWFyY2giLCJzY2hlbWFfYXRfc3RhcnQiLCJwcmV0ZXN0IiwiTWF0Y2giLCJzaGlmdCIsInN0YXJ0IiwiZW5kIiwiX19sYXN0X2luZGV4X18iLCJzY2hlbWEiLCJfX3NjaGVtYV9fIiwidG9Mb3dlckNhc2UiLCJpbmRleCIsImxhc3RJbmRleCIsInJhdyIsInVybCIsImNyZWF0ZU1hdGNoIiwiTGlua2lmeUl0Iiwic2NoZW1hcyIsIm9wdGlvbnMiLCJhZGQiLCJkZWZpbml0aW9uIiwic2V0IiwibSIsIm1sIiwibWUiLCJsZW4iLCJuZXh0IiwidGxkX3BvcyIsImF0X3BvcyIsImV4ZWMiLCJ0ZXN0U2NoZW1hQXQiLCJzZWFyY2giLCJpbmRleE9mIiwicmVzdWx0IiwibWF0Y2hBdFN0YXJ0IiwibGlzdCIsImtlZXBPbGQiLCJpc0FycmF5IiwiY29uY2F0Iiwic29ydCIsImVsIiwiaWR4IiwiYXJyIiwicmV2ZXJzZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/linkify-it/build/index.cjs.js\n");

/***/ })

};
;